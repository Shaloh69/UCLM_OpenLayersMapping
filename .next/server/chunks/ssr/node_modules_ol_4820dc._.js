module.exports = {

"[project]/node_modules/ol/math.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/math
 */ /**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */ __turbopack_esm__({
    "ceil": (()=>ceil),
    "clamp": (()=>clamp),
    "floor": (()=>floor),
    "lerp": (()=>lerp),
    "modulo": (()=>modulo),
    "round": (()=>round),
    "solveLinearSystem": (()=>solveLinearSystem),
    "squaredDistance": (()=>squaredDistance),
    "squaredSegmentDistance": (()=>squaredSegmentDistance),
    "toDegrees": (()=>toDegrees),
    "toFixed": (()=>toFixed),
    "toRadians": (()=>toRadians),
    "wrap": (()=>wrap)
});
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        } else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
    const n = mat.length;
    for(let i = 0; i < n; i++){
        // Find max in the i-th column (ignoring i - 1 first rows)
        let maxRow = i;
        let maxEl = Math.abs(mat[i][i]);
        for(let r = i + 1; r < n; r++){
            const absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) {
            return null; // matrix is singular
        }
        // Swap max row with i-th (current) row
        const tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for(let j = i + 1; j < n; j++){
            const coef = -mat[j][i] / mat[i][i];
            for(let k = i; k < n + 1; k++){
                if (i == k) {
                    mat[j][k] = 0;
                } else {
                    mat[j][k] += coef * mat[i][k];
                }
            }
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    const x = new Array(n);
    for(let l = n - 1; l >= 0; l--){
        x[l] = mat[l][n] / mat[l][l];
        for(let m = l - 1; m >= 0; m--){
            mat[m][n] -= mat[m][l] * x[l];
        }
    }
    return x;
}
function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
    const r = a % b;
    return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
    return a + x * (b - a);
}
function toFixed(n, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
}
function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
}
function wrap(n, min, max) {
    if (n >= min && n < max) {
        return n;
    }
    const range = max - min;
    return ((n - min) % range + range) % range + min;
}
}}),
"[project]/node_modules/ol/proj/Units.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/Units
 */ /**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */ /**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */ __turbopack_esm__({
    "METERS_PER_UNIT": (()=>METERS_PER_UNIT),
    "fromCode": (()=>fromCode)
});
const unitByCode = {
    '9001': 'm',
    '9002': 'ft',
    '9003': 'us-ft',
    '9101': 'radians',
    '9102': 'degrees'
};
function fromCode(code) {
    return unitByCode[code];
}
const METERS_PER_UNIT = {
    // use the radius of the Normal sphere
    'radians': 6370997 / (2 * Math.PI),
    'degrees': 2 * Math.PI * 6370997 / 360,
    'ft': 0.3048,
    'm': 1,
    'us-ft': 1200 / 3937
};
}}),
"[project]/node_modules/ol/proj/Projection.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/Projection
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Units.js [app-ssr] (ecmascript)");
;
/**
 * The function is called with a `number` view resolution and a
 * {@link module:ol/coordinate~Coordinate} as arguments, and returns the `number` resolution
 * in projection units at the passed coordinate.
 * @typedef {function(number, import("../coordinate.js").Coordinate):number} GetPointResolution
 * @api
 */ /**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {GetPointResolution} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */ /**
 * @classdesc
 * In most cases, you should not need to create instances of this class.
 * Instead, where projection information is required, you can use a string
 * projection code or identifier (e.g. `EPSG:4326`) instead of a projection
 * instance.
 *
 * The library includes support for transforming coordinates between the following
 * projections:
 *
 *  WGS 84 / Geographic - Using codes `EPSG:4326`, `CRS:84`, `urn:ogc:def:crs:EPSG:6.6:4326`,
 *    `urn:ogc:def:crs:OGC:1.3:CRS84`, `urn:ogc:def:crs:OGC:2:84`, `http://www.opengis.net/gml/srs/epsg.xml#4326`,
 *    or `urn:x-ogc:def:crs:EPSG:4326`
 *  WGS 84 / Spherical Mercator - Using codes `EPSG:3857`, `EPSG:102100`, `EPSG:102113`, `EPSG:900913`,
 *    `urn:ogc:def:crs:EPSG:6.18:3:3857`, or `http://www.opengis.net/gml/srs/epsg.xml#3857`
 *  WGS 84 / UTM zones - Using codes `EPSG:32601` through `EPSG:32660` for northern zones
 *    and `EPSG:32701` through `EPSG:32760` for southern zones. Note that the built-in UTM transforms
 *    are lower accuracy (with errors on the order of 0.1 m) than those that you might get in a
 *    library like [proj4js](https://github.com/proj4js/proj4js).
 *
 * For additional projection support, or to use higher accuracy transforms than the built-in ones, you can use
 * the [proj4js](https://github.com/proj4js/proj4js) library. With `proj4js`, after adding any new projection
 * definitions, call the {@link module:ol/proj/proj4.register} function.
 *
 * You can use the {@link module:ol/proj.get} function to retrieve a projection instance
 * for one of the registered projections.
 *
 * @api
 */ class Projection {
    /**
   * @param {Options} options Projection options.
   */ constructor(options){
        /**
     * @private
     * @type {string}
     */ this.code_ = options.code;
        /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */ this.units_ = options.units;
        /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
        /**
     * @private
     * @type {string}
     */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
     * @private
     * @type {boolean}
     */ this.global_ = options.global !== undefined ? options.global : false;
        /**
     * @private
     * @type {boolean}
     */ this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
     * @private
     * @type {GetPointResolution|undefined}
     */ this.getPointResolutionFunc_ = options.getPointResolution;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.defaultTileGrid_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */ canWrapX() {
        return this.canWrapX_;
    }
    /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */ getCode() {
        return this.code_;
    }
    /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */ getUnits() {
        return this.units_;
    }
    /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */ getMetersPerUnit() {
        return this.metersPerUnit_ || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METERS_PER_UNIT"][this.units_];
    }
    /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getWorldExtent() {
        return this.worldExtent_;
    }
    /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */ getAxisOrientation() {
        return this.axisOrientation_;
    }
    /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */ isGlobal() {
        return this.global_;
    }
    /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */ setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    }
    /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */ getDefaultTileGrid() {
        return this.defaultTileGrid_;
    }
    /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */ setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    }
    /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */ setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
    }
    /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */ setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
    }
    /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */ getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
    }
}
const __TURBOPACK__default__export__ = Projection;
}}),
"[project]/node_modules/ol/proj/utm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/utm
 */ /**
 * Adapted from https://github.com/Turbo87/utm
 * Copyright (c) 2012-2017 Tobias Bieniek
 *
 * The functions here provide approximate transforms to and from UTM.
 * They are not appropriate for use beyond the validity extend of a UTM
 * zone, and the accuracy of the transform decreases toward the zone
 * edges.
 */ __turbopack_esm__({
    "makeProjection": (()=>makeProjection),
    "makeTransforms": (()=>makeTransforms),
    "zoneFromCode": (()=>zoneFromCode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Projection.js [app-ssr] (ecmascript)");
;
;
/**
 * @typedef {Object} UTMZone
 * @property {number} number The zone number (1 - 60).
 * @property {boolean} north The northern hemisphere.
 */ const K0 = 0.9996;
const E = 0.00669438;
const E2 = E * E;
const E3 = E2 * E;
const E_P2 = E / (1 - E);
const SQRT_E = Math.sqrt(1 - E);
const _E = (1 - SQRT_E) / (1 + SQRT_E);
const _E2 = _E * _E;
const _E3 = _E2 * _E;
const _E4 = _E3 * _E;
const _E5 = _E4 * _E;
const M1 = 1 - E / 4 - 3 * E2 / 64 - 5 * E3 / 256;
const M2 = 3 * E / 8 + 3 * E2 / 32 + 45 * E3 / 1024;
const M3 = 15 * E2 / 256 + 45 * E3 / 1024;
const M4 = 35 * E3 / 3072;
const P2 = 3 / 2 * _E - 27 / 32 * _E3 + 269 / 512 * _E5;
const P3 = 21 / 16 * _E2 - 55 / 32 * _E4;
const P4 = 151 / 96 * _E3 - 417 / 128 * _E5;
const P5 = 1097 / 512 * _E4;
const R = 6378137;
/**
 * @param {number} easting Easting value of coordinate.
 * @param {number} northing Northing value of coordinate.
 * @param {UTMZone} zone The UTM zone.
 * @return {import("../coordinate.js").Coordinate} The transformed coordinate.
 */ function toLonLat(easting, northing, zone) {
    const x = easting - 500000;
    const y = zone.north ? northing : northing - 10000000;
    const m = y / K0;
    const mu = m / (R * M1);
    const pRad = mu + P2 * Math.sin(2 * mu) + P3 * Math.sin(4 * mu) + P4 * Math.sin(6 * mu) + P5 * Math.sin(8 * mu);
    const pSin = Math.sin(pRad);
    const pSin2 = pSin * pSin;
    const pCos = Math.cos(pRad);
    const pTan = pSin / pCos;
    const pTan2 = pTan * pTan;
    const pTan4 = pTan2 * pTan2;
    const epSin = 1 - E * pSin2;
    const epSinSqrt = Math.sqrt(1 - E * pSin2);
    const n = R / epSinSqrt;
    const r = (1 - E) / epSin;
    const c = E_P2 * pCos ** 2;
    const c2 = c * c;
    const d = x / (n * K0);
    const d2 = d * d;
    const d3 = d2 * d;
    const d4 = d3 * d;
    const d5 = d4 * d;
    const d6 = d5 * d;
    const latitude = pRad - pTan / r * (d2 / 2 - d4 / 24 * (5 + 3 * pTan2 + 10 * c - 4 * c2 - 9 * E_P2)) + d6 / 720 * (61 + 90 * pTan2 + 298 * c + 45 * pTan4 - 252 * E_P2 - 3 * c2);
    let longitude = (d - d3 / 6 * (1 + 2 * pTan2 + c) + d5 / 120 * (5 - 2 * c + 28 * pTan2 - 3 * c2 + 8 * E_P2 + 24 * pTan4)) / pCos;
    longitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrap"])(longitude + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(zoneToCentralLongitude(zone.number)), -Math.PI, Math.PI);
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toDegrees"])(longitude),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toDegrees"])(latitude)
    ];
}
const MIN_LATITUDE = -80;
const MAX_LATITUDE = 84;
const MIN_LONGITUDE = -180;
const MAX_LONGITUDE = 180;
/**
 * @param {number} longitude The longitude.
 * @param {number} latitude The latitude.
 * @param {UTMZone} zone The UTM zone.
 * @return {import('../coordinate.js').Coordinate} The UTM coordinate.
 */ function fromLonLat(longitude, latitude, zone) {
    longitude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrap"])(longitude, MIN_LONGITUDE, MAX_LONGITUDE);
    if (latitude < MIN_LATITUDE) {
        latitude = MIN_LATITUDE;
    } else if (latitude > MAX_LATITUDE) {
        latitude = MAX_LATITUDE;
    }
    const latRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(latitude);
    const latSin = Math.sin(latRad);
    const latCos = Math.cos(latRad);
    const latTan = latSin / latCos;
    const latTan2 = latTan * latTan;
    const latTan4 = latTan2 * latTan2;
    const lonRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(longitude);
    const centralLon = zoneToCentralLongitude(zone.number);
    const centralLonRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(centralLon);
    const n = R / Math.sqrt(1 - E * latSin ** 2);
    const c = E_P2 * latCos ** 2;
    const a = latCos * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrap"])(lonRad - centralLonRad, -Math.PI, Math.PI);
    const a2 = a * a;
    const a3 = a2 * a;
    const a4 = a3 * a;
    const a5 = a4 * a;
    const a6 = a5 * a;
    const m = R * (M1 * latRad - M2 * Math.sin(2 * latRad) + M3 * Math.sin(4 * latRad) - M4 * Math.sin(6 * latRad));
    const easting = K0 * n * (a + a3 / 6 * (1 - latTan2 + c) + a5 / 120 * (5 - 18 * latTan2 + latTan4 + 72 * c - 58 * E_P2)) + 500000;
    let northing = K0 * (m + n * latTan * (a2 / 2 + a4 / 24 * (5 - latTan2 + 9 * c + 4 * c ** 2) + a6 / 720 * (61 - 58 * latTan2 + latTan4 + 600 * c - 330 * E_P2)));
    if (!zone.north) {
        northing += 10000000;
    }
    return [
        easting,
        northing
    ];
}
/**
 * @param {number} zone The zone number.
 * @return {number} The central longitude in degrees.
 */ function zoneToCentralLongitude(zone) {
    return (zone - 1) * 6 - 180 + 3;
}
/**
 * @type {Array<RegExp>}
 */ const epsgRegExes = [
    /^EPSG:(\d+)$/,
    /^urn:ogc:def:crs:EPSG::(\d+)$/,
    /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function zoneFromCode(code) {
    let epsgId = 0;
    for (const re of epsgRegExes){
        const match = code.match(re);
        if (match) {
            epsgId = parseInt(match[1]);
            break;
        }
    }
    if (!epsgId) {
        return null;
    }
    let number = 0;
    let north = false;
    if (epsgId > 32700 && epsgId < 32761) {
        number = epsgId - 32700;
    } else if (epsgId > 32600 && epsgId < 32661) {
        north = true;
        number = epsgId - 32600;
    }
    if (!number) {
        return null;
    }
    return {
        number,
        north
    };
}
/**
 * @param {function(number, number, UTMZone): import('../coordinate.js').Coordinate} transformer The transformer.
 * @param {UTMZone} zone The UTM zone.
 * @return {import('../proj.js').TransformFunction} The transform function.
 */ function makeTransformFunction(transformer, zone) {
    return function(input, output, dimension, stride) {
        const length = input.length;
        dimension = dimension > 1 ? dimension : 2;
        stride = stride ?? dimension;
        if (!output) {
            if (dimension > 2) {
                output = input.slice();
            } else {
                output = new Array(length);
            }
        }
        for(let i = 0; i < length; i += stride){
            const x = input[i];
            const y = input[i + 1];
            const coord = transformer(x, y, zone);
            output[i] = coord[0];
            output[i + 1] = coord[1];
        }
        return output;
    };
}
function makeProjection(code) {
    const zone = zoneFromCode(code);
    if (!zone) {
        return null;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]({
        code,
        units: 'm'
    });
}
function makeTransforms(projection) {
    const zone = zoneFromCode(projection.getCode());
    if (!zone) {
        return null;
    }
    return {
        forward: makeTransformFunction(fromLonLat, zone),
        inverse: makeTransformFunction(toLonLat, zone)
    };
}
}}),
"[project]/node_modules/ol/proj/projections.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/projections
 */ /**
 * @type {Object<string, import("./Projection.js").default>}
 */ __turbopack_esm__({
    "add": (()=>add),
    "clear": (()=>clear),
    "get": (()=>get)
});
let cache = {};
function clear() {
    cache = {};
}
function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
function add(code, projection) {
    cache[code] = projection;
}
}}),
"[project]/node_modules/ol/proj/transforms.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/transforms
 */ __turbopack_esm__({
    "add": (()=>add),
    "clear": (()=>clear),
    "get": (()=>get),
    "remove": (()=>remove)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
;
/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */ let transforms = {};
function clear() {
    transforms = {};
}
function add(source, destination, transformFn) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) {
        transforms[sourceCode] = {};
    }
    transforms[sourceCode][destinationCode] = transformFn;
}
function remove(source, destination) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    const transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(transforms[sourceCode])) {
        delete transforms[sourceCode];
    }
    return transform;
}
function get(sourceCode, destinationCode) {
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
        return transforms[sourceCode][destinationCode];
    }
    return null;
}
}}),
"[project]/node_modules/ol/proj/epsg3857.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/epsg3857
 */ __turbopack_esm__({
    "EXTENT": (()=>EXTENT),
    "HALF_SIZE": (()=>HALF_SIZE),
    "MAX_SAFE_Y": (()=>MAX_SAFE_Y),
    "PROJECTIONS": (()=>PROJECTIONS),
    "RADIUS": (()=>RADIUS),
    "WORLD_EXTENT": (()=>WORLD_EXTENT),
    "fromEPSG4326": (()=>fromEPSG4326),
    "toEPSG4326": (()=>toEPSG4326)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Projection.js [app-ssr] (ecmascript)");
;
const RADIUS = 6378137;
const HALF_SIZE = Math.PI * RADIUS;
const EXTENT = [
    -HALF_SIZE,
    -HALF_SIZE,
    HALF_SIZE,
    HALF_SIZE
];
const WORLD_EXTENT = [
    -180,
    -85,
    180,
    85
];
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */ class EPSG3857Projection extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} code Code.
   */ constructor(code){
        super({
            code: code,
            units: 'm',
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(resolution, point) {
                return resolution / Math.cosh(point[1] / RADIUS);
            }
        });
    }
}
const PROJECTIONS = [
    new EPSG3857Projection('EPSG:3857'),
    new EPSG3857Projection('EPSG:102100'),
    new EPSG3857Projection('EPSG:102113'),
    new EPSG3857Projection('EPSG:900913'),
    new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];
function fromEPSG4326(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        } else {
            output = new Array(length);
        }
    }
    for(let i = 0; i < length; i += stride){
        output[i] = HALF_SIZE * input[i] / 180;
        let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
        if (y > MAX_SAFE_Y) {
            y = MAX_SAFE_Y;
        } else if (y < -MAX_SAFE_Y) {
            y = -MAX_SAFE_Y;
        }
        output[i + 1] = y;
    }
    return output;
}
function toEPSG4326(input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        } else {
            output = new Array(length);
        }
    }
    for(let i = 0; i < length; i += stride){
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
}
}}),
"[project]/node_modules/ol/proj/epsg4326.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj/epsg4326
 */ __turbopack_esm__({
    "EXTENT": (()=>EXTENT),
    "METERS_PER_UNIT": (()=>METERS_PER_UNIT),
    "PROJECTIONS": (()=>PROJECTIONS),
    "RADIUS": (()=>RADIUS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Projection.js [app-ssr] (ecmascript)");
;
const RADIUS = 6378137;
const EXTENT = [
    -180,
    -90,
    180,
    90
];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */ class EPSG4326Projection extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Projection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */ constructor(code, axisOrientation){
        super({
            code: code,
            units: 'degrees',
            extent: EXTENT,
            axisOrientation: axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        });
    }
}
const PROJECTIONS = [
    new EPSG4326Projection('CRS:84'),
    new EPSG4326Projection('EPSG:4326', 'neu'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
    new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')
];
}}),
"[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/obj
 */ /**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */ __turbopack_esm__({
    "clear": (()=>clear),
    "isEmpty": (()=>isEmpty)
});
function clear(object) {
    for(const property in object){
        delete object[property];
    }
}
function isEmpty(object) {
    let property;
    for(property in object){
        return false;
    }
    return !property;
}
}}),
"[project]/node_modules/ol/sphere.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/sphere
 */ __turbopack_esm__({
    "DEFAULT_RADIUS": (()=>DEFAULT_RADIUS),
    "getArea": (()=>getArea),
    "getDistance": (()=>getDistance),
    "getLength": (()=>getLength),
    "offset": (()=>offset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
;
const DEFAULT_RADIUS = 6371008.8;
function getDistance(c1, c2, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(c1[1]);
    const lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(c2[1]);
    const deltaLatBy2 = (lat2 - lat1) / 2;
    const deltaLonBy2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(c2[0] - c1[0]) / 2;
    const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */ function getLengthInternal(coordinates, radius) {
    let length = 0;
    for(let i = 0, ii = coordinates.length; i < ii - 1; ++i){
        length += getDistance(coordinates[i], coordinates[i + 1], radius);
    }
    return length;
}
function getLength(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    let length = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
            {
                break;
            }
        case 'LineString':
        case 'LinearRing':
            {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
                length = getLengthInternal(coordinates, radius);
                break;
            }
        case 'MultiLineString':
        case 'Polygon':
            {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
                for(i = 0, ii = coordinates.length; i < ii; ++i){
                    length += getLengthInternal(coordinates[i], radius);
                }
                break;
            }
        case 'MultiPolygon':
            {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
                for(i = 0, ii = coordinates.length; i < ii; ++i){
                    coords = coordinates[i];
                    for(j = 0, jj = coords.length; j < jj; ++j){
                        length += getLengthInternal(coords[j], radius);
                    }
                }
                break;
            }
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i){
                    length += getLength(geometries[i], options);
                }
                break;
            }
        default:
            {
                throw new Error('Unsupported geometry type: ' + type);
            }
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */ function getAreaInternal(coordinates, radius) {
    let area = 0;
    const len = coordinates.length;
    let x1 = coordinates[len - 1][0];
    let y1 = coordinates[len - 1][1];
    for(let i = 0; i < len; i++){
        const x2 = coordinates[i][0];
        const y2 = coordinates[i][1];
        area += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(x2 - x1) * (2 + Math.sin((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(y1)) + Math.sin((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(y2)));
        x1 = x2;
        y1 = y2;
    }
    return area * radius * radius / 2.0;
}
function getArea(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    let area = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
        case 'LinearRing':
            {
                break;
            }
        case 'Polygon':
            {
                coordinates = /** @type {import("./geom/Polygon.js").default} */ geometry.getCoordinates();
                area = Math.abs(getAreaInternal(coordinates[0], radius));
                for(i = 1, ii = coordinates.length; i < ii; ++i){
                    area -= Math.abs(getAreaInternal(coordinates[i], radius));
                }
                break;
            }
        case 'MultiPolygon':
            {
                coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
                for(i = 0, ii = coordinates.length; i < ii; ++i){
                    coords = coordinates[i];
                    area += Math.abs(getAreaInternal(coords[0], radius));
                    for(j = 1, jj = coords.length; j < jj; ++j){
                        area -= Math.abs(getAreaInternal(coords[j], radius));
                    }
                }
                break;
            }
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i){
                    area += getArea(geometries[i], options);
                }
                break;
            }
        default:
            {
                throw new Error('Unsupported geometry type: ' + type);
            }
    }
    return area;
}
function offset(c1, distance, bearing, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(c1[1]);
    const lon1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(c1[0]);
    const dByR = distance / radius;
    const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toDegrees"])(lon),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toDegrees"])(lat)
    ];
}
}}),
"[project]/node_modules/ol/extent/Relationship.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/extent/Relationship
 */ /**
 * Relationship to an extent.
 * @enum {number}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};
}}),
"[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/extent
 */ __turbopack_esm__({
    "applyTransform": (()=>applyTransform),
    "approximatelyEquals": (()=>approximatelyEquals),
    "boundingExtent": (()=>boundingExtent),
    "buffer": (()=>buffer),
    "clone": (()=>clone),
    "closestSquaredDistanceXY": (()=>closestSquaredDistanceXY),
    "containsCoordinate": (()=>containsCoordinate),
    "containsExtent": (()=>containsExtent),
    "containsXY": (()=>containsXY),
    "coordinateRelationship": (()=>coordinateRelationship),
    "createEmpty": (()=>createEmpty),
    "createOrUpdate": (()=>createOrUpdate),
    "createOrUpdateEmpty": (()=>createOrUpdateEmpty),
    "createOrUpdateFromCoordinate": (()=>createOrUpdateFromCoordinate),
    "createOrUpdateFromCoordinates": (()=>createOrUpdateFromCoordinates),
    "createOrUpdateFromFlatCoordinates": (()=>createOrUpdateFromFlatCoordinates),
    "createOrUpdateFromRings": (()=>createOrUpdateFromRings),
    "equals": (()=>equals),
    "extend": (()=>extend),
    "extendCoordinate": (()=>extendCoordinate),
    "extendCoordinates": (()=>extendCoordinates),
    "extendFlatCoordinates": (()=>extendFlatCoordinates),
    "extendRings": (()=>extendRings),
    "extendXY": (()=>extendXY),
    "forEachCorner": (()=>forEachCorner),
    "getArea": (()=>getArea),
    "getBottomLeft": (()=>getBottomLeft),
    "getBottomRight": (()=>getBottomRight),
    "getCenter": (()=>getCenter),
    "getCorner": (()=>getCorner),
    "getEnlargedArea": (()=>getEnlargedArea),
    "getForViewAndSize": (()=>getForViewAndSize),
    "getHeight": (()=>getHeight),
    "getIntersection": (()=>getIntersection),
    "getIntersectionArea": (()=>getIntersectionArea),
    "getMargin": (()=>getMargin),
    "getRotatedViewport": (()=>getRotatedViewport),
    "getSize": (()=>getSize),
    "getTopLeft": (()=>getTopLeft),
    "getTopRight": (()=>getTopRight),
    "getWidth": (()=>getWidth),
    "intersects": (()=>intersects),
    "intersectsSegment": (()=>intersectsSegment),
    "isEmpty": (()=>isEmpty),
    "returnOrUpdate": (()=>returnOrUpdate),
    "scaleFromCenter": (()=>scaleFromCenter),
    "wrapAndSliceX": (()=>wrapAndSliceX),
    "wrapX": (()=>wrapX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent/Relationship.js [app-ssr] (ecmascript)");
;
function boundingExtent(coordinates) {
    const extent = createEmpty();
    for(let i = 0, ii = coordinates.length; i < ii; ++i){
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */ function _boundingExtentXYs(xs, ys, dest) {
    const minX = Math.min.apply(null, xs);
    const minY = Math.min.apply(null, ys);
    const maxX = Math.max.apply(null, xs);
    const maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
    if (dest) {
        dest[0] = extent[0] - value;
        dest[1] = extent[1] - value;
        dest[2] = extent[2] + value;
        dest[3] = extent[3] + value;
        return dest;
    }
    return [
        extent[0] - value,
        extent[1] - value,
        extent[2] + value,
        extent[3] + value
    ];
}
function clone(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
    let dx, dy;
    if (x < extent[0]) {
        dx = extent[0] - x;
    } else if (extent[2] < x) {
        dx = x - extent[2];
    } else {
        dx = 0;
    }
    if (y < extent[1]) {
        dy = extent[1] - y;
    } else if (extent[3] < y) {
        dy = y - extent[3];
    } else {
        dy = 0;
    }
    return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const x = coordinate[0];
    const y = coordinate[1];
    let relationship = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].UNKNOWN;
    if (x < minX) {
        relationship = relationship | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LEFT;
    } else if (x > maxX) {
        relationship = relationship | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RIGHT;
    }
    if (y < minY) {
        relationship = relationship | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].BELOW;
    } else if (y > maxY) {
        relationship = relationship | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ABOVE;
    }
    if (relationship === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].UNKNOWN) {
        relationship = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERSECTING;
    }
    return relationship;
}
function createEmpty() {
    return [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
    if (dest) {
        dest[0] = minX;
        dest[1] = minY;
        dest[2] = maxX;
        dest[3] = maxY;
        return dest;
    }
    return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
    const x = coordinate[0];
    const y = coordinate[1];
    return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendCoordinates(extent, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendRings(extent, rings);
}
function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
        extent1[0] = extent2[0];
    }
    if (extent2[2] > extent1[2]) {
        extent1[2] = extent2[2];
    }
    if (extent2[1] < extent1[1]) {
        extent1[1] = extent2[1];
    }
    if (extent2[3] > extent1[3]) {
        extent1[3] = extent2[3];
    }
    return extent1;
}
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) {
        extent[0] = coordinate[0];
    }
    if (coordinate[0] > extent[2]) {
        extent[2] = coordinate[0];
    }
    if (coordinate[1] < extent[1]) {
        extent[1] = coordinate[1];
    }
    if (coordinate[1] > extent[3]) {
        extent[3] = coordinate[1];
    }
}
function extendCoordinates(extent, coordinates) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i){
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for(; offset < end; offset += stride){
        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    }
    return extent;
}
function extendRings(extent, rings) {
    for(let i = 0, ii = rings.length; i < ii; ++i){
        extendCoordinates(extent, rings[i]);
    }
    return extent;
}
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
    let val;
    val = callback(getBottomLeft(extent));
    if (val) {
        return val;
    }
    val = callback(getBottomRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopLeft(extent));
    if (val) {
        return val;
    }
    return false;
}
function getArea(extent) {
    let area = 0;
    if (!isEmpty(extent)) {
        area = getWidth(extent) * getHeight(extent);
    }
    return area;
}
function getBottomLeft(extent) {
    return [
        extent[0],
        extent[1]
    ];
}
function getBottomRight(extent) {
    return [
        extent[2],
        extent[1]
    ];
}
function getCenter(extent) {
    return [
        (extent[0] + extent[2]) / 2,
        (extent[1] + extent[3]) / 2
    ];
}
function getCorner(extent, corner) {
    let coordinate;
    if (corner === 'bottom-left') {
        coordinate = getBottomLeft(extent);
    } else if (corner === 'bottom-right') {
        coordinate = getBottomRight(extent);
    } else if (corner === 'top-left') {
        coordinate = getTopLeft(extent);
    } else if (corner === 'top-right') {
        coordinate = getTopRight(extent);
    } else {
        throw new Error('Invalid corner');
    }
    return coordinate;
}
function getEnlargedArea(extent1, extent2) {
    const minX = Math.min(extent1[0], extent2[0]);
    const minY = Math.min(extent1[1], extent2[1]);
    const maxX = Math.max(extent1[2], extent2[2]);
    const maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
function getRotatedViewport(center, resolution, rotation, size) {
    const dx = resolution * size[0] / 2;
    const dy = resolution * size[1] / 2;
    const cosRotation = Math.cos(rotation);
    const sinRotation = Math.sin(rotation);
    const xCos = dx * cosRotation;
    const xSin = dx * sinRotation;
    const yCos = dy * cosRotation;
    const ySin = dy * sinRotation;
    const x = center[0];
    const y = center[1];
    return [
        x - xCos + ySin,
        y - xSin - yCos,
        x - xCos - ySin,
        y - xSin + yCos,
        x + xCos - ySin,
        y + xSin + yCos,
        x + xCos + ySin,
        y + xSin - yCos,
        x - xCos + ySin,
        y - xSin - yCos
    ];
}
function getHeight(extent) {
    return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
    const intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
    const intersection = dest ? dest : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) {
            intersection[0] = extent1[0];
        } else {
            intersection[0] = extent2[0];
        }
        if (extent1[1] > extent2[1]) {
            intersection[1] = extent1[1];
        } else {
            intersection[1] = extent2[1];
        }
        if (extent1[2] < extent2[2]) {
            intersection[2] = extent1[2];
        } else {
            intersection[2] = extent2[2];
        }
        if (extent1[3] < extent2[3]) {
            intersection[3] = extent1[3];
        } else {
            intersection[3] = extent2[3];
        }
    } else {
        createOrUpdateEmpty(intersection);
    }
    return intersection;
}
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
    return [
        extent[2] - extent[0],
        extent[3] - extent[1]
    ];
}
function getTopLeft(extent) {
    return [
        extent[0],
        extent[3]
    ];
}
function getTopRight(extent) {
    return [
        extent[2],
        extent[3]
    ];
}
function getWidth(extent) {
    return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent;
}
function scaleFromCenter(extent, value) {
    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
    let intersects = false;
    const startRel = coordinateRelationship(extent, start);
    const endRel = coordinateRelationship(extent, end);
    if (startRel === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERSECTING || endRel === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERSECTING) {
        intersects = true;
    } else {
        const minX = extent[0];
        const minY = extent[1];
        const maxX = extent[2];
        const maxY = extent[3];
        const startX = start[0];
        const startY = start[1];
        const endX = end[0];
        const endY = end[1];
        const slope = (endY - startY) / (endX - startX);
        let x, y;
        if (!!(endRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ABOVE) && !(startRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RIGHT) && !(startRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects && !!(endRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].BELOW) && !(startRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LEFT) && !(startRel & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2f$Relationship$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
function applyTransform(extent, transformFn, dest, stops) {
    if (isEmpty(extent)) {
        return createOrUpdateEmpty(dest);
    }
    let coordinates = [];
    if (stops > 1) {
        const width = extent[2] - extent[0];
        const height = extent[3] - extent[1];
        for(let i = 0; i < stops; ++i){
            coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
        }
    } else {
        coordinates = [
            extent[0],
            extent[1],
            extent[2],
            extent[1],
            extent[2],
            extent[3],
            extent[0],
            extent[3]
        ];
    }
    transformFn(coordinates, coordinates, 2);
    const xs = [];
    const ys = [];
    for(let i = 0, l = coordinates.length; i < l; i += 2){
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
    const projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        const worldWidth = getWidth(projectionExtent);
        const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        const offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
    if (projection.canWrapX()) {
        const projectionExtent = projection.getExtent();
        if (!isFinite(extent[0]) || !isFinite(extent[2])) {
            return [
                [
                    projectionExtent[0],
                    extent[1],
                    projectionExtent[2],
                    extent[3]
                ]
            ];
        }
        wrapX(extent, projection);
        const worldWidth = getWidth(projectionExtent);
        if (getWidth(extent) > worldWidth && !multiWorld) {
            // the extent wraps around on itself
            return [
                [
                    projectionExtent[0],
                    extent[1],
                    projectionExtent[2],
                    extent[3]
                ]
            ];
        }
        if (extent[0] < projectionExtent[0]) {
            // the extent crosses the anti meridian, so it needs to be sliced
            return [
                [
                    extent[0] + worldWidth,
                    extent[1],
                    projectionExtent[2],
                    extent[3]
                ],
                [
                    projectionExtent[0],
                    extent[1],
                    extent[2],
                    extent[3]
                ]
            ];
        }
        if (extent[2] > projectionExtent[2]) {
            // the extent crosses the anti meridian, so it needs to be sliced
            return [
                [
                    extent[0],
                    extent[1],
                    projectionExtent[2],
                    extent[3]
                ],
                [
                    projectionExtent[0],
                    extent[1],
                    extent[2] - worldWidth,
                    extent[3]
                ]
            ];
        }
    }
    return [
        extent
    ];
}
}}),
"[project]/node_modules/ol/string.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/string
 */ /**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */ __turbopack_esm__({
    "compareVersions": (()=>compareVersions),
    "padNumber": (()=>padNumber)
});
function padNumber(number, width, precision) {
    const numberString = precision !== undefined ? number.toFixed(precision) : '' + number;
    let decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
function compareVersions(v1, v2) {
    const s1 = ('' + v1).split('.');
    const s2 = ('' + v2).split('.');
    for(let i = 0; i < Math.max(s1.length, s2.length); i++){
        const n1 = parseInt(s1[i] || '0', 10);
        const n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) {
            return 1;
        }
        if (n2 > n1) {
            return -1;
        }
    }
    return 0;
}
}}),
"[project]/node_modules/ol/coordinate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/coordinate
 */ __turbopack_esm__({
    "add": (()=>add),
    "closestOnCircle": (()=>closestOnCircle),
    "closestOnSegment": (()=>closestOnSegment),
    "createStringXY": (()=>createStringXY),
    "degreesToStringHDMS": (()=>degreesToStringHDMS),
    "distance": (()=>distance),
    "equals": (()=>equals),
    "format": (()=>format),
    "getWorldsAway": (()=>getWorldsAway),
    "rotate": (()=>rotate),
    "scale": (()=>scale),
    "squaredDistance": (()=>squaredDistance),
    "squaredDistanceToSegment": (()=>squaredDistanceToSegment),
    "toStringHDMS": (()=>toStringHDMS),
    "toStringXY": (()=>toStringXY),
    "wrapX": (()=>wrapX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
;
;
;
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
function closestOnCircle(coordinate, circle) {
    const r = circle.getRadius();
    const center = circle.getCenter();
    const x0 = center[0];
    const y0 = center[1];
    const x1 = coordinate[0];
    const y1 = coordinate[1];
    let dx = x1 - x0;
    const dy = y1 - y0;
    if (dx === 0 && dy === 0) {
        dx = 1;
    }
    const d = Math.sqrt(dx * dx + dy * dy);
    const x = x0 + r * dx / d;
    const y = y0 + r * dy / d;
    return [
        x,
        y
    ];
}
function closestOnSegment(coordinate, segment) {
    const x0 = coordinate[0];
    const y0 = coordinate[1];
    const start = segment[0];
    const end = segment[1];
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    let x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    } else if (along >= 1) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [
        x,
        y
    ];
}
function createStringXY(fractionDigits) {
    return(/**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */ function(coordinate) {
        return toStringXY(coordinate, fractionDigits);
    });
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
    const normalizedDegrees = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modulo"])(degrees + 180, 360) - 180;
    const x = Math.abs(3600 * normalizedDegrees);
    const decimals = fractionDigits || 0;
    let deg = Math.floor(x / 3600);
    let min = Math.floor((x - deg * 3600) / 60);
    let sec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFixed"])(x - deg * 3600 - min * 60, decimals);
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    let hdms = deg + '\u00b0';
    if (min !== 0 || sec !== 0) {
        hdms += ' ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["padNumber"])(min, 2) + '\u2032';
    }
    if (sec !== 0) {
        hdms += ' ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["padNumber"])(sec, 2, decimals) + '\u2033';
    }
    if (normalizedDegrees !== 0) {
        hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    }
    return hdms;
}
function format(coordinate, template, fractionDigits) {
    if (coordinate) {
        return template.replace('{x}', coordinate[0].toFixed(fractionDigits)).replace('{y}', coordinate[1].toFixed(fractionDigits));
    }
    return '';
}
function equals(coordinate1, coordinate2) {
    let equals = true;
    for(let i = coordinate1.length - 1; i >= 0; --i){
        if (coordinate1[i] != coordinate2[i]) {
            equals = false;
            break;
        }
    }
    return equals;
}
function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
function squaredDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    const dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
    if (coordinate) {
        return degreesToStringHDMS('NS', coordinate[1], fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], fractionDigits);
    }
    return '';
}
function toStringXY(coordinate, fractionDigits) {
    return format(coordinate, '{x}, {y}', fractionDigits);
}
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        const worldWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projection.getExtent());
        const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) {
            coordinate[0] -= worldsAway * worldWidth;
        }
    }
    return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        sourceExtentWidth = sourceExtentWidth || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}
}}),
"[project]/node_modules/ol/console.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/console
 */ /**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */ /**
 * @type {Object<Level, number>}
 */ __turbopack_esm__({
    "error": (()=>error),
    "log": (()=>log),
    "setLevel": (()=>setLevel),
    "warn": (()=>warn)
});
const levels = {
    info: 1,
    warn: 2,
    error: 3,
    none: 4
};
/**
 * @type {number}
 */ let level = levels.info;
function setLevel(l) {
    level = levels[l];
}
function log(...args) {
    if (level > levels.info) {
        return;
    }
    console.log(...args); // eslint-disable-line no-console
}
function warn(...args) {
    if (level > levels.warn) {
        return;
    }
    console.warn(...args); // eslint-disable-line no-console
}
function error(...args) {
    if (level > levels.error) {
        return;
    }
    console.error(...args); // eslint-disable-line no-console
}
}}),
"[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/proj
 */ /**
 * The ol/proj module stores:
 * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */ __turbopack_esm__({
    "addCommon": (()=>addCommon),
    "addCoordinateTransforms": (()=>addCoordinateTransforms),
    "addEquivalentProjections": (()=>addEquivalentProjections),
    "addEquivalentTransforms": (()=>addEquivalentTransforms),
    "addProjection": (()=>addProjection),
    "addProjections": (()=>addProjections),
    "clearAllProjections": (()=>clearAllProjections),
    "clearUserProjection": (()=>clearUserProjection),
    "cloneTransform": (()=>cloneTransform),
    "createProjection": (()=>createProjection),
    "createSafeCoordinateTransform": (()=>createSafeCoordinateTransform),
    "createTransformFromCoordinateTransform": (()=>createTransformFromCoordinateTransform),
    "disableCoordinateWarning": (()=>disableCoordinateWarning),
    "equivalent": (()=>equivalent),
    "fromLonLat": (()=>fromLonLat),
    "fromUserCoordinate": (()=>fromUserCoordinate),
    "fromUserExtent": (()=>fromUserExtent),
    "fromUserResolution": (()=>fromUserResolution),
    "get": (()=>get),
    "getPointResolution": (()=>getPointResolution),
    "getTransform": (()=>getTransform),
    "getTransformFromProjections": (()=>getTransformFromProjections),
    "getUserProjection": (()=>getUserProjection),
    "identityTransform": (()=>identityTransform),
    "setUserProjection": (()=>setUserProjection),
    "toLonLat": (()=>toLonLat),
    "toUserCoordinate": (()=>toUserCoordinate),
    "toUserExtent": (()=>toUserExtent),
    "toUserResolution": (()=>toUserResolution),
    "transform": (()=>transform),
    "transformExtent": (()=>transformExtent),
    "transformWithProjections": (()=>transformWithProjections),
    "useGeographic": (()=>useGeographic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$utm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/utm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$projections$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/projections.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/transforms.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$sphere$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/sphere.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Units.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$console$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/console.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg3857$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/epsg3857.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg4326$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/epsg4326.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */ /**
 * @typedef {Object} Transforms
 * @property {TransformFunction} forward The forward transform (from geographic).
 * @property {TransformFunction} inverse The inverse transform (to geographic).
 */ /**
 * @type {Array<function(Projection): Transforms|null>}
 */ const transformFactories = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$utm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeTransforms"]
];
/**
 * @type {Array<function(string): Projection|null>}
 */ const projectionFactories = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$utm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeProjection"]
];
;
;
let showCoordinateWarning = true;
function disableCoordinateWarning(disable) {
    const hide = disable === undefined ? true : disable;
    showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
    if (output !== undefined) {
        for(let i = 0, ii = input.length; i < ii; ++i){
            output[i] = input[i];
        }
        output = output;
    } else {
        output = input.slice();
    }
    return output;
}
function identityTransform(input, output) {
    if (output !== undefined && input !== output) {
        for(let i = 0, ii = input.length; i < ii; ++i){
            output[i] = input[i];
        }
        input = output;
    }
    return input;
}
function addProjection(projection) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$projections$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(projection.getCode(), projection);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(projection, projection, cloneTransform);
}
function addProjections(projections) {
    projections.forEach(addProjection);
}
function get(projectionLike) {
    if (!(typeof projectionLike === 'string')) {
        return projectionLike;
    }
    const projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$projections$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(projectionLike);
    if (projection) {
        return projection;
    }
    for (const makeProjection of projectionFactories){
        const projection = makeProjection(projectionLike);
        if (projection) {
            return projection;
        }
    }
    return null;
}
function getPointResolution(projection, resolution, point, units) {
    projection = get(projection);
    let pointResolution;
    const getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (units && units !== projection.getUnits()) {
            const metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) {
                pointResolution = pointResolution * metersPerUnit / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METERS_PER_UNIT"][units];
            }
        }
    } else {
        const projUnits = projection.getUnits();
        if (projUnits == 'degrees' && !units || units == 'degrees') {
            pointResolution = resolution;
        } else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            const toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
            if (!toEPSG4326 && projUnits !== 'degrees') {
                // no transform is available
                pointResolution = resolution * projection.getMetersPerUnit();
            } else {
                let vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2
                ];
                vertices = toEPSG4326(vertices, vertices, 2);
                const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$sphere$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
                const height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$sphere$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            const metersPerUnit = units ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METERS_PER_UNIT"][units] : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) {
                pointResolution /= metersPerUnit;
            }
        }
    }
    return pointResolution;
}
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
        projections.forEach(function(destination) {
            if (source !== destination) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(source, destination, cloneTransform);
            }
        });
    });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(projection1, projection2, forwardTransform);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(projection2, projection1, inverseTransform);
        });
    });
}
function clearAllProjections() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$projections$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])();
}
function createProjection(projection, defaultCode) {
    if (!projection) {
        return get(defaultCode);
    }
    if (typeof projection === 'string') {
        return get(projection);
    }
    return projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
    return(/**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */ function(input, output, dimension, stride) {
        const length = input.length;
        dimension = dimension !== undefined ? dimension : 2;
        stride = stride ?? dimension;
        output = output !== undefined ? output : new Array(length);
        for(let i = 0; i < length; i += stride){
            const point = coordTransform(input.slice(i, i + dimension));
            const pointLength = point.length;
            for(let j = 0, jj = stride; j < jj; ++j){
                output[i + j] = j >= pointLength ? input[i + j] : point[j];
            }
        }
        return output;
    });
}
function addCoordinateTransforms(source, destination, forward, inverse) {
    const sourceProj = get(source);
    const destProj = get(destination);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');
}
function toLonLat(coordinate, projection) {
    const lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');
    const lon = lonLat[0];
    if (lon < -180 || lon > 180) {
        lonLat[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modulo"])(lon + 180, 360) - 180;
    }
    return lonLat;
}
function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
        return true;
    }
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) {
        return equalUnits;
    }
    const transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(source, destination) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    let transformFunc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(sourceCode, destinationCode);
    if (transformFunc) {
        return transformFunc;
    }
    /**
   * @type {Transforms|null}
   */ let sourceTransforms = null;
    /**
   * @type {Transforms|null}
   */ let destinationTransforms = null;
    // lazily add projections if we have supported transforms
    for (const makeTransforms of transformFactories){
        if (!sourceTransforms) {
            sourceTransforms = makeTransforms(source);
        }
        if (!destinationTransforms) {
            destinationTransforms = makeTransforms(destination);
        }
    }
    if (!sourceTransforms && !destinationTransforms) {
        return null;
    }
    const intermediateCode = 'EPSG:4326';
    if (!destinationTransforms) {
        const toDestination = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(intermediateCode, destinationCode);
        if (toDestination) {
            transformFunc = composeTransformFuncs(sourceTransforms.inverse, toDestination);
        }
    } else if (!sourceTransforms) {
        const fromSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(sourceCode, intermediateCode);
        if (fromSource) {
            transformFunc = composeTransformFuncs(fromSource, destinationTransforms.forward);
        }
    } else {
        transformFunc = composeTransformFuncs(sourceTransforms.inverse, destinationTransforms.forward);
    }
    if (transformFunc) {
        addProjection(source);
        addProjection(destination);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(source, destination, transformFunc);
    }
    return transformFunc;
}
/**
 * @param {TransformFunction} t1 The first transform function.
 * @param {TransformFunction} t2 The second transform function.
 * @return {TransformFunction} The composed transform function.
 */ function composeTransformFuncs(t1, t2) {
    return function(input, output, dimensions, stride) {
        output = t1(input, output, dimensions, stride);
        return t2(output, output, dimensions, stride);
    };
}
function getTransform(source, destination) {
    const sourceProjection = get(source);
    const destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    if (!transformFunc) {
        const sourceCode = get(source).getCode();
        const destinationCode = get(destination).getCode();
        throw new Error(`No transform available between ${sourceCode} and ${destinationCode}`);
    }
    return transformFunc(coordinate, undefined, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
    const transformFunc = getTransform(source, destination);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyTransform"])(extent, transformFunc, undefined, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
    const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {Projection|null}
 */ let userProjection = null;
function setUserProjection(projection) {
    userProjection = get(projection);
}
function clearUserProjection() {
    userProjection = null;
}
function getUserProjection() {
    return userProjection;
}
function useGeographic() {
    setUserProjection('EPSG:4326');
}
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) {
        return coordinate;
    }
    return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        if (showCoordinateWarning && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(coordinate, [
            0,
            0
        ]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
            showCoordinateWarning = false;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$console$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
        }
        return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) {
        return resolution;
    }
    const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) {
        return resolution;
    }
    const destMetersPerUnit = get(destProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function(coord) {
        let transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            const sourceExtent = sourceProj.getExtent();
            const sourceExtentWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(sourceExtent);
            coord = coord.slice(0);
            worldsAway = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWorldsAway"])(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) {
                // Move x to the real world
                coord[0] = coord[0] - worldsAway * sourceExtentWidth;
            }
            coord[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(coord[0], sourceExtent[0], sourceExtent[2]);
            coord[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(coord[1], sourceExtent[1], sourceExtent[3]);
            transformed = transform(coord);
        } else {
            transformed = transform(coord);
        }
        if (worldsAway && destProj.canWrapX()) {
            // Move transformed coordinate back to the offset world
            transformed[0] += worldsAway * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(destProj.getExtent());
        }
        return transformed;
    };
}
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg3857$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROJECTIONS"]);
    addEquivalentProjections(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg4326$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROJECTIONS"]);
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg4326$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROJECTIONS"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg3857$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROJECTIONS"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg3857$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromEPSG4326"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$epsg3857$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toEPSG4326"]);
}
addCommon();
}}),
"[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: require } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/ol/util.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/util
 */ /**
 * @return {never} Any return.
 */ __turbopack_esm__({
    "VERSION": (()=>VERSION),
    "abstract": (()=>abstract),
    "getUid": (()=>getUid)
});
function abstract() {
    throw new Error('Unimplemented abstract method.');
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */ let uidCounter_ = 0;
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
const VERSION = '10.4.0';
}}),
"[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/asserts
 */ /**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */ __turbopack_esm__({
    "assert": (()=>assert)
});
function assert(assertion, errorMessage) {
    if (!assertion) {
        throw new Error(errorMessage);
    }
}
}}),
"[project]/node_modules/ol/transform.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/transform
 */ __turbopack_esm__({
    "apply": (()=>apply),
    "compose": (()=>compose),
    "composeCssTransform": (()=>composeCssTransform),
    "create": (()=>create),
    "determinant": (()=>determinant),
    "invert": (()=>invert),
    "makeInverse": (()=>makeInverse),
    "makeScale": (()=>makeScale),
    "multiply": (()=>multiply),
    "reset": (()=>reset),
    "rotate": (()=>rotate),
    "scale": (()=>scale),
    "set": (()=>set),
    "setFromArray": (()=>setFromArray),
    "toString": (()=>toString),
    "translate": (()=>translate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
;
/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */ /**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 33 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */ /**
 * @private
 * @type {Transform}
 */ const tmp_ = new Array(6);
function create() {
    return [
        1,
        0,
        0,
        1,
        0,
        0
    ];
}
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
    const a1 = transform1[0];
    const b1 = transform1[1];
    const c1 = transform1[2];
    const d1 = transform1[3];
    const e1 = transform1[4];
    const f1 = transform1[5];
    const a2 = transform2[0];
    const b2 = transform2[1];
    const c2 = transform2[2];
    const d2 = transform2[3];
    const e2 = transform2[4];
    const f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
function apply(transform, coordinate) {
    const x = coordinate[0];
    const y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
function rotate(transform, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
    return makeInverse(source, source);
}
function makeInverse(target, source) {
    const det = determinant(source);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(det !== 0, 'Transformation matrix cannot be inverted');
    const a = source[0];
    const b = source[1];
    const c = source[2];
    const d = source[3];
    const e = source[4];
    const f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {Array}
 */ const matrixPrecision = [
    1e6,
    1e6,
    1e6,
    1e6,
    2,
    2
];
function toString(mat) {
    const transformString = 'matrix(' + mat.map((value, i)=>Math.round(value * matrixPrecision[i]) / matrixPrecision[i]).join(', ') + ')';
    return transformString;
}
}}),
"[project]/node_modules/ol/array.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/array
 */ /**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */ __turbopack_esm__({
    "ascending": (()=>ascending),
    "binarySearch": (()=>binarySearch),
    "descending": (()=>descending),
    "equals": (()=>equals),
    "extend": (()=>extend),
    "isSorted": (()=>isSorted),
    "linearFindNearest": (()=>linearFindNearest),
    "remove": (()=>remove),
    "reverseSubArray": (()=>reverseSubArray),
    "stableSort": (()=>stableSort)
});
function binarySearch(haystack, needle, comparator) {
    let mid, cmp;
    comparator = comparator || ascending;
    let low = 0;
    let high = haystack.length;
    let found = false;
    while(low < high){
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */ mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) {
            /* Too low. */ low = mid + 1;
        } else {
            /* Key found or too high */ high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */ return found ? low : ~low;
}
function ascending(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
    if (arr[0] <= target) {
        return 0;
    }
    const n = arr.length;
    if (target <= arr[n - 1]) {
        return n - 1;
    }
    if (typeof direction === 'function') {
        for(let i = 1; i < n; ++i){
            const candidate = arr[i];
            if (candidate === target) {
                return i;
            }
            if (candidate < target) {
                if (direction(target, arr[i - 1], candidate) > 0) {
                    return i - 1;
                }
                return i;
            }
        }
        return n - 1;
    }
    if (direction > 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] < target) {
                return i - 1;
            }
        }
        return n - 1;
    }
    if (direction < 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] <= target) {
                return i;
            }
        }
        return n - 1;
    }
    for(let i = 1; i < n; ++i){
        if (arr[i] == target) {
            return i;
        }
        if (arr[i] < target) {
            if (arr[i - 1] - target < target - arr[i]) {
                return i - 1;
            }
            return i;
        }
    }
    return n - 1;
}
function reverseSubArray(arr, begin, end) {
    while(begin < end){
        const tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
function extend(arr, data) {
    const extension = Array.isArray(data) ? data : [
        data
    ];
    const length = extension.length;
    for(let i = 0; i < length; i++){
        arr[arr.length] = extension[i];
    }
}
function remove(arr, obj) {
    const i = arr.indexOf(obj);
    const found = i > -1;
    if (found) {
        arr.splice(i, 1);
    }
    return found;
}
function equals(arr1, arr2) {
    const len1 = arr1.length;
    if (len1 !== arr2.length) {
        return false;
    }
    for(let i = 0; i < len1; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function stableSort(arr, compareFnc) {
    const length = arr.length;
    const tmp = Array(arr.length);
    let i;
    for(i = 0; i < length; i++){
        tmp[i] = {
            index: i,
            value: arr[i]
        };
    }
    tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for(i = 0; i < arr.length; i++){
        arr[i] = tmp[i].value;
    }
}
function isSorted(arr, func, strict) {
    const compare = func || ascending;
    return arr.every(function(currentVal, index) {
        if (index === 0) {
            return true;
        }
        const res = compare(arr[index - 1], currentVal);
        return !(res > 0 || strict && res === 0);
    });
}
}}),
"[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/functions
 */ __turbopack_esm__({
    "FALSE": (()=>FALSE),
    "TRUE": (()=>TRUE),
    "VOID": (()=>VOID),
    "memoizeOne": (()=>memoizeOne),
    "toPromise": (()=>toPromise)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
;
function TRUE() {
    return true;
}
function FALSE() {
    return false;
}
function VOID() {}
function memoizeOne(fn) {
    /** @type {ReturnType} */ let lastResult;
    /** @type {Array<any>|undefined} */ let lastArgs;
    let lastThis;
    /**
   * @this {*} Only need to know if `this` changed, don't care what type
   * @return {ReturnType} Memoized value
   */ return function() {
        const nextArgs = Array.prototype.slice.call(arguments);
        if (!lastArgs || this !== lastThis || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(nextArgs, lastArgs)) {
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}
function toPromise(getter) {
    function promiseGetter() {
        let value;
        try {
            value = getter();
        } catch (err) {
            return Promise.reject(err);
        }
        if (value instanceof Promise) {
            return value;
        }
        return Promise.resolve(value);
    }
    return promiseGetter();
}
}}),
"[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events/Event
 */ /**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "preventDefault": (()=>preventDefault),
    "stopPropagation": (()=>stopPropagation)
});
class BaseEvent {
    /**
   * @param {string} type Type.
   */ constructor(type){
        /**
     * @type {boolean}
     */ this.propagationStopped;
        /**
     * @type {boolean}
     */ this.defaultPrevented;
        /**
     * The event type.
     * @type {string}
     * @api
     */ this.type = type;
        /**
     * The event target.
     * @type {Object}
     * @api
     */ this.target = null;
    }
    /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */ preventDefault() {
        this.defaultPrevented = true;
    }
    /**
   * Stop event propagation.
   * @api
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
function stopPropagation(evt) {
    evt.stopPropagation();
}
function preventDefault(evt) {
    evt.preventDefault();
}
const __TURBOPACK__default__export__ = BaseEvent;
}}),
"[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events/EventType
 */ /**
 * @enum {string}
 * @const
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */ CHANGE: 'change',
    /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */ ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel'
};
}}),
"[project]/node_modules/ol/events/Target.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events/Target
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Disposable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Disposable.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */ /**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */ class Target extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Disposable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {*} [target] Default event target for dispatched events.
   */ constructor(target){
        super();
        /**
     * @private
     * @type {*}
     */ this.eventTarget_ = target;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.pendingRemovals_ = null;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.dispatching_ = null;
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */ this.listeners_ = null;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ addEventListener(type, listener) {
        if (!type || !listener) {
            return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
            listenersForType.push(listener);
        }
    }
    /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */ dispatchEvent(event) {
        const isString = typeof event === 'string';
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
            return;
        }
        const evt = isString ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](event) : event;
        if (!evt.target) {
            evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
            dispatching[type] = 0;
            pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for(let i = 0, ii = listeners.length; i < ii; ++i){
            if ('handleEvent' in listeners[i]) {
                propagate = /** @type {import("../events.js").ListenerObject} */ listeners[i].handleEvent(evt);
            } else {
                propagate = /** @type {import("../events.js").ListenerFunction} */ listeners[i].call(this, evt);
            }
            if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
            }
        }
        if (--dispatching[type] === 0) {
            let pr = pendingRemovals[type];
            delete pendingRemovals[type];
            while(pr--){
                this.removeEventListener(type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"]);
            }
            delete dispatching[type];
        }
        return propagate;
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        this.listeners_ && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])(this.listeners_);
    }
    /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */ getListeners(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
    }
    /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */ hasListener(type) {
        if (!this.listeners_) {
            return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ removeEventListener(type, listener) {
        if (!this.listeners_) {
            return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
            return;
        }
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                // make listener a no-op, and remove later in #dispatchEvent()
                listeners[index] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"];
                ++this.pendingRemovals_[type];
            } else {
                listeners.splice(index, 1);
                if (listeners.length === 0) {
                    delete this.listeners_[type];
                }
            }
        }
    }
}
const __TURBOPACK__default__export__ = Target;
}}),
"[project]/node_modules/ol/events/condition.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events/condition
 */ __turbopack_esm__({
    "all": (()=>all),
    "altKeyOnly": (()=>altKeyOnly),
    "altShiftKeysOnly": (()=>altShiftKeysOnly),
    "always": (()=>always),
    "click": (()=>click),
    "doubleClick": (()=>doubleClick),
    "focus": (()=>focus),
    "focusWithTabindex": (()=>focusWithTabindex),
    "mouseActionButton": (()=>mouseActionButton),
    "mouseOnly": (()=>mouseOnly),
    "never": (()=>never),
    "noModifierKeys": (()=>noModifierKeys),
    "penOnly": (()=>penOnly),
    "platformModifierKey": (()=>platformModifierKey),
    "platformModifierKeyOnly": (()=>platformModifierKeyOnly),
    "pointerMove": (()=>pointerMove),
    "primaryAction": (()=>primaryAction),
    "shiftKeyOnly": (()=>shiftKeyOnly),
    "singleClick": (()=>singleClick),
    "targetNotEditable": (()=>targetNotEditable),
    "touchOnly": (()=>touchOnly)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
;
;
;
;
function all(var_args) {
    const conditions = arguments;
    /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */ return function(event) {
        let pass = true;
        for(let i = 0, ii = conditions.length; i < ii; ++i){
            pass = pass && conditions[i](event);
            if (!pass) {
                break;
            }
        }
        return pass;
    };
}
const altKeyOnly = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const altShiftKeysOnly = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
    const targetElement = event.map.getTargetElement();
    const rootNode = targetElement.getRootNode();
    const activeElement = event.map.getOwnerDocument().activeElement;
    return rootNode instanceof ShadowRoot ? rootNode.host.contains(activeElement) : targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
    const targetElement = event.map.getTargetElement();
    const rootNode = targetElement.getRootNode();
    const tabIndexCandidate = rootNode instanceof ShadowRoot ? rootNode.host : targetElement;
    return tabIndexCandidate.hasAttribute('tabindex') ? focus(event) : true;
};
const always = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRUE"];
const click = function(mapBrowserEvent) {
    return mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK;
};
const mouseActionButton = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WEBKIT"] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MAC"] && originalEvent.ctrlKey);
};
const never = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FALSE"];
const pointerMove = function(mapBrowserEvent) {
    return mapBrowserEvent.type == 'pointermove';
};
const singleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SINGLECLICK;
};
const doubleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DBLCLICK;
};
const noModifierKeys = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKeyOnly = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MAC"] ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKey = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MAC"] ? originalEvent.metaKey : originalEvent.ctrlKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
    const originalEvent = mapBrowserEvent.originalEvent;
    const tagName = /** @type {Element} */ originalEvent.target.tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == 'mouse';
};
const touchOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'touch';
};
const penOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'pen';
};
const primaryAction = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};
}}),
"[project]/node_modules/ol/events/Key.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events/Key
 */ /**
 * @enum {string}
 * @const
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown'
};
}}),
"[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/ObjectEventType
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */ PROPERTYCHANGE: 'propertychange'
};
 /**
 * @typedef {'propertychange'} Types
 */ }}),
"[project]/node_modules/ol/events.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/events
 */ __turbopack_esm__({
    "listen": (()=>listen),
    "listenOnce": (()=>listenOnce),
    "unlistenByKey": (()=>unlistenByKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
;
function listen(target, type, listener, thisArg, once) {
    if (once) {
        const originalListener = listener;
        /**
     * @param {Event|import('./events/Event.js').default} event The event
     * @return {void|boolean} When the function returns `false`, event propagation will stop.
     * @this {typeof target}
     */ listener = function(event) {
            target.removeEventListener(type, listener);
            return originalListener.call(thisArg ?? this, event);
        };
    } else if (thisArg && thisArg !== target) {
        listener = listener.bind(thisArg);
    }
    const eventsKey = {
        target: target,
        type: type,
        listener: listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])(key);
    }
}
}}),
"[project]/node_modules/ol/Disposable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Disposable
 */ /**
 * @classdesc
 * Objects that need to clean up after themselves.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class Disposable {
    constructor(){
        /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */ this.disposed = false;
    }
    /**
   * Clean up.
   */ dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    }
    /**
   * Extension point for disposable objects.
   * @protected
   */ disposeInternal() {}
}
const __TURBOPACK__default__export__ = Disposable;
}}),
"[project]/node_modules/ol/Observable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Observable
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "unByKey": (()=>unByKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Target.js [app-ssr] (ecmascript)");
;
;
;
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */ /***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */ /**
 * @typedef {'change'|'error'} EventTypes
 */ /***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */ class Observable extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(){
        super();
        this.on = this.onInternal;
        this.once = this.onceInternal;
        this.un = this.unInternal;
        /**
     * @private
     * @type {number}
     */ this.revision_ = 0;
    }
    /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */ changed() {
        ++this.revision_;
        this.dispatchEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE);
    }
    /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */ getRevision() {
        return this.revision_;
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onInternal(type, listener) {
        if (Array.isArray(type)) {
            const len = type.length;
            const keys = new Array(len);
            for(let i = 0; i < len; ++i){
                keys[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(this, type[i], listener);
            }
            return keys;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(this, type, listener);
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
            const len = type.length;
            key = new Array(len);
            for(let i = 0; i < len; ++i){
                key[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listenOnce"])(this, type[i], listener);
            }
        } else {
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listenOnce"])(this, type, listener);
        }
        /** @type {Object} */ listener.ol_key = key;
        return key;
    }
    /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */ unInternal(type, listener) {
        const key = /** @type {Object} */ listener.ol_key;
        if (key) {
            unByKey(key);
        } else if (Array.isArray(type)) {
            for(let i = 0, ii = type.length; i < ii; ++i){
                this.removeEventListener(type[i], listener);
            }
        } else {
            this.removeEventListener(type, listener);
        }
    }
}
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */ Observable.prototype.un;
function unByKey(key) {
    if (Array.isArray(key)) {
        for(let i = 0, ii = key.length; i < ii; ++i){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(key[i]);
        }
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(key);
    }
}
const __TURBOPACK__default__export__ = Observable;
}}),
"[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Object
 */ __turbopack_esm__({
    "ObjectEvent": (()=>ObjectEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Observable.js [app-ssr] (ecmascript)");
;
;
;
;
;
class ObjectEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */ constructor(type, key, oldValue){
        super(type);
        /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */ this.key = key;
        /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */ this.oldValue = oldValue;
    }
}
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */ class BaseObject extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */ constructor(values){
        super();
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ObjectOnSignature<void>}
     */ this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(this);
        /**
     * @private
     * @type {Object<string, *>|null}
     */ this.values_ = null;
        if (values !== undefined) {
            this.setProperties(values);
        }
    }
    /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */ get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
            value = this.values_[key];
        }
        return value;
    }
    /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */ getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */ getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */ getPropertiesInternal() {
        return this.values_;
    }
    /**
   * @return {boolean} The object has properties.
   */ hasProperties() {
        return !!this.values_;
    }
    /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */ notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
    }
    /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
            values[key] = value;
        } else {
            const oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) {
                this.notify(key, oldValue);
            }
        }
    }
    /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ setProperties(values, silent) {
        for(const key in values){
            this.set(key, values[key], silent);
        }
    }
    /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */ applyProperties(source) {
        if (!source.values_) {
            return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */ unset(key, silent) {
        if (this.values_ && key in this.values_) {
            const oldValue = this.values_[key];
            delete this.values_[key];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(this.values_)) {
                this.values_ = null;
            }
            if (!silent) {
                this.notify(key, oldValue);
            }
        }
    }
}
const __TURBOPACK__default__export__ = BaseObject;
}}),
"[project]/node_modules/ol/Feature.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Feature
 */ __turbopack_esm__({
    "createStyleFunction": (()=>createStyleFunction),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */ /**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */ /***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */ /**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */ class Feature extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */ constructor(geometryOrProperties){
        super();
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {FeatureOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = undefined;
        /**
     * @type {string}
     * @private
     */ this.geometryName_ = 'geometry';
        /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */ this.style_ = null;
        /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */ this.styleFunction_ = undefined;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
            if (typeof /** @type {?} */ geometryOrProperties.getSimplifiedGeometry === 'function') {
                const geometry = geometryOrProperties;
                this.setGeometry(geometry);
            } else {
                /** @type {Object<string, *>} */ const properties = geometryOrProperties;
                this.setProperties(properties);
            }
        }
    }
    /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */ clone() {
        const clone = new Feature(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
            clone.setGeometry(geometry.clone());
        }
        const style = this.getStyle();
        if (style) {
            clone.setStyle(style);
        }
        return clone;
    }
    /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */ getGeometry() {
        return this.get(this.geometryName_);
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */ getGeometryName() {
        return this.geometryName_;
    }
    /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @private
   */ handleGeometryChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
            this.geometryChangeKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.handleGeometryChange_, this);
        }
        this.changed();
    }
    /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */ setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
    }
    /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
    }
    /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setId(id) {
        this.id_ = id;
        this.changed();
    }
    /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */ setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    }
}
function createStyleFunction(obj) {
    if (typeof obj === 'function') {
        return obj;
    }
    /**
   * @type {Array<import("./style/Style.js").default>}
   */ let styles;
    if (Array.isArray(obj)) {
        styles = obj;
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof /** @type {?} */ obj.getZIndex === 'function', 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`');
        const style = obj;
        styles = [
            style
        ];
    }
    return function() {
        return styles;
    };
}
const __TURBOPACK__default__export__ = Feature;
}}),
"[project]/node_modules/ol/format/Feature.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/format/Feature
 */ __turbopack_esm__({
    "createGeometry": (()=>createGeometry),
    "createRenderFeature": (()=>createRenderFeature),
    "default": (()=>__TURBOPACK__default__export__),
    "transformExtentWithOptions": (()=>transformExtentWithOptions),
    "transformGeometryWithOptions": (()=>transformGeometryWithOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Point$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/Point.js [app-ssr] (ecmascript) <export default as Point>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__LineString$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/LineString.js [app-ssr] (ecmascript) <export default as LineString>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Polygon$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/Polygon.js [app-ssr] (ecmascript) <export default as Polygon>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPoint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiPoint$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiPoint.js [app-ssr] (ecmascript) <export default as MultiPoint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiLineString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiLineString$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiLineString.js [app-ssr] (ecmascript) <export default as MultiLineString>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPolygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiPolygon$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiPolygon.js [app-ssr] (ecmascript) <export default as MultiPolygon>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$orient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/flat/orient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$GeometryCollection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__GeometryCollection$3e$__ = __turbopack_import__("[project]/node_modules/ol/geom/GeometryCollection.js [app-ssr] (ecmascript) <export default as GeometryCollection>");
;
;
;
;
;
;
/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */ /**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */ /**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */ /**
 * @typedef {Object} SimpleGeometryObject
 * @property {import('../geom/Geometry.js').Type} type Type.
 * @property {Array<number>} flatCoordinates Flat coordinates.
 * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.
 * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.
 */ /**
 * @typedef {Array<GeometryObject>} GeometryCollectionObject
 */ /**
 * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject
 */ /**
 * @typedef {Object} FeatureObject
 * @property {string|number} [id] Id.
 * @property {GeometryObject} [geometry] Geometry.
 * @property {Object<string, *>} [properties] Properties.
 */ /***
 * @template {import('../Feature.js').FeatureLike} T
 * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass
 */ /***
 * @template {import("../Feature.js").FeatureClass} T
 * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @abstract
 * @api
 */ class FeatureFormat {
    constructor(){
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.dataProjection = undefined;
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.defaultFeatureProjection = undefined;
        /**
     * @protected
     * @type {FeatureToFeatureClass<FeatureType>}
     */ this.featureClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
        /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */ this.supportedMediaTypes = null;
    }
    /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */ getReadOptions(source, options) {
        if (options) {
            let dataProjection = options.dataProjection ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.dataProjection) : this.readProjection(source);
            if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {
                dataProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(dataProjection);
                dataProjection.setWorldExtent(options.extent);
            }
            options = {
                dataProjection: dataProjection,
                featureProjection: options.featureProjection
            };
        }
        return this.adaptOptions(options);
    }
    /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */ adaptOptions(options) {
        return Object.assign({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
        }, options);
    }
    /**
   * @abstract
   * @return {Type} The format type.
   */ getType() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   */ readFeature(source, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   */ readFeatures(source, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */ readProjection(source) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeature(feature, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeatures(features, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeGeometry(geometry, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
}
const __TURBOPACK__default__export__ = FeatureFormat;
function transformGeometryWithOptions(geometry, write, options) {
    const featureProjection = options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.featureProjection) : null;
    const dataProjection = options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.dataProjection) : null;
    let transformed = geometry;
    if (featureProjection && dataProjection && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["equivalent"])(featureProjection, dataProjection)) {
        if (write) {
            transformed = geometry.clone();
        }
        const fromProjection = write ? featureProjection : dataProjection;
        const toProjection = write ? dataProjection : featureProjection;
        if (fromProjection.getUnits() === 'tile-pixels') {
            transformed.transform(fromProjection, toProjection);
        } else {
            transformed.applyTransform((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getTransform"])(fromProjection, toProjection));
        }
    }
    if (write && options && /** @type {WriteOptions} */ options.decimals !== undefined) {
        const power = Math.pow(10, /** @type {WriteOptions} */ options.decimals);
        // if decimals option on write, round each coordinate appropriately
        /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */ const transform = function(coordinates) {
            for(let i = 0, ii = coordinates.length; i < ii; ++i){
                coordinates[i] = Math.round(coordinates[i] * power) / power;
            }
            return coordinates;
        };
        if (transformed === geometry) {
            transformed = geometry.clone();
        }
        transformed.applyTransform(transform);
    }
    return transformed;
}
function transformExtentWithOptions(extent, options) {
    const featureProjection = options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.featureProjection) : null;
    const dataProjection = options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.dataProjection) : null;
    if (featureProjection && dataProjection && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["equivalent"])(featureProjection, dataProjection)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transformExtent"])(extent, dataProjection, featureProjection);
    }
    return extent;
}
const GeometryConstructor = {
    Point: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Point$3e$__["Point"],
    LineString: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__LineString$3e$__["LineString"],
    Polygon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Polygon$3e$__["Polygon"],
    MultiPoint: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPoint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiPoint$3e$__["MultiPoint"],
    MultiLineString: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiLineString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiLineString$3e$__["MultiLineString"],
    MultiPolygon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPolygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__MultiPolygon$3e$__["MultiPolygon"]
};
function orientFlatCoordinates(flatCoordinates, ends, stride) {
    if (Array.isArray(ends[0])) {
        // MultiPolagon
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$orient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["linearRingssAreOriented"])(flatCoordinates, 0, ends, stride)) {
            flatCoordinates = flatCoordinates.slice();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$orient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["orientLinearRingsArray"])(flatCoordinates, 0, ends, stride);
        }
        return flatCoordinates;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$orient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["linearRingsAreOriented"])(flatCoordinates, 0, ends, stride)) {
        flatCoordinates = flatCoordinates.slice();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$orient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["orientLinearRings"])(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
}
function createRenderFeature(object, options) {
    const geometry = object.geometry;
    if (!geometry) {
        return [];
    }
    if (Array.isArray(geometry)) {
        return geometry.map((geometry)=>createRenderFeature({
                ...object,
                geometry
            })).flat();
    }
    const geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;
    if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {
        throw new Error('Unsupported geometry type: ' + geometryType);
    }
    const stride = geometry.layout.length;
    return transformGeometryWithOptions(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, geometry.ends?.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);
}
function createGeometry(object, options) {
    if (!object) {
        return null;
    }
    if (Array.isArray(object)) {
        const geometries = object.map((geometry)=>createGeometry(geometry, options));
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$GeometryCollection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__GeometryCollection$3e$__["GeometryCollection"](geometries);
    }
    const Geometry = GeometryConstructor[object.type];
    return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout || 'XY', object.ends), false, options);
}
}}),
"[project]/node_modules/ol/format/JSONFeature.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/format/JSONFeature
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/format/Feature.js [app-ssr] (ecmascript)");
;
;
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @extends {FeatureFormat<FeatureType>}
 * @abstract
 */ class JSONFeature extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(){
        super();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */ getType() {
        return 'json';
    }
    /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @api
   * @override
   */ readFeature(source, options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */ readFeatures(source, options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   */ readFeatureFromObject(object, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   */ readFeaturesFromObject(object, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */ readGeometry(source, options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */ readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   * @override
   */ writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
    }
    /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeatureObject(feature, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   * @override
   */ writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
    }
    /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeaturesObject(features, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   * @override
   */ writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
    }
    /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeGeometryObject(geometry, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
}
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */ function getObject(source) {
    if (typeof source === 'string') {
        const object = JSON.parse(source);
        return object ? object : null;
    }
    if (source !== null) {
        return source;
    }
    return null;
}
const __TURBOPACK__default__export__ = JSONFeature;
}}),
"[project]/node_modules/ol/format/GeoJSON.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/format/GeoJSON
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/format/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$JSONFeature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/format/JSONFeature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/SimpleGeometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$deflate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/flat/deflate.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */ /**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {Object} Options
 *
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class
 * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is
 * the primary concern, and features are not going to be modified or round-tripped through the format,
 * consider using {@link module:ol/render/Feature~RenderFeature}
 */ /**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @extends {JSONFeature<FeatureType>}
 * @api
 */ class GeoJSON extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$JSONFeature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options<FeatureType>} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super();
        /**
     * @type {import("../proj/Projection.js").default}
     */ this.dataProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.dataProjection ? options.dataProjection : 'EPSG:4326');
        if (options.featureProjection) {
            /**
       * @type {import("../proj/Projection.js").default}
       */ this.defaultFeatureProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.featureProjection);
        }
        if (options.featureClass) {
            this.featureClass = options.featureClass;
        }
        /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * Look for the `geometry_name` in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */ this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
            'application/geo+json',
            'application/vnd.geo+json'
        ];
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @override
   */ readFeatureFromObject(object, options) {
        /**
     * @type {GeoJSONFeature}
     */ let geoJSONFeature = null;
        if (object['type'] === 'Feature') {
            geoJSONFeature = object;
        } else {
            geoJSONFeature = {
                'type': 'Feature',
                'geometry': object,
                'properties': null
            };
        }
        const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);
        if (this.featureClass === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createRenderFeature"])({
                geometry,
                id: geoJSONFeature['id'],
                properties: geoJSONFeature['properties']
            }, options);
        }
        const feature = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        if (this.geometryName_) {
            feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && geoJSONFeature['geometry_name']) {
            feature.setGeometryName(geoJSONFeature['geometry_name']);
        }
        feature.setGeometry((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createGeometry"])(geometry, options));
        if ('id' in geoJSONFeature) {
            feature.setId(geoJSONFeature['id']);
        }
        if (geoJSONFeature['properties']) {
            feature.setProperties(geoJSONFeature['properties'], true);
        }
        return feature;
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   * @override
   */ readFeaturesFromObject(object, options) {
        const geoJSONObject = object;
        let features = null;
        if (geoJSONObject['type'] === 'FeatureCollection') {
            const geoJSONFeatureCollection = object;
            features = [];
            const geoJSONFeatures = geoJSONFeatureCollection['features'];
            for(let i = 0, ii = geoJSONFeatures.length; i < ii; ++i){
                const featureObject = this.readFeatureFromObject(geoJSONFeatures[i], options);
                if (!featureObject) {
                    continue;
                }
                features.push(featureObject);
            }
        } else {
            features = [
                this.readFeatureFromObject(object, options)
            ];
        }
        return features.flat();
    }
    /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */ readGeometryFromObject(object, options) {
        return readGeometry(object, options);
    }
    /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */ readProjectionFromObject(object) {
        const crs = object['crs'];
        let projection;
        if (crs) {
            if (crs['type'] == 'name') {
                projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(crs['properties']['name']);
            } else if (crs['type'] === 'EPSG') {
                projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])('EPSG:' + crs['properties']['code']);
            } else {
                throw new Error('Unknown SRS type');
            }
        } else {
            projection = this.dataProjection;
        }
        return projection;
    }
    /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   * @override
   */ writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */ const object = {
            'type': 'Feature',
            geometry: null,
            properties: null
        };
        const id = feature.getId();
        if (id !== undefined) {
            object.id = id;
        }
        if (!feature.hasProperties()) {
            return object;
        }
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
            object.geometry = writeGeometry(geometry, options);
            delete properties[feature.getGeometryName()];
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(properties)) {
            object.properties = properties;
        }
        return object;
    }
    /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   * @override
   */ writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for(let i = 0, ii = features.length; i < ii; ++i){
            objects.push(this.writeFeatureObject(features[i], options));
        }
        return {
            type: 'FeatureCollection',
            features: objects
        };
    }
    /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   * @override
   */ writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
    }
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryObject} Geometry.
 */ function readGeometryInternal(object, options) {
    if (!object) {
        return null;
    }
    /** @type {import("./Feature.js").GeometryObject} */ let geometry;
    switch(object['type']){
        case 'Point':
            {
                geometry = readPointGeometry(object);
                break;
            }
        case 'LineString':
            {
                geometry = readLineStringGeometry(object);
                break;
            }
        case 'Polygon':
            {
                geometry = readPolygonGeometry(object);
                break;
            }
        case 'MultiPoint':
            {
                geometry = readMultiPointGeometry(object);
                break;
            }
        case 'MultiLineString':
            {
                geometry = readMultiLineStringGeometry(object);
                break;
            }
        case 'MultiPolygon':
            {
                geometry = readMultiPolygonGeometry(object);
                break;
            }
        case 'GeometryCollection':
            {
                geometry = readGeometryCollectionGeometry(object);
                break;
            }
        default:
            {
                throw new Error('Unsupported GeoJSON type: ' + object['type']);
            }
    }
    return geometry;
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ function readGeometry(object, options) {
    const geometryObject = readGeometryInternal(object, options);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createGeometry"])(geometryObject, options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryCollectionObject} Geometry collection.
 */ function readGeometryCollectionGeometry(object, options) {
    const geometries = object['geometries'].map(/**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */ function(geometry) {
        return readGeometryInternal(geometry, options);
    });
    return geometries;
}
/**
 * @param {GeoJSONPoint} object Input object.
 * @return {import("./Feature.js").GeometryObject} Point geometry.
 */ function readPointGeometry(object) {
    const flatCoordinates = object['coordinates'];
    return {
        type: 'Point',
        flatCoordinates,
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(flatCoordinates.length)
    };
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} LineString geometry.
 */ function readLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = coordinates.flat();
    return {
        type: 'LineString',
        flatCoordinates,
        ends: [
            flatCoordinates.length
        ],
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(coordinates[0]?.length || 2)
    };
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiLineString geometry.
 */ function readMultiLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const stride = coordinates[0]?.[0]?.length || 2;
    const flatCoordinates = [];
    const ends = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$deflate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deflateCoordinatesArray"])(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiLineString',
        flatCoordinates,
        ends,
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(stride)
    };
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPoint geometry.
 */ function readMultiPointGeometry(object) {
    const coordinates = object['coordinates'];
    return {
        type: 'MultiPoint',
        flatCoordinates: coordinates.flat(),
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(coordinates[0]?.length || 2)
    };
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPolygon geometry.
 */ function readMultiPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0]?.[0]?.[0].length || 2;
    const endss = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$deflate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deflateMultiCoordinatesArray"])(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiPolygon',
        flatCoordinates,
        ends: endss,
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(stride)
    };
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} Polygon.
 */ function readPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0]?.[0]?.length;
    const ends = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$flat$2f$deflate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deflateCoordinatesArray"])(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'Polygon',
        flatCoordinates,
        ends,
        layout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLayoutForStride"])(stride)
    };
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeGeometry(geometry, options) {
    geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$format$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformGeometryWithOptions"])(geometry, true, options);
    const type = geometry.getType();
    /** @type {GeoJSONGeometry} */ let geoJSON;
    switch(type){
        case 'Point':
            {
                geoJSON = writePointGeometry(geometry, options);
                break;
            }
        case 'LineString':
            {
                geoJSON = writeLineStringGeometry(geometry, options);
                break;
            }
        case 'Polygon':
            {
                geoJSON = writePolygonGeometry(geometry, options);
                break;
            }
        case 'MultiPoint':
            {
                geoJSON = writeMultiPointGeometry(geometry, options);
                break;
            }
        case 'MultiLineString':
            {
                geoJSON = writeMultiLineStringGeometry(geometry, options);
                break;
            }
        case 'MultiPolygon':
            {
                geoJSON = writeMultiPolygonGeometry(geometry, options);
                break;
            }
        case 'GeometryCollection':
            {
                geoJSON = writeGeometryCollectionGeometry(geometry, options);
                break;
            }
        case 'Circle':
            {
                geoJSON = {
                    type: 'GeometryCollection',
                    geometries: []
                };
                break;
            }
        default:
            {
                throw new Error('Unsupported geometry type: ' + type);
            }
    }
    return geoJSON;
}
/**
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */ function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    const geometries = geometry.getGeometriesArray().map(function(geometry) {
        return writeGeometry(geometry, options);
    });
    return {
        type: 'GeometryCollection',
        geometries: geometries
    };
}
/**
 * @param {import("../geom/LineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeLineStringGeometry(geometry, options) {
    return {
        type: 'LineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiLineStringGeometry(geometry, options) {
    return {
        type: 'MultiLineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPointGeometry(geometry, options) {
    return {
        type: 'MultiPoint',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPolygonGeometry(geometry, options) {
    let right;
    if (options) {
        right = options.rightHanded;
    }
    return {
        type: 'MultiPolygon',
        coordinates: geometry.getCoordinates(right)
    };
}
/**
 * @param {import("../geom/Point.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePointGeometry(geometry, options) {
    return {
        type: 'Point',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/Polygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePolygonGeometry(geometry, options) {
    let right;
    if (options) {
        right = options.rightHanded;
    }
    return {
        type: 'Polygon',
        coordinates: geometry.getCoordinates(right)
    };
}
const __TURBOPACK__default__export__ = GeoJSON;
}}),
"[project]/node_modules/ol/ViewHint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/ViewHint
 */ /**
 * @enum {number}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    ANIMATING: 0,
    INTERACTING: 1
};
}}),
"[project]/node_modules/ol/has.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/has
 */ __turbopack_esm__({
    "CREATE_IMAGE_BITMAP": (()=>CREATE_IMAGE_BITMAP),
    "DEVICE_PIXEL_RATIO": (()=>DEVICE_PIXEL_RATIO),
    "FIREFOX": (()=>FIREFOX),
    "IMAGE_DECODE": (()=>IMAGE_DECODE),
    "MAC": (()=>MAC),
    "PASSIVE_EVENT_LISTENERS": (()=>PASSIVE_EVENT_LISTENERS),
    "SAFARI": (()=>SAFARI),
    "SAFARI_BUG_237906": (()=>SAFARI_BUG_237906),
    "WEBKIT": (()=>WEBKIT),
    "WORKER_OFFSCREEN_CANVAS": (()=>WORKER_OFFSCREEN_CANVAS)
});
const ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
const FIREFOX = ua.includes('firefox');
const SAFARI = ua.includes('safari') && !ua.includes('chrom');
const SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');
const MAC = ua.includes('macintosh');
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line
const IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';
const PASSIVE_EVENT_LISTENERS = function() {
    let passive = false;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get: function() {
                passive = true;
            }
        });
        // @ts-ignore Ignore invalid event type '_'
        window.addEventListener('_', null, options);
        // @ts-ignore Ignore invalid event type '_'
        window.removeEventListener('_', null, options);
    } catch  {
    // passive not supported
    }
    return passive;
}();
}}),
"[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "createCanvasContext2D": (()=>createCanvasContext2D),
    "getSharedCanvasContext2D": (()=>getSharedCanvasContext2D),
    "outerHeight": (()=>outerHeight),
    "outerWidth": (()=>outerWidth),
    "releaseCanvas": (()=>releaseCanvas),
    "removeChildren": (()=>removeChildren),
    "replaceChildren": (()=>replaceChildren),
    "replaceNode": (()=>replaceNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-ssr] (ecmascript)");
;
function createCanvasContext2D(width, height, canvasPool, settings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */ let canvas;
    if (canvasPool && canvasPool.length) {
        canvas = canvasPool.shift();
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WORKER_OFFSCREEN_CANVAS"]) {
        canvas = new OffscreenCanvas(width || 300, height || 300);
    } else {
        canvas = document.createElement('canvas');
    }
    if (width) {
        canvas.width = width;
    }
    if (height) {
        canvas.height = height;
    }
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return canvas.getContext('2d', settings);
}
/** @type {CanvasRenderingContext2D} */ let sharedCanvasContext;
function getSharedCanvasContext2D() {
    if (!sharedCanvasContext) {
        sharedCanvasContext = createCanvasContext2D(1, 1);
    }
    return sharedCanvasContext;
}
function releaseCanvas(context) {
    const canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
function outerHeight(element) {
    let height = element.offsetHeight;
    const style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
function replaceNode(newNode, oldNode) {
    const parent = oldNode.parentNode;
    if (parent) {
        parent.replaceChild(newNode, oldNode);
    }
}
function removeChildren(node) {
    while(node.lastChild){
        node.lastChild.remove();
    }
}
function replaceChildren(node, children) {
    const oldChildren = node.childNodes;
    for(let i = 0; true; ++i){
        const oldChild = oldChildren[i];
        const newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) {
            break;
        }
        // check if children match
        if (oldChild === newChild) {
            continue;
        }
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}
}}),
"[project]/node_modules/ol/css.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/css
 */ /**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */ /**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */ __turbopack_esm__({
    "CLASS_COLLAPSED": (()=>CLASS_COLLAPSED),
    "CLASS_CONTROL": (()=>CLASS_CONTROL),
    "CLASS_HIDDEN": (()=>CLASS_HIDDEN),
    "CLASS_SELECTABLE": (()=>CLASS_SELECTABLE),
    "CLASS_UNSELECTABLE": (()=>CLASS_UNSELECTABLE),
    "CLASS_UNSUPPORTED": (()=>CLASS_UNSUPPORTED),
    "getFontParameters": (()=>getFontParameters)
});
const CLASS_HIDDEN = 'ol-hidden';
const CLASS_SELECTABLE = 'ol-selectable';
const CLASS_UNSELECTABLE = 'ol-unselectable';
const CLASS_UNSUPPORTED = 'ol-unsupported';
const CLASS_CONTROL = 'ol-control';
const CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */ const fontRegEx = new RegExp([
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'
].join(''), 'i');
/** @type {Array<'style'|'variant'|'weight'|'size'|'lineHeight'|'family'>} */ const fontRegExMatchIndex = [
    'style',
    'variant',
    'weight',
    'size',
    'lineHeight',
    'family'
];
const getFontParameters = function(fontSpec) {
    const match = fontSpec.match(fontRegEx);
    if (!match) {
        return null;
    }
    const style = {
        lineHeight: 'normal',
        size: '1.2em',
        style: 'normal',
        weight: 'normal',
        variant: 'normal'
    };
    for(let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i){
        const value = match[i + 1];
        if (value !== undefined) {
            style[fontRegExMatchIndex[i]] = value;
        }
    }
    style.families = style.family.split(/,\s?/);
    return style;
};
}}),
"[project]/node_modules/ol/color.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/color
 */ __turbopack_esm__({
    "NO_COLOR": (()=>NO_COLOR),
    "asArray": (()=>asArray),
    "asString": (()=>asString),
    "fromString": (()=>fromString),
    "isStringColor": (()=>isStringColor),
    "lchaToRgba": (()=>lchaToRgba),
    "normalize": (()=>normalize),
    "rgbaToLcha": (()=>rgbaToLcha),
    "toString": (()=>toString),
    "withAlpha": (()=>withAlpha)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$rgba$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/color-rgba/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$lchuv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/color-space/lchuv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$rgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/color-space/rgb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$xyz$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/color-space/xyz.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
;
;
;
;
;
const NO_COLOR = [
    NaN,
    NaN,
    NaN,
    0
];
function asString(color) {
    if (typeof color === 'string') {
        return color;
    }
    return toString(color);
}
/**
 * @type {number}
 */ const MAX_CACHE_SIZE = 1024;
/**
 * We maintain a small cache of parsed strings.  Whenever the cache grows too large,
 * we delete an arbitrary set of the entries.
 *
 * @type {Object<string, Color>}
 */ const cache = {};
/**
 * @type {number}
 */ let cacheSize = 0;
function withAlpha(color) {
    if (color.length === 4) {
        return color;
    }
    const output = color.slice();
    output[3] = 1;
    return output;
}
function rgbaToLcha(color) {
    const output = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$xyz$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].lchuv(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$rgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].xyz(color));
    output[3] = color[3];
    return output;
}
function lchaToRgba(color) {
    const output = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$xyz$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].rgb(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$space$2f$lchuv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].xyz(color));
    output[3] = color[3];
    return output;
}
function fromString(s) {
    if (s === 'none') {
        return NO_COLOR;
    }
    if (cache.hasOwnProperty(s)) {
        return cache[s];
    }
    if (cacheSize >= MAX_CACHE_SIZE) {
        let i = 0;
        for(const key in cache){
            if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
            }
        }
    }
    const color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2d$rgba$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(s);
    if (color.length !== 4) {
        throw new Error('failed to parse "' + s + '" as color');
    }
    for (const c of color){
        if (isNaN(c)) {
            throw new Error('failed to parse "' + s + '" as color');
        }
    }
    normalize(color);
    cache[s] = color;
    ++cacheSize;
    return color;
}
function asArray(color) {
    if (Array.isArray(color)) {
        return color;
    }
    return fromString(color);
}
function normalize(color) {
    color[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(color[0] + 0.5 | 0, 0, 255);
    color[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(color[1] + 0.5 | 0, 0, 255);
    color[2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(color[2] + 0.5 | 0, 0, 255);
    color[3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(color[3], 0, 1);
    return color;
}
function toString(color) {
    let r = color[0];
    if (r != (r | 0)) {
        r = r + 0.5 | 0;
    }
    let g = color[1];
    if (g != (g | 0)) {
        g = g + 0.5 | 0;
    }
    let b = color[2];
    if (b != (b | 0)) {
        b = b + 0.5 | 0;
    }
    const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
function isStringColor(s) {
    try {
        fromString(s);
        return true;
    } catch  {
        return false;
    }
}
}}),
"[project]/node_modules/ol/ImageState.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/ImageState
 */ /**
 * @enum {number}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};
}}),
"[project]/node_modules/ol/Image.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Image
 */ __turbopack_esm__({
    "decode": (()=>decode),
    "decodeFallback": (()=>decodeFallback),
    "default": (()=>__TURBOPACK__default__export__),
    "listenImage": (()=>listenImage),
    "load": (()=>load)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ImageState.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Target.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */ /**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */ class ImageWrapper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|Loader} stateOrLoader State.
   */ constructor(extent, resolution, pixelRatio, stateOrLoader){
        super();
        /**
     * @protected
     * @type {import("./extent.js").Extent}
     */ this.extent = extent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @protected
     * @type {number|Array<number>|undefined}
     */ this.resolution = resolution;
        /**
     * @protected
     * @type {import("./ImageState.js").default}
     */ this.state = typeof stateOrLoader === 'function' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IDLE : stateOrLoader;
        /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */ this.image_ = null;
        /**
     * @protected
     * @type {Loader|null}
     */ this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE);
    }
    /**
   * @return {import("./extent.js").Extent} Extent.
   */ getExtent() {
        return this.extent;
    }
    /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */ getImage() {
        return this.image_;
    }
    /**
   * @return {number} PixelRatio.
   */ getPixelRatio() {
        return this.pixelRatio_;
    }
    /**
   * @return {number|Array<number>} Resolution.
   */ getResolution() {
        return this.resolution;
    }
    /**
   * @return {import("./ImageState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IDLE) {
            if (this.loader) {
                this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADING;
                this.changed();
                const resolution = this.getResolution();
                const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromise"])(()=>this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then((image)=>{
                    if ('image' in image) {
                        this.image_ = image.image;
                    }
                    if ('extent' in image) {
                        this.extent = image.extent;
                    }
                    if ('resolution' in image) {
                        this.resolution = image.resolution;
                    }
                    if ('pixelRatio' in image) {
                        this.pixelRatio_ = image.pixelRatio;
                    }
                    if (image instanceof HTMLImageElement || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CREATE_IMAGE_BITMAP"] && image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {
                        this.image_ = image;
                    }
                    this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED;
                }).catch((error)=>{
                    this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR;
                    console.error(error); // eslint-disable-line no-console
                }).finally(()=>this.changed());
            }
        }
    }
    /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * @param {number|Array<number>} resolution Resolution.
   */ setResolution(resolution) {
        this.resolution = resolution;
    }
}
function listenImage(image, loadHandler, errorHandler) {
    const img = image;
    let listening = true;
    let decoding = false;
    let loaded = false;
    const listenerKeys = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listenOnce"])(img, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOAD, function() {
            loaded = true;
            if (!decoding) {
                loadHandler();
            }
        })
    ];
    if (img.src && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IMAGE_DECODE"]) {
        decoding = true;
        img.decode().then(function() {
            if (listening) {
                loadHandler();
            }
        }).catch(function(error) {
            if (listening) {
                if (loaded) {
                    loadHandler();
                } else {
                    errorHandler();
                }
            }
        });
    } else {
        listenerKeys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listenOnce"])(img, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR, errorHandler));
    }
    return function unlisten() {
        listening = false;
        listenerKeys.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
    };
}
function load(image, src) {
    return new Promise((resolve, reject)=>{
        function handleLoad() {
            unlisten();
            resolve(image);
        }
        function handleError() {
            unlisten();
            reject(new Error('Image load error'));
        }
        function unlisten() {
            image.removeEventListener('load', handleLoad);
            image.removeEventListener('error', handleError);
        }
        image.addEventListener('load', handleLoad);
        image.addEventListener('error', handleError);
        if (src) {
            image.src = src;
        }
    });
}
function decodeFallback(image, src) {
    if (src) {
        image.src = src;
    }
    return image.src && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IMAGE_DECODE"] ? new Promise((resolve, reject)=>image.decode().then(()=>resolve(image)).catch((e)=>image.complete && image.width ? resolve(image) : reject(e))) : load(image);
}
function decode(image, src) {
    if (src) {
        image.src = src;
    }
    return image.src && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IMAGE_DECODE"] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CREATE_IMAGE_BITMAP"] ? image.decode().then(()=>createImageBitmap(image)).catch((e)=>{
        if (image.complete && image.width) {
            return image;
        }
        throw e;
    }) : decodeFallback(image);
}
const __TURBOPACK__default__export__ = ImageWrapper;
}}),
"[project]/node_modules/ol/colorlike.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/colorlike
 */ __turbopack_esm__({
    "asColorLike": (()=>asColorLike)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/color.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/IconImageCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ImageState.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/IconImage.js [app-ssr] (ecmascript)");
;
;
;
;
;
function asColorLike(color) {
    if (!color) {
        return null;
    }
    if (Array.isArray(color)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toString"])(color);
    }
    if (typeof color === 'object' && 'src' in color) {
        return asCanvasPattern(color);
    }
    return color;
}
/**
 * @param {PatternDescriptor} pattern Pattern descriptor.
 * @return {CanvasPattern|null} Canvas pattern or null if the pattern referenced in the
 * PatternDescriptor was not found in the icon image cache.
 */ function asCanvasPattern(pattern) {
    if (!pattern.offset || !pattern.size) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].getPattern(pattern.src, 'anonymous', pattern.color);
    }
    const cacheKey = pattern.src + ':' + pattern.offset;
    const canvasPattern = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].getPattern(cacheKey, undefined, pattern.color);
    if (canvasPattern) {
        return canvasPattern;
    }
    const iconImage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].get(pattern.src, 'anonymous', null);
    if (iconImage.getImageState() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED) {
        return null;
    }
    const patternCanvasContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCanvasContext2D"])(pattern.size[0], pattern.size[1]);
    patternCanvasContext.drawImage(iconImage.getImage(1), pattern.offset[0], pattern.offset[1], pattern.size[0], pattern.size[1], 0, 0, pattern.size[0], pattern.size[1]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(patternCanvasContext.canvas, cacheKey, undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED, pattern.color, true);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].getPattern(cacheKey, undefined, pattern.color);
}
}}),
"[project]/node_modules/ol/renderer/Layer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/Layer
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ImageState.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Observable.js [app-ssr] (ecmascript)");
;
;
;
;
const maxStaleKeys = 5;
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */ class LayerRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super();
        /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */ this.ready = true;
        /** @private */ this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        /**
     * @private
     * @type {LayerType}
     */ this.layer_ = layer;
        /**
     * @type {Array<string>}
     * @private
     */ this.staleKeys_ = new Array();
        /**
     * @type {number}
     * @protected
     */ this.maxStaleKeys = maxStaleKeys;
    }
    /**
   * @return {Array<string>} Get the list of stale keys.
   */ getStaleKeys() {
        return this.staleKeys_;
    }
    /**
   * @param {string} key The new stale key.
   */ prependStaleKey(key) {
        this.staleKeys_.unshift(key);
        if (this.staleKeys_.length > this.maxStaleKeys) {
            this.staleKeys_.length = this.maxStaleKeys;
        }
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        return null;
    }
    /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */ renderFrame(frameState, target) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    }
    /**
   * @return {LayerType} Layer.
   */ getLayer() {
        return this.layer_;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */ handleFontsChanged() {}
    /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */ handleImageChange_(event) {
        const image = event.target;
        if (image.getState() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED || image.getState() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR) {
            this.renderIfReadyAndVisible();
        }
    }
    /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */ loadImage(image) {
        let imageState = image.getState();
        if (imageState != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED && imageState != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR) {
            image.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED;
    }
    /**
   * @protected
   */ renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
            layer.changed();
        }
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ renderDeferred(frameState) {}
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
    }
}
const __TURBOPACK__default__export__ = LayerRenderer;
}}),
"[project]/node_modules/ol/renderer/canvas/Layer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/canvas/Layer
 */ __turbopack_esm__({
    "canvasPool": (()=>canvasPool),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/color.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ZIndexContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas/ZIndexContext.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/Layer.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
const canvasPool = [];
/**
 * @type {CanvasRenderingContext2D}
 */ let pixelContext = null;
function createPixelContext() {
    pixelContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCanvasContext2D"])(1, 1, undefined, {
        willReadFrequently: true
    });
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ class CanvasLayerRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super(layer);
        /**
     * @protected
     * @type {HTMLElement}
     */ this.container = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedResolution;
        /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.tempTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
        /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.pixelTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
        /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.inversePixelTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
        /**
     * @type {CanvasRenderingContext2D}
     */ this.context = null;
        /**
     * @private
     * @type {ZIndexContext}
     */ this.deferredContext_ = null;
        /**
     * @type {boolean}
     */ this.containerReused = false;
        /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */ this.frameState = null;
    }
    /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */ getImageData(image, col, row) {
        if (!pixelContext) {
            createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
            pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch  {
            pixelContext = null;
            return null;
        }
        return data;
    }
    /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */ getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === 'function') {
            background = background(frameState.viewState.resolution);
        }
        return background || undefined;
    }
    /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */ useContainer(target, transform, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asArray"])(target.style.backgroundColor), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asArray"])(backgroundColor)))) {
            const canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) {
                context = canvas.getContext('2d');
            }
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        } else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        } else if (this.container) {
            this.container.style.backgroundColor = null;
        }
        if (!this.container) {
            container = document.createElement('div');
            container.className = layerClassName;
            let style = container.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCanvasContext2D"])();
            const canvas = context.canvas;
            container.appendChild(canvas);
            style = canvas.style;
            style.position = 'absolute';
            style.left = '0';
            style.transformOrigin = 'top left';
            this.container = container;
            this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
            this.container.style.backgroundColor = backgroundColor;
        }
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */ clipUnrotated(context, frameState, extent) {
        const topLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTopLeft"])(extent);
        const topRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTopRight"])(extent);
        const bottomRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBottomRight"])(extent);
        const bottomLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBottomLeft"])(extent);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.coordinateToPixelTransform, topLeft);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.coordinateToPixelTransform, topRight);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.coordinateToPixelTransform, bottomRight);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(inverted, topLeft);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(inverted, topRight);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(inverted, bottomRight);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */ prepareContainer(frameState, target) {
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const width = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(extent) / resolution * pixelRatio);
        const height = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHeight"])(extent) / resolution * pixelRatio);
        // set forward and inverse pixel transforms
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compose"])(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeInverse"])(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toString"])(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        if (!this.containerReused) {
            const canvas = this.context.canvas;
            if (canvas.width != width || canvas.height != height) {
                canvas.width = width;
                canvas.height = height;
            } else {
                this.context.clearRect(0, 0, width, height);
            }
            if (canvasTransform !== canvas.style.transform) {
                canvas.style.transform = canvasTransform;
            }
        }
    }
    /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */ dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
            const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ preRender(context, frameState) {
        this.frameState = frameState;
        if (frameState.declutter) {
            return;
        }
        this.dispatchRenderEvent_(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PRERENDER, context, frameState);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ postRender(context, frameState) {
        if (frameState.declutter) {
            return;
        }
        this.dispatchRenderEvent_(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTRENDER, context, frameState);
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeferredInternal(frameState) {}
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */ getRenderContext(frameState) {
        if (frameState.declutter && !this.deferredContext_) {
            this.deferredContext_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ZIndexContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        }
        return frameState.declutter ? this.deferredContext_.getContext() : this.context;
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */ renderDeferred(frameState) {
        if (!frameState.declutter) {
            return;
        }
        this.dispatchRenderEvent_(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PRERENDER, this.context, frameState);
        if (frameState.declutter && this.deferredContext_) {
            this.deferredContext_.draw(this.context);
            this.deferredContext_.clear();
        }
        this.renderDeferredInternal(frameState);
        this.dispatchRenderEvent_(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTRENDER, this.context, frameState);
    }
    /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */ getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compose"])(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
    }
}
const __TURBOPACK__default__export__ = CanvasLayerRenderer;
}}),
"[project]/node_modules/ol/renderer/vector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/vector
 */ __turbopack_esm__({
    "defaultOrder": (()=>defaultOrder),
    "getSquaredTolerance": (()=>getSquaredTolerance),
    "getTolerance": (()=>getTolerance),
    "renderFeature": (()=>renderFeature)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ImageState.js [app-ssr] (ecmascript)");
;
;
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */ const SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */ const GEOMETRY_RENDERERS = {
    'Point': renderPointGeometry,
    'LineString': renderLineStringGeometry,
    'Polygon': renderPolygonGeometry,
    'MultiPoint': renderMultiPointGeometry,
    'MultiLineString': renderMultiLineStringGeometry,
    'MultiPolygon': renderMultiPolygonGeometry,
    'GeometryCollection': renderGeometryCollectionGeometry,
    'Circle': renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
    return parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature1), 10) - parseInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
    const tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderCircleGeometry(builderGroup, geometry, style, feature, index) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature, index);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutter, index) {
    const loadingPromises = [];
    const imageStyle = style.getImage();
    if (imageStyle) {
        let loading = true;
        const imageState = imageStyle.getImageState();
        if (imageState == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED || imageState == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR) {
            loading = false;
        } else {
            if (imageState == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IDLE) {
                imageStyle.load();
            }
        }
        if (loading) {
            loadingPromises.push(imageStyle.ready());
        }
    }
    const fillStyle = style.getFill();
    if (fillStyle && fillStyle.loading()) {
        loadingPromises.push(fillStyle.ready());
    }
    const loading = loadingPromises.length > 0;
    if (loading) {
        Promise.all(loadingPromises).then(()=>listener(null));
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutter, index);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {boolean} [declutter] Enable decluttering.
 * @param {number} [index] Render order index..
 */ function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutter, index) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
        return;
    }
    const simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
    const renderer = style.getRenderer();
    if (renderer) {
        renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);
    } else {
        const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, index, declutter);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderGeometry(replayGroup, geometry, style, feature, index) {
    if (geometry.getType() == 'GeometryCollection') {
        const geometries = /** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries();
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            renderGeometry(replayGroup, geometries[i], style, feature, index);
        }
        return;
    }
    const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
    replay.drawCustom(geometry, feature, style.getRenderer(), style.getHitDetectionRenderer(), index);
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @param {number} [index] Render order index.
 */ function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup, index) {
    const geometries = geometry.getGeometriesArray();
    let i, ii;
    for(i = 0, ii = geometries.length; i < ii; ++i){
        const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderLineStringGeometry(builderGroup, geometry, style, feature, index) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature, index);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, index) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature, index);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, index) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature, index);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 * @param {boolean} [declutter] Enable decluttering.
 */ function renderPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    const hasText = textStyle && textStyle.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ const declutterImageWithText = declutter && imageStyle && hasText ? {} : undefined;
    if (imageStyle) {
        if (imageStyle.getImageState() != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED) {
            return;
        }
        const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawPoint(geometry, feature, index);
    }
    if (hasText) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 * @param {boolean} [declutter] Enable decluttering.
 */ function renderMultiPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
    const imageStyle = style.getImage();
    const hasImage = imageStyle && imageStyle.getOpacity() !== 0;
    const textStyle = style.getText();
    const hasText = textStyle && textStyle.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ const declutterImageWithText = declutter && hasImage && hasText ? {} : undefined;
    if (hasImage) {
        if (imageStyle.getImageState() != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ImageState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED) {
            return;
        }
        const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawMultiPoint(geometry, feature, index);
    }
    if (hasText) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature, index);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} [index] Render order index.
 */ function renderPolygonGeometry(builderGroup, geometry, style, feature, index) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature, index);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature, index);
    }
}
}}),
"[project]/node_modules/ol/renderer/canvas/VectorLayer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/canvas/VectorLayer
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ViewHint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ExecutorGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas/ExecutorGroup.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/canvas/Layer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas/hitdetect.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$BuilderGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas/BuilderGroup.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */ class CanvasVectorLayerRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */ constructor(vectorLayer){
        super(vectorLayer);
        /** @private */ this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        /**
     * @private
     * @type {boolean}
     */ this.animatingOrInteracting_;
        /**
     * @private
     * @type {ImageData|null}
     */ this.hitDetectionImageData_ = null;
        /**
     * @private
     * @type {boolean}
     */ this.clipped_ = false;
        /**
     * @private
     * @type {Array<import("../../Feature.js").default>}
     */ this.renderedFeatures_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.renderedResolution_ = NaN;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.renderedExtent_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEmpty"])();
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.wrappedRenderedExtent_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEmpty"])();
        /**
     * @private
     * @type {number}
     */ this.renderedRotation_;
        /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */ this.renderedCenter_ = null;
        /**
     * @private
     * @type {import("../../proj/Projection").default}
     */ this.renderedProjection_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedPixelRatio_ = 1;
        /**
     * @private
     * @type {import("../../render.js").OrderFunction|null}
     */ this.renderedRenderOrder_ = null;
        /**
     * @private
     * @type {boolean}
     */ this.renderedFrameDeclutter_;
        /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.replayGroup_ = null;
        /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */ this.replayGroupChanged = true;
        /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */ this.clipping = true;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.targetContext_ = null;
        /**
     * @private
     * @type {number}
     */ this.opacity_ = 1;
    }
    /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */ renderWorlds(executorGroup, frameState, declutterable) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const declutter = this.getLayer().getDeclutter();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING] || viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING]);
        const context = this.context;
        const width = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(extent) / resolution * pixelRatio);
        const height = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHeight"])(extent) / resolution * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
            let transform = this.getRenderTransform(center, resolution, 0, pixelRatio, width, height, world * worldWidth);
            if (frameState.declutter) {
                transform = transform.slice(0);
            }
            executorGroup.execute(context, [
                context.canvas.width,
                context.canvas.height
            ], transform, rotation, snapToPixel, declutterable === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ExecutorGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALL"] : declutterable ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ExecutorGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DECLUTTER"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ExecutorGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NON_DECLUTTER"], declutterable ? declutter && frameState.declutter[declutter] : undefined);
        }while (++world < endWorld)
    }
    /**
   * @private
   */ setDrawContext_() {
        if (this.opacity_ !== 1) {
            this.targetContext_ = this.context;
            this.context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createCanvasContext2D"])(this.context.canvas.width, this.context.canvas.height, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["canvasPool"]);
        }
    }
    /**
   * @private
   */ resetDrawContext_() {
        if (this.opacity_ !== 1) {
            const alpha = this.targetContext_.globalAlpha;
            this.targetContext_.globalAlpha = this.opacity_;
            this.targetContext_.drawImage(this.context.canvas, 0, 0);
            this.targetContext_.globalAlpha = alpha;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["releaseCanvas"])(this.context);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["canvasPool"].push(this.context.canvas);
            this.context = this.targetContext_;
            this.targetContext_ = null;
        }
    }
    /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {
            return;
        }
        this.renderWorlds(this.replayGroup_, frameState, true);
    }
    /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */ renderDeferredInternal(frameState) {
        if (!this.replayGroup_) {
            return;
        }
        this.replayGroup_.renderDeferred();
        if (this.clipped_) {
            this.context.restore();
        }
        this.resetDrawContext_();
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   * @override
   */ renderFrame(frameState, target) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        this.opacity_ = layerState.opacity;
        const viewState = frameState.viewState;
        this.prepareContainer(frameState, target);
        const context = this.context;
        const replayGroup = this.replayGroup_;
        let render = replayGroup && !replayGroup.isEmpty();
        if (!render) {
            const hasRenderListeners = this.getLayer().hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PRERENDER) || this.getLayer().hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTRENDER);
            if (!hasRenderListeners) {
                return null;
            }
        }
        this.setDrawContext_();
        this.preRender(context, frameState);
        const projection = viewState.projection;
        // clipped rendering if layer extent is set
        this.clipped_ = false;
        if (render && layerState.extent && this.clipping) {
            const layerExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(layerState.extent, projection);
            render = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(layerExtent, frameState.extent);
            this.clipped_ = render && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsExtent"])(layerExtent, frameState.extent);
            if (this.clipped_) {
                this.clipUnrotated(context, frameState, layerExtent);
            }
        }
        if (render) {
            this.renderWorlds(replayGroup, frameState, this.getLayer().getDeclutter() ? false : undefined);
        }
        if (!frameState.declutter && this.clipped_) {
            context.restore();
        }
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        if (!frameState.declutter) {
            this.resetDrawContext_();
        }
        return this.container;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   * @override
   */ getFeatures(pixel) {
        return new Promise((resolve)=>{
            if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                const size = this.frameState.size.slice();
                const center = this.renderedCenter_;
                const resolution = this.renderedResolution_;
                const rotation = this.renderedRotation_;
                const projection = this.renderedProjection_;
                const extent = this.wrappedRenderedExtent_;
                const layer = this.getLayer();
                const transforms = [];
                const width = size[0] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIT_DETECT_RESOLUTION"];
                const height = size[1] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIT_DETECT_RESOLUTION"];
                transforms.push(this.getRenderTransform(center, resolution, rotation, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIT_DETECT_RESOLUTION"], width, height, 0).slice());
                const source = layer.getSource();
                const projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsExtent"])(projectionExtent, extent)) {
                    let startX = extent[0];
                    const worldWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projectionExtent);
                    let world = 0;
                    let offsetX;
                    while(startX < projectionExtent[0]){
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIT_DETECT_RESOLUTION"], width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while(startX > projectionExtent[2]){
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIT_DETECT_RESOLUTION"], width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
                this.hitDetectionImageData_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHitDetectionImageData"])(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSquaredTolerance"])(resolution, this.renderedPixelRatio_), userProjection ? projection : null);
            }
            resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$hitdetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hitDetect"])(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        });
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) {
            return undefined;
        }
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ const features = {};
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */ const featureCallback = function(feature, geometry, distanceSq) {
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
            const match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        const declutter = this.getLayer().getDeclutter();
        return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutter ? frameState.declutter?.[declutter]?.all().map((item)=>item.value) : null);
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */ handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
            layer.changed();
        }
    }
    /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */ handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */ prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
            return false;
        }
        const animating = frameState.viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING];
        const interacting = frameState.viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) {
            vectorLayerRenderOrder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultOrder"];
        }
        const center = viewState.center.slice();
        const extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buffer"])(frameStateExtent, vectorLayerRenderBuffer * resolution);
        const renderedExtent = extent.slice();
        const loadExtents = [
            extent.slice()
        ];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsExtent"])(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180 to +180). To support geometries in a coordinate range from -540
            // to +540, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            const worldWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projectionExtent);
            const gutter = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrapX"])(center, projection);
            const loadExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrapX"])(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
                loadExtents.push([
                    loadExtent[0] + worldWidth,
                    loadExtent[1],
                    loadExtent[2] + worldWidth,
                    loadExtent[3]
                ]);
            } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
                loadExtents.push([
                    loadExtent[0] - worldWidth,
                    loadExtent[1],
                    loadExtent[2] - worldWidth,
                    loadExtent[3]
                ]);
            }
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && this.renderedFrameDeclutter_ === !!frameState.declutter && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsExtent"])(this.wrappedRenderedExtent_, extent)) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$BuilderGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTolerance"])(resolution, pixelRatio), extent, resolution, pixelRatio);
        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
        let userTransform;
        if (userProjection) {
            for(let i = 0, ii = loadExtents.length; i < ii; ++i){
                const extent = loadExtents[i];
                const userExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserExtent"])(extent, projection);
                vectorSource.loadFeatures(userExtent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserResolution"])(resolution, projection), userProjection);
            }
            userTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getTransformFromProjections"])(userProjection, projection);
        } else {
            for(let i = 0, ii = loadExtents.length; i < ii; ++i){
                vectorSource.loadFeatures(loadExtents[i], resolution, projection);
            }
        }
        const squaredTolerance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSquaredTolerance"])(resolution, pixelRatio);
        let ready = true;
        const render = /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */ (feature, index)=>{
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
                styles = styleFunction(feature, resolution);
            }
            if (styles) {
                const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, this.getLayer().getDeclutter(), index);
                ready = ready && !dirty;
            }
        };
        const userExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserExtent"])(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */ const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
            features.sort(vectorLayerRenderOrder);
        }
        for(let i = 0, ii = features.length; i < ii; ++i){
            render(features[i], i);
        }
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$ExecutorGroup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer(), !!frameState.declutter);
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedFrameDeclutter_ = !!frameState.declutter;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.renderedPixelRatio_ = pixelRatio;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    }
    /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */ renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutter, index) {
        if (!styles) {
            return false;
        }
        let loading = false;
        if (Array.isArray(styles)) {
            for(let i = 0, ii = styles.length; i < ii; ++i){
                loading = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["renderFeature"])(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutter, index) || loading;
            }
        } else {
            loading = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["renderFeature"])(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutter, index);
        }
        return loading;
    }
}
const __TURBOPACK__default__export__ = CanvasVectorLayerRenderer;
}}),
"[project]/node_modules/ol/renderer/Map.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/Map
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Layer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/IconImageCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Disposable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Disposable.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */ /**
 * @abstract
 */ class MapRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Disposable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super();
        /**
     * @private
     * @type {import("../Map.js").default}
     */ this.map_ = map;
    }
    /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ dispatchRenderEvent(type, frameState) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */ calculateMatrices2D(frameState) {
        const viewState = frameState.viewState;
        const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compose"])(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeInverse"])(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        let result;
        const viewState = frameState.viewState;
        /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
            return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }
        const projection = viewState.projection;
        const translatedCoordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrapX"])(coordinate.slice(), projection);
        const offsets = [
            [
                0,
                0
            ]
        ];
        if (projection.canWrapX() && checkWrapped) {
            const projectionExtent = projection.getExtent();
            const worldWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projectionExtent);
            offsets.push([
                -worldWidth,
                0
            ], [
                worldWidth,
                0
            ]);
        }
        const layerStates = frameState.layerStatesArray;
        const numLayers = layerStates.length;
        const matches = [];
        const tmpCoord = [];
        for(let i = 0; i < offsets.length; i++){
            for(let j = numLayers - 1; j >= 0; --j){
                const layerState = layerStates[j];
                const layer = layerState.layer;
                if (layer.hasRenderer() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inView"])(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                    const layerRenderer = layer.getRenderer();
                    const source = layer.getSource();
                    if (layerRenderer && source) {
                        const coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                        const callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                        tmpCoord[0] = coordinates[0] + offsets[i][0];
                        tmpCoord[1] = coordinates[1] + offsets[i][1];
                        result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback, matches);
                    }
                    if (result) {
                        return result;
                    }
                }
            }
        }
        if (matches.length === 0) {
            return undefined;
        }
        const order = 1 / matches.length;
        matches.forEach((m, i)=>m.distanceSq += i * order);
        matches.sort((a, b)=>a.distanceSq - b.distanceSq);
        matches.some((m)=>{
            return result = m.callback(m.feature, m.layer, m.geometry);
        });
        return result;
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */ hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRUE"], this, layerFilter, thisArg);
        return hasFeature !== undefined;
    }
    /**
   * @return {import("../Map.js").default} Map.
   */ getMap() {
        return this.map_;
    }
    /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ renderFrame(frameState) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */ scheduleExpireIconCache(frameState) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].canExpireCache()) {
            frameState.postRenderFunctions.push(expireIconCache);
        }
    }
}
/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */ function expireIconCache(map, frameState) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$IconImageCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shared"].expire();
}
const __TURBOPACK__default__export__ = MapRenderer;
}}),
"[project]/node_modules/ol/renderer/Composite.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/renderer/Composite
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/css.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$BaseVector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/BaseVector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Layer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/Map.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */ class CompositeMapRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super(map);
        /**
     * @private
     * @type {import("../events.js").EventsKey}
     */ this.fontChangeListenerKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkedFonts"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE, map.redrawText, map);
        /**
     * @private
     * @type {HTMLDivElement}
     */ this.element_ = document.createElement('div');
        const style = this.element_.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        style.zIndex = '0';
        this.element_.className = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_UNSELECTABLE"] + ' ol-layers';
        const container = map.getViewport();
        container.insertBefore(this.element_, container.firstChild || null);
        /**
     * @private
     * @type {Array<HTMLElement>}
     */ this.children_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
    }
    /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */ dispatchRenderEvent(type, frameState) {
        const map = this.getMap();
        if (map.hasListener(type)) {
            const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](type, undefined, frameState);
            map.dispatchEvent(event);
        }
    }
    /**
   * @override
   */ disposeInternal() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.fontChangeListenerKey_);
        this.element_.remove();
        super.disposeInternal();
    }
    /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */ renderFrame(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element_.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PRECOMPOSE, frameState);
        const layerStatesArray = frameState.layerStatesArray.sort((a, b)=>a.zIndex - b.zIndex);
        const declutter = layerStatesArray.some((layerState)=>layerState.layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$BaseVector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] && layerState.layer.getDeclutter());
        if (declutter) {
            // Some layers need decluttering, turn on deferred rendering hint
            frameState.declutter = {};
        }
        const viewState = frameState.viewState;
        this.children_.length = 0;
        const renderedLayerStates = [];
        let previousElement = null;
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const layerState = layerStatesArray[i];
            frameState.layerIndex = i;
            const layer = layerState.layer;
            const sourceState = layer.getSourceState();
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inView"])(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {
                layer.unrender();
                continue;
            }
            const element = layer.render(frameState, previousElement);
            if (!element) {
                continue;
            }
            if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
            }
            renderedLayerStates.push(layerState);
        }
        this.declutter(frameState, renderedLayerStates);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["replaceChildren"])(this.element_, this.children_);
        this.dispatchRenderEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTCOMPOSE, frameState);
        if (!this.renderedVisible_) {
            this.element_.style.display = '';
            this.renderedVisible_ = true;
        }
        this.scheduleExpireIconCache(frameState);
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */ declutter(frameState, layerStates) {
        if (!frameState.declutter) {
            return;
        }
        for(let i = layerStates.length - 1; i >= 0; --i){
            const layerState = layerStates[i];
            const layer = layerState.layer;
            if (layer.getDeclutter()) {
                layer.renderDeclutter(frameState, layerState);
            }
        }
        layerStates.forEach((layerState)=>layerState.layer.renderDeferred(frameState));
    }
}
const __TURBOPACK__default__export__ = CompositeMapRenderer;
}}),
"[project]/node_modules/ol/size.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/size
 */ /**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */ /**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */ __turbopack_esm__({
    "buffer": (()=>buffer),
    "hasArea": (()=>hasArea),
    "scale": (()=>scale),
    "toSize": (()=>toSize)
});
function buffer(size, num, dest) {
    if (dest === undefined) {
        dest = [
            0,
            0
        ];
    }
    dest[0] = size[0] + 2 * num;
    dest[1] = size[1] + 2 * num;
    return dest;
}
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
    if (dest === undefined) {
        dest = [
            0,
            0
        ];
    }
    dest[0] = size[0] * ratio + 0.5 | 0;
    dest[1] = size[1] * ratio + 0.5 | 0;
    return dest;
}
function toSize(size, dest) {
    if (Array.isArray(size)) {
        return size;
    }
    if (dest === undefined) {
        dest = [
            size,
            size
        ];
    } else {
        dest[0] = size;
        dest[1] = size;
    }
    return dest;
}
}}),
"[project]/node_modules/ol/layer/Property.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/Property
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source',
    MAP: 'map'
};
}}),
"[project]/node_modules/ol/layer/Base.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/Base
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Property.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
;
;
;
;
;
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */ /**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */ class BaseLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} options Layer options.
   */ constructor(options){
        super();
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseLayerOnSignature<void>}
     */ this.un;
        /**
     * @type {BackgroundColor|false}
     * @private
     */ this.background_ = options.background;
        /**
     * @type {Object<string, *>}
     */ const properties = Object.assign({}, options);
        if (typeof options.properties === 'object') {
            delete properties.properties;
            Object.assign(properties, options.properties);
        }
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].OPACITY] = options.opacity !== undefined ? options.opacity : 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].OPACITY] === 'number', 'Layer opacity must be a number');
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VISIBLE] = options.visible !== undefined ? options.visible : true;
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Z_INDEX] = options.zIndex;
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
     * @type {string}
     * @private
     */ this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
        delete properties.className;
        this.setProperties(properties);
        /**
     * @type {import("./Layer.js").State}
     * @private
     */ this.state_ = null;
    }
    /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */ getBackground() {
        return this.background_;
    }
    /**
   * @return {string} CSS class name.
   */ getClassName() {
        return this.className_;
    }
    /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */ getLayerState(managed) {
        /** @type {import("./Layer.js").State} */ const state = this.state_ || {
            layer: this,
            managed: managed === undefined ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */ getExtent() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].EXTENT);
    }
    /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */ getMaxResolution() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_RESOLUTION);
    }
    /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */ getMinResolution() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_RESOLUTION);
    }
    /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */ getMinZoom() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_ZOOM);
    }
    /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */ getMaxZoom() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_ZOOM);
    }
    /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */ getOpacity() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].OPACITY);
    }
    /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abstract"])();
    }
    /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */ getVisible() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VISIBLE);
    }
    /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */ getZIndex() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Z_INDEX);
    }
    /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */ setBackground(background) {
        this.background_ = background;
        this.changed();
    }
    /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */ setExtent(extent) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].EXTENT, extent);
    }
    /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */ setMaxResolution(maxResolution) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_RESOLUTION, maxResolution);
    }
    /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */ setMinResolution(minResolution) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_RESOLUTION, minResolution);
    }
    /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */ setMaxZoom(maxZoom) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAX_ZOOM, maxZoom);
    }
    /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */ setMinZoom(minZoom) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MIN_ZOOM, minZoom);
    }
    /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */ setOpacity(opacity) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof opacity === 'number', 'Layer opacity must be a number');
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].OPACITY, opacity);
    }
    /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */ setVisible(visible) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VISIBLE, visible);
    }
    /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */ setZIndex(zindex) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Z_INDEX, zindex);
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        super.disposeInternal();
    }
}
const __TURBOPACK__default__export__ = BaseLayer;
}}),
"[project]/node_modules/ol/layer/Layer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/Layer
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "inView": (()=>inView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Property.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/View.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Base.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */ /**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */ /**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */ /**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */ class Layer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options<SourceType>} options Layer options.
   */ constructor(options){
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {LayerOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapPrecomposeKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapRenderKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceChangeKey_ = null;
        /**
     * @private
     * @type {RendererType}
     */ this.renderer_ = null;
        /**
     * @private
     * @type {boolean}
     */ this.sourceReady_ = false;
        /**
     * @protected
     * @type {boolean}
     */ this.rendered = false;
        // Overwrite default render method with a custom one
        if (options.render) {
            this.render = options.render;
        }
        if (options.map) {
            this.setMap(options.map);
        }
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SOURCE, this.handleSourcePropertyChange_);
        const source = options.source ? options.source : null;
        this.setSource(source);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */ getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
    }
    /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */ getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
    }
    /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */ getSource() {
        return /** @type {SourceType} */ this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SOURCE) || null;
    }
    /**
   * @return {SourceType|null} The source being rendered.
   */ getRenderSource() {
        return this.getSource();
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */ getSourceState() {
        const source = this.getSource();
        return !source ? 'undefined' : source.getState();
    }
    /**
   * @private
   */ handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== 'ready') {
            return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent('sourceready');
    }
    /**
   * @private
   */ handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
            this.sourceChangeKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(source, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.handleSourceChange_, this);
            if (source.getState() === 'ready') {
                this.sourceReady_ = true;
                setTimeout(()=>{
                    this.dispatchEvent('sourceready');
                }, 0);
            }
            this.clearRenderer();
        }
        this.changed();
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        if (!this.renderer_) {
            return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
            return null;
        }
        return this.renderer_.getData(pixel);
    }
    /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */ isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
            view = map.getView();
        }
        if (view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
            frameState = {
                viewState: view.getState(),
                extent: view.calculateExtent()
            };
        } else {
            frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
            frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
            layerState = frameState.layerStatesArray.find((layerState)=>layerState.layer === this);
            if (!layerState) {
                return false;
            }
        } else {
            layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(layerExtent, frameState.extent));
    }
    /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */ getAttributions(view) {
        if (!this.isVisible(view)) {
            return [];
        }
        const getAttributions = this.getSource()?.getAttributions();
        if (!getAttributions) {
            return [];
        }
        const frameState = view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
            attributions = [
                attributions
            ];
        }
        return attributions;
    }
    /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */ render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
            this.rendered = true;
            return layerRenderer.renderFrame(frameState, target);
        }
        return null;
    }
    /**
   * Called when a layer is not visible during a map render.
   */ unrender() {
        this.rendered = false;
    }
    /** @return {string} Declutter */ getDeclutter() {
        return undefined;
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */ renderDeclutter(frameState, layerState) {}
    /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */ renderDeferred(frameState) {
        const layerRenderer = this.getRenderer();
        if (!layerRenderer) {
            return;
        }
        layerRenderer.renderDeferred(frameState);
    }
    /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */ setMapInternal(map) {
        if (!map) {
            this.unrender();
        }
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAP, map);
    }
    /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */ getMapInternal() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MAP);
    }
    /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.mapPrecomposeKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) {
            this.changed();
        }
        if (this.mapRenderKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(map, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PRECOMPOSE, this.handlePrecompose_, this);
            this.mapRenderKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, map.render, map);
            this.changed();
        }
    }
    /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */ handlePrecompose_(renderEvent) {
        const layerStatesArray = /** @type {import("../render/Event.js").default} */ renderEvent.frameState.layerStatesArray;
        const layerState = this.getLayerState(false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!layerStatesArray.some((arrayLayerState)=>arrayLayerState.layer === layerState.layer), 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.');
        layerStatesArray.push(layerState);
    }
    /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */ setSource(source) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Property$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SOURCE, source);
    }
    /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */ getRenderer() {
        if (!this.renderer_) {
            this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
    }
    /**
   * @return {boolean} The layer has a renderer.
   */ hasRenderer() {
        return !!this.renderer_;
    }
    /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */ createRenderer() {
        return null;
    }
    /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */ clearRenderer() {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        this.clearRenderer();
        this.setSource(null);
        super.disposeInternal();
    }
}
function inView(layerState, viewState) {
    if (!layerState.visible) {
        return false;
    }
    const resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
        return false;
    }
    const zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
const __TURBOPACK__default__export__ = Layer;
}}),
"[project]/node_modules/ol/layer/BaseVector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/BaseVector
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/Style.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Layer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/canvas/style.js [app-ssr] (ecmascript)");
;
;
;
;
/***
 * @template T
 * @typedef {T extends import("../source/Vector.js").default<infer U extends import("../Feature.js").FeatureLike> ? U : never} ExtractedFeatureType
 */ /**
 * @template {import('../Feature').FeatureLike} FeatureType
 * @template {import("../source/Vector.js").default<FeatureType>|import("../source/VectorTile.js").default<FeatureType>} VectorSourceType<FeatureType>
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable
 * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
 * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
 * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
 * layers or groups of layers separately, use different truthy values for `declutter`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import('../Feature').FeatureLike} FeatureType
 * @template {import("../source/Vector.js").default<FeatureType>|import("../source/VectorTile.js").default<FeatureType>} VectorSourceType<FeatureType>
 * @extends {Layer<VectorSourceType, RendererType>}
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @api
 */ class BaseVectorLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        /**
     * @private
     * @type {string}
     */ this.declutter_ = options.declutter ? String(options.declutter) : undefined;
        /**
     * @type {number}
     * @private
     */ this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike}
     * @private
     */ this.style_ = null;
        /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */ this.styleFunction_ = undefined;
        this.setStyle(options.style);
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    }
    /**
   * @return {string} Declutter group.
   * @override
   */ getDeclutter() {
        return this.declutter_;
    }
    /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */ getFeatures(pixel) {
        return super.getFeatures(pixel);
    }
    /**
   * @return {number|undefined} Render buffer.
   */ getRenderBuffer() {
        return this.renderBuffer_;
    }
    /**
   * @return {import("../render.js").OrderFunction|null|undefined} Render order.
   */ getRenderOrder() {
        return this.get(Property.RENDER_ORDER);
    }
    /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */ getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */ getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
    }
    /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */ renderDeclutter(frameState, layerState) {
        const declutterGroup = this.getDeclutter();
        if (declutterGroup in frameState.declutter === false) {
            frameState.declutter[declutterGroup] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](9);
        }
        this.getRenderer().renderDeclutter(frameState, layerState);
    }
    /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */ setRenderOrder(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    }
    /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */ setStyle(style) {
        this.style_ = style === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDefaultStyle"] : style;
        const styleLike = toStyleLike(style);
        this.styleFunction_ = style === null ? undefined : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFunction"])(styleLike);
        this.changed();
    }
    /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */ setDeclutter(declutter) {
        this.declutter_ = declutter ? String(declutter) : undefined;
        this.changed();
    }
}
/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */ function toStyleLike(style) {
    if (style === undefined) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDefaultStyle"];
    }
    if (!style) {
        return null;
    }
    if (typeof style === 'function') {
        return style;
    }
    if (style instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        return style;
    }
    if (!Array.isArray(style)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatStylesToStyleFunction"])([
            style
        ]);
    }
    if (style.length === 0) {
        return [];
    }
    const length = style.length;
    const first = style[0];
    if (first instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        /**
     * @type {Array<Style>}
     */ const styles = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!(candidate instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])) {
                throw new Error('Expected a list of style instances');
            }
            styles[i] = candidate;
        }
        return styles;
    }
    if ('style' in first) {
        /**
     * @type {Array<import("../style/flat.js").Rule>}
     */ const rules = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!('style' in candidate)) {
                throw new Error('Expected a list of rules with a style property');
            }
            rules[i] = candidate;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rulesToStyleFunction"])(rules);
    }
    const flatStyles = style;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$canvas$2f$style$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatStylesToStyleFunction"])(flatStyles);
}
const __TURBOPACK__default__export__ = BaseVectorLayer;
}}),
"[project]/node_modules/ol/layer/Vector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/Vector
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$VectorLayer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/canvas/VectorLayer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$BaseVector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/BaseVector.js [app-ssr] (ecmascript)");
;
;
/**
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable
 * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
 * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
 * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
 * layers or groups of layers separately, use different truthy values for `declutter`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @extends {BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */ class VectorLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$BaseVector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */ constructor(options){
        super(options);
    }
    /**
   * @override
   */ createRenderer() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$canvas$2f$VectorLayer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this);
    }
}
const __TURBOPACK__default__export__ = VectorLayer;
}}),
"[project]/node_modules/ol/layer/Group.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/layer/Group
 */ __turbopack_esm__({
    "GroupEvent": (()=>GroupEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Base.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
class GroupEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */ constructor(type, layer){
        super(type);
        /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */ this.layer = layer;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */ class LayerGroup extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Layer options.
   */ constructor(options){
        options = options || {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.layers;
        let layers = options.layers;
        super(baseOptions);
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {GroupOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */ this.layersListenerKeys_ = [];
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.listenerKeys_ = {};
        this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
        if (layers) {
            if (Array.isArray(layers)) {
                layers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](layers.slice(), {
                    unique: true
                });
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof /** @type {?} */ layers.getArray === 'function', 'Expected `layers` to be an array or a `Collection`');
            }
        } else {
            layers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](undefined, {
                unique: true
            });
        }
        this.setLayers(layers);
    }
    /**
   * @private
   */ handleLayerChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleLayersChanged_() {
        this.layersListenerKeys_.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
        this.layersListenerKeys_.length = 0;
        const layers = this.getLayers();
        this.layersListenerKeys_.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layers, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, this.handleLayersAdd_, this), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layers, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, this.handleLayersRemove_, this));
        for(const id in this.listenerKeys_){
            this.listenerKeys_[id].forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])(this.listenerKeys_);
        const layersArray = layers.getArray();
        for(let i = 0, ii = layersArray.length; i < ii; i++){
            const layer = layersArray[i];
            this.registerLayerListeners_(layer);
            this.dispatchEvent(new GroupEvent('addlayer', layer));
        }
        this.changed();
    }
    /**
   * @param {BaseLayer} layer The layer.
   */ registerLayerListeners_(layer) {
        const listenerKeys = [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.handleLayerChange_, this)
        ];
        if (layer instanceof LayerGroup) {
            listenerKeys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layer, 'addlayer', this.handleLayerGroupAdd_, this), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layer, 'removelayer', this.handleLayerGroupRemove_, this));
        }
        this.listenerKeys_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(layer)] = listenerKeys;
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent('addlayer', event.layer));
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent('removelayer', event.layer));
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersAdd_(collectionEvent) {
        const layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
        this.changed();
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersRemove_(collectionEvent) {
        const layer = collectionEvent.element;
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(layer);
        this.listenerKeys_[key].forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent('removelayer', layer));
        this.changed();
    }
    /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ getLayers() {
        return this.get(Property.LAYERS);
    }
    /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ setLayers(layers) {
        const collection = this.getLayers();
        if (collection) {
            const currentLayers = collection.getArray();
            for(let i = 0, ii = currentLayers.length; i < ii; ++i){
                this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
            }
        }
        this.set(Property.LAYERS, layers);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */ getLayersArray(array) {
        array = array !== undefined ? array : [];
        this.getLayers().forEach(function(layer) {
            layer.getLayersArray(array);
        });
        return array;
    }
    /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */ getLayerStatesArray(dest) {
        const states = dest !== undefined ? dest : [];
        const pos = states.length;
        this.getLayers().forEach(function(layer) {
            layer.getLayerStatesArray(states);
        });
        const ownLayerState = this.getLayerState();
        let defaultZIndex = ownLayerState.zIndex;
        if (!dest && ownLayerState.zIndex === undefined) {
            defaultZIndex = 0;
        }
        for(let i = pos, ii = states.length; i < ii; i++){
            const layerState = states[i];
            layerState.opacity *= ownLayerState.opacity;
            layerState.visible = layerState.visible && ownLayerState.visible;
            layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
            layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
            layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
            layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
            if (ownLayerState.extent !== undefined) {
                if (layerState.extent !== undefined) {
                    layerState.extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIntersection"])(layerState.extent, ownLayerState.extent);
                } else {
                    layerState.extent = ownLayerState.extent;
                }
            }
            if (layerState.zIndex === undefined) {
                layerState.zIndex = defaultZIndex;
            }
        }
        return states;
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */ getSourceState() {
        return 'ready';
    }
}
const __TURBOPACK__default__export__ = LayerGroup;
}}),
"[project]/node_modules/ol/layer/Vector.js [app-ssr] (ecmascript) <export default as Vector>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Vector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Vector.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/ol/ViewProperty.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/ViewProperty
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation'
};
}}),
"[project]/node_modules/ol/easing.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/easing
 */ /**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ __turbopack_esm__({
    "easeIn": (()=>easeIn),
    "easeOut": (()=>easeOut),
    "inAndOut": (()=>inAndOut),
    "linear": (()=>linear),
    "upAndDown": (()=>upAndDown)
});
function easeIn(t) {
    return Math.pow(t, 3);
}
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
    return t;
}
function upAndDown(t) {
    if (t < 0.5) {
        return inAndOut(2 * t);
    }
    return 1 - inAndOut(2 * (t - 0.5));
}
}}),
"[project]/node_modules/ol/centerconstraint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/centerconstraint
 */ __turbopack_esm__({
    "createExtent": (()=>createExtent),
    "none": (()=>none)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
;
function createExtent(extent, onlyCenter, smooth) {
    return(/**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */ function(center, resolution, size, isMoving, centerShift) {
        if (!center) {
            return undefined;
        }
        if (!resolution && !onlyCenter) {
            return center;
        }
        const viewWidth = onlyCenter ? 0 : size[0] * resolution;
        const viewHeight = onlyCenter ? 0 : size[1] * resolution;
        const shiftX = centerShift ? centerShift[0] : 0;
        const shiftY = centerShift ? centerShift[1] : 0;
        let minX = extent[0] + viewWidth / 2 + shiftX;
        let maxX = extent[2] - viewWidth / 2 + shiftX;
        let minY = extent[1] + viewHeight / 2 + shiftY;
        let maxY = extent[3] - viewHeight / 2 + shiftY;
        // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for
        if (minX > maxX) {
            minX = (maxX + minX) / 2;
            maxX = minX;
        }
        if (minY > maxY) {
            minY = (maxY + minY) / 2;
            maxY = minY;
        }
        let x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(center[0], minX, maxX);
        let y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(center[1], minY, maxY);
        // during an interaction, allow some overscroll
        if (isMoving && smooth && resolution) {
            const ratio = 30 * resolution;
            x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
            y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [
            x,
            y
        ];
    });
}
function none(center) {
    return center;
}
}}),
"[project]/node_modules/ol/tilegrid/common.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/tilegrid/common
 */ /**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */ __turbopack_esm__({
    "DEFAULT_MAX_ZOOM": (()=>DEFAULT_MAX_ZOOM),
    "DEFAULT_TILE_SIZE": (()=>DEFAULT_TILE_SIZE)
});
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;
}}),
"[project]/node_modules/ol/resolutionconstraint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/resolutionconstraint
 */ __turbopack_esm__({
    "createMinMaxResolution": (()=>createMinMaxResolution),
    "createSnapToPower": (()=>createSnapToPower),
    "createSnapToResolutions": (()=>createSnapToResolutions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
;
;
;
/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */ /**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */ function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    const xResolution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(maxExtent) / viewportSize[0];
    const yResolution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHeight"])(maxExtent) / viewportSize[1];
    if (showFullExtent) {
        return Math.min(resolution, Math.max(xResolution, yResolution));
    }
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */ function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    let result = Math.min(resolution, maxResolution);
    const ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const maxResolution = resolutions[0];
            const minResolution = resolutions[resolutions.length - 1];
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const capped = Math.min(cappedMaxRes, resolution);
            const z = Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["linearFindNearest"])(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                return resolutions[z + 1];
            }
            return resolutions[z];
        }
        return undefined;
    });
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    minResolution = minResolution !== undefined ? minResolution : 0;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const tolerance = 1e-9;
            const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            const offset = -direction * (0.5 - tolerance) + 0.5;
            const capped = Math.min(cappedMaxRes, resolution);
            const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            const newResolution = maxResolution / Math.pow(power, zoomLevel);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(newResolution, minResolution, cappedMaxRes);
        }
        return undefined;
    });
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            if (!smooth || !isMoving) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(resolution, minResolution, cappedMaxRes);
            }
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        return undefined;
    });
}
}}),
"[project]/node_modules/ol/rotationconstraint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/rotationconstraint
 */ __turbopack_esm__({
    "createSnapToN": (()=>createSnapToN),
    "createSnapToZero": (()=>createSnapToZero),
    "disable": (()=>disable),
    "none": (()=>none)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
;
function disable(rotation) {
    if (rotation !== undefined) {
        return 0;
    }
    return undefined;
}
function none(rotation) {
    if (rotation !== undefined) {
        return rotation;
    }
    return undefined;
}
function createSnapToN(n) {
    const theta = 2 * Math.PI / n;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving) {
            return rotation;
        }
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        }
        return undefined;
    });
}
function createSnapToZero(tolerance) {
    const t = tolerance === undefined ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(5) : tolerance;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving || rotation === undefined) {
            return rotation;
        }
        if (Math.abs(rotation) <= t) {
            return 0;
        }
        return rotation;
    });
}
}}),
"[project]/node_modules/ol/View.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/View
 */ __turbopack_esm__({
    "createCenterConstraint": (()=>createCenterConstraint),
    "createResolutionConstraint": (()=>createResolutionConstraint),
    "createRotationConstraint": (()=>createRotationConstraint),
    "default": (()=>__TURBOPACK__default__export__),
    "isNoopAnimation": (()=>isNoopAnimation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ViewProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ViewHint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Polygon.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$centerconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/centerconstraint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/proj/Units.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$tilegrid$2f$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/tilegrid/common.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$resolutionconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/resolutionconstraint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/rotationconstraint.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */ /**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */ /**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to
 * fit the extent into. Defaults to the size of the map the view is associated with.
 * If no map or multiple maps are connected to the view, provide the desired box size
 * (e.g. `map.getSize()`).
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */ /**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */ /**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */ /**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */ /**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */ /**
 * Default min zoom level for the map view.
 * @type {number}
 */ const DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */ /**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */ class View extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {ViewOptions} [options] View options.
   */ constructor(options){
        super();
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ViewOnSignature<void>}
     */ this.un;
        options = Object.assign({}, options);
        /**
     * @private
     * @type {Array<number>}
     */ this.hints_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {Array<Array<Animation>>}
     */ this.animations_ = [];
        /**
     * @private
     * @type {number|undefined}
     */ this.updateAnimationKey_;
        /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */ this.projection_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createProjection"])(options.projection, 'EPSG:3857');
        /**
     * @private
     * @type {import("./size.js").Size}
     */ this.viewportSize_ = [
            100,
            100
        ];
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.targetCenter_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetResolution_;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */ this.nextCenter_ = null;
        /**
     * @private
     * @type {number}
     */ this.nextResolution_;
        /**
     * @private
     * @type {number}
     */ this.nextRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.cancelAnchor_ = undefined;
        if (options.projection) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["disableCoordinateWarning"])();
        }
        if (options.center) {
            options.center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(options.center, this.projection_);
        }
        if (options.extent) {
            options.extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(options.extent, this.projection_);
        }
        this.applyOptions_(options);
    }
    /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */ applyOptions_(options) {
        const properties = Object.assign({}, options);
        for(const key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]){
            delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        /**
     * @private
     * @type {number}
     */ this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
     * @private
     * @type {number}
     */ this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
     * @private
     * @type {number}
     */ this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
     * @private
     * @type {Array<number>|undefined}
     */ this.resolutions_ = options.resolutions;
        /**
     * @type {Array<number>|undefined}
     * @private
     */ this.padding_ = options.padding;
        /**
     * @private
     * @type {number}
     */ this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        /**
     * @private
     * @type {Constraints}
     */ this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) {
            this.setResolution(options.resolution);
        } else if (options.zoom !== undefined) {
            this.setZoom(options.zoom);
        }
    }
    /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */ get padding() {
        return this.padding_;
    }
    set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
            const newPadding = padding || [
                0,
                0,
                0,
                0
            ];
            oldPadding = oldPadding || [
                0,
                0,
                0,
                0
            ];
            const resolution = this.getResolution();
            const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
            const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
            this.setCenterInternal([
                center[0] + offsetX,
                center[1] - offsetY
            ]);
        }
    }
    /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */ getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) {
            options.resolution = this.getResolution();
        } else {
            options.zoom = this.getZoom();
        }
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
    }
    /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */ animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
            this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for(let i = 0; i < args.length; ++i){
            let options = arguments[i];
            if (options.center) {
                options = Object.assign({}, options);
                options.center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = Object.assign({}, options);
                options.anchor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    }
    /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */ animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        let i = 0;
        for(; i < animationCount && !this.isDef(); ++i){
            // if view properties are not yet set, shortcut to the final state
            const state = arguments[i];
            if (state.center) {
                this.setCenterInternal(state.center);
            }
            if (state.zoom !== undefined) {
                this.setZoom(state.zoom);
            } else if (state.resolution) {
                this.setResolution(state.resolution);
            }
            if (state.rotation !== undefined) {
                this.setRotation(state.rotation);
            }
        }
        if (i === animationCount) {
            if (callback) {
                animationCallback(callback, true);
            }
            return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for(; i < animationCount; ++i){
            const options = arguments[i];
            const animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inAndOut"],
                callback: callback
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                const delta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modulo"])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) {
                animation.complete = true;
            // we still push it onto the series for callback handling
            } else {
                start += animation.duration;
            }
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING, 1);
        this.updateAnimations_();
    }
    /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */ getAnimating() {
        return this.hints_[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING] > 0;
    }
    /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */ getInteracting() {
        return this.hints_[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING] > 0;
    }
    /**
   * Cancel any ongoing animations.
   * @api
   */ cancelAnimations() {
        this.setHint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING, -this.hints_[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING]);
        let anchor;
        for(let i = 0, ii = this.animations_.length; i < ii; ++i){
            const series = this.animations_[i];
            if (series[0].callback) {
                animationCallback(series[0].callback, false);
            }
            if (!anchor) {
                for(let j = 0, jj = series.length; j < jj; ++j){
                    const animation = series[j];
                    if (!animation.complete) {
                        anchor = animation.anchor;
                        break;
                    }
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    }
    /**
   * Update all animations.
   */ updateAnimations_() {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) {
            return;
        }
        const now = Date.now();
        let more = false;
        for(let i = this.animations_.length - 1; i >= 0; --i){
            const series = this.animations_[i];
            let seriesComplete = true;
            for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (animation.complete) {
                    continue;
                }
                const elapsed = now - animation.start;
                let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                } else {
                    seriesComplete = false;
                }
                const progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    const x0 = animation.sourceCenter[0];
                    const y0 = animation.sourceCenter[1];
                    const x1 = animation.targetCenter[0];
                    const y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    const x = x0 + progress * (x1 - x0);
                    const y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [
                        x,
                        y
                    ];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        const size = this.getViewportSize_(this.getRotation());
                        const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
                    const rotation = progress === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modulo"])(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        const constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) {
                    break;
                }
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                const callback = series[0].callback;
                if (callback) {
                    animationCallback(callback, true);
                }
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) {
            this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
        }
    }
    /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */ calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [
                currentCenter[0] - anchor[0],
                currentCenter[1] - anchor[1]
            ];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotate"])(center, rotation - this.getRotation());
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(center, anchor);
        }
        return center;
    }
    /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */ calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
            const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
            center = [
                x,
                y
            ];
        }
        return center;
    }
    /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */ getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
            const w = size[0];
            const h = size[1];
            return [
                Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
                Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
            ];
        }
        return size;
    }
    /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */ setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [
            100,
            100
        ];
        if (!this.getAnimating()) {
            this.resolveConstraints(0);
        }
    }
    /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */ getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
            return center;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(center, this.getProjection());
    }
    /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */ getCenterInternal() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CENTER);
    }
    /**
   * @return {Constraints} Constraints.
   */ getConstraints() {
        return this.constraints_;
    }
    /**
   * @return {boolean} Resolution constraint is set
   */ getConstrainResolution() {
        return this.get('constrainResolution');
    }
    /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */ getHints(hints) {
        if (hints !== undefined) {
            hints[0] = this.hints_[0];
            hints[1] = this.hints_[1];
            return hints;
        }
        return this.hints_.slice();
    }
    /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */ calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserExtent"])(extent, this.getProjection());
    }
    /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */ calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = this.getCenterInternal();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(center, 'The view center is not defined');
        const resolution = this.getResolution();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(resolution !== undefined, 'The view resolution is not defined');
        const rotation = this.getRotation();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(rotation !== undefined, 'The view rotation is not defined');
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getForViewAndSize"])(center, resolution, rotation, size);
    }
    /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */ getMaxResolution() {
        return this.maxResolution_;
    }
    /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */ getMinResolution() {
        return this.minResolution_;
    }
    /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */ getMaxZoom() {
        return this.getZoomForResolution(this.minResolution_);
    }
    /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */ setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: zoom
        }));
    }
    /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */ getMinZoom() {
        return this.getZoomForResolution(this.maxResolution_);
    }
    /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */ setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: zoom
        }));
    }
    /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */ setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: enabled
        }));
    }
    /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */ getProjection() {
        return this.projection_;
    }
    /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */ getResolution() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RESOLUTION);
    }
    /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */ getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(extent, this.getProjection()), size);
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */ getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(extent) / size[0];
        const yResolution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHeight"])(extent) / size[1];
        return Math.max(xResolution, yResolution);
    }
    /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */ getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return(/**
       * @param {number} value Value.
       * @return {number} Resolution.
       */ function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    }
    /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */ getRotation() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION);
    }
    /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */ getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return(/**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */ function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    }
    /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */ getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
            size = [
                size[0] - padding[1] - padding[3],
                size[1] - padding[0] - padding[2]
            ];
        }
        return size;
    }
    /**
   * @return {State} View state.
   */ getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = this.getCenterInternal();
        const padding = this.padding_;
        if (padding) {
            const reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom()
        };
    }
    /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */ getViewStateAndExtent() {
        return {
            viewState: this.getState(),
            extent: this.calculateExtent()
        };
    }
    /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */ getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== undefined) {
            zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
    }
    /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */ getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
            const nearest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["linearFindNearest"])(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) {
                zoomFactor = 2;
            } else {
                zoomFactor = max / this.resolutions_[nearest + 1];
            }
        } else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */ getResolutionForZoom(zoom) {
        if (this.resolutions_?.length) {
            if (this.resolutions_.length === 1) {
                return this.resolutions_[0];
            }
            const baseLevel = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(Math.floor(zoom), 0, this.resolutions_.length - 2);
            const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clamp"])(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */ fit(geometryOrExtent, options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */ let geometry;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ geometryOrExtent.getSimplifiedGeometry === 'function', 'Invalid extent or geometry provided as `geometry`');
        if (Array.isArray(geometryOrExtent)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(geometryOrExtent), 'Cannot fit empty extent provided as `geometry`');
            const extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(geometryOrExtent, this.getProjection());
            geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromExtent"])(extent);
        } else if (geometryOrExtent.getType() === 'Circle') {
            const extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(geometryOrExtent.getExtent(), this.getProjection());
            geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromExtent"])(extent);
            geometry.rotate(this.getRotation(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCenter"])(extent));
        } else {
            const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
            if (userProjection) {
                geometry = geometryOrExtent.clone().transform(userProjection, this.getProjection());
            } else {
                geometry = geometryOrExtent;
            }
        }
        this.fitInternal(geometry, options);
    }
    /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */ rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = +Infinity;
        let minRotY = +Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for(let i = 0, ii = coords.length; i < ii; i += stride){
            const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [
            minRotX,
            minRotY,
            maxRotX,
            maxRotY
        ];
    }
    /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */ fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
            size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== undefined ? options.padding : [
            0,
            0,
            0,
            0
        ];
        const nearest = options.nearest !== undefined ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== undefined) {
            minResolution = options.minResolution;
        } else if (options.maxZoom !== undefined) {
            minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
            minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCenter"])(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([
            centerX,
            centerY
        ], resolution);
        const callback = options.callback ? options.callback : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"];
        if (options.duration !== undefined) {
            this.animateInternal({
                resolution: resolution,
                center: center,
                duration: options.duration,
                easing: options.easing
            }, callback);
        } else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    }
    /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */ centerOn(coordinate, size, position) {
        this.centerOnInternal((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinate, this.getProjection()), size, position);
    }
    /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */ centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */ calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
            const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            const shiftedCenter = calculateCenterOn(center, size, [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1]
            ];
        }
        return centerShift;
    }
    /**
   * @return {boolean} Is defined.
   */ isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */ adjustCenter(deltaCoordinates) {
        const center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */ adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustResolution(ratio, anchor) {
        anchor = anchor && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (anchor) {
            this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    }
    /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */ adjustRotation(delta, anchor) {
        if (anchor) {
            anchor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
    }
    /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */ adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (anchor) {
            this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
    }
    /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */ setCenter(center) {
        this.setCenterInternal(center ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(center, this.getProjection()) : center);
    }
    /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */ setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    }
    /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */ setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    }
    /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */ setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    }
    /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */ setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    }
    /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */ setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */ applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        // compute rotation
        const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION) !== newRotation) {
            this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION, newRotation);
        }
        if (this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RESOLUTION) !== newResolution) {
            this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RESOLUTION, newResolution);
            this.set('zoom', this.getZoom(), true);
        }
        if (!newCenter || !this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CENTER) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CENTER), newCenter)) {
            this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
            this.cancelAnimations();
        }
        this.cancelAnchor_ = undefined;
    }
    /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== undefined ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) {
                this.cancelAnimations();
            }
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeOut"],
                anchor: anchor
            });
        }
    }
    /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */ beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING, 1);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
            return;
        }
        this.setHint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */ getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */ getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }
    /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */ getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    }
}
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */ function animationCallback(callback, returnValue) {
    setTimeout(function() {
        callback(returnValue);
    }, 0);
}
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        const smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$centerconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExtent"])(options.extent, options.constrainOnlyCenter, smooth);
    }
    const projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createProjection"])(options.projection, 'EPSG:3857');
    if (options.multiWorld !== true && projection.isGlobal()) {
        const extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$centerconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExtent"])(extent, false, false);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$centerconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["none"];
}
function createResolutionConstraint(options) {
    let resolutionConstraint;
    let maxResolution;
    let minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    const defaultMaxZoom = 28;
    const defaultZoomFactor = 2;
    let minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    let maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    const zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    const multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    const smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    const showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    const projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createProjection"])(options.projection, 'EPSG:3857');
    const projExtent = projection.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter;
    let extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        const resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
        if (options.constrainResolution) {
            resolutionConstraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$resolutionconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSnapToResolutions"])(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        } else {
            resolutionConstraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$resolutionconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMinMaxResolution"])(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
    } else {
        // calculate the default min and max resolution
        const size = !projExtent ? 360 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2f$Units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METERS_PER_UNIT"].degrees / projection.getMetersPerUnit() : Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWidth"])(projExtent), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHeight"])(projExtent));
        const defaultMaxResolution = size / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$tilegrid$2f$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_TILE_SIZE"] / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) {
            minZoom = 0;
        } else {
            maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        }
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) {
                    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                } else {
                    minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                }
            } else {
                minResolution = defaultMinResolution;
            }
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) {
            resolutionConstraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$resolutionconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSnapToPower"])(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        } else {
            resolutionConstraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$resolutionconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMinMaxResolution"])(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor
    };
}
function createRotationConstraint(options) {
    const enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        const constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSnapToZero"])();
        }
        if (constrainRotation === false) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["none"];
        }
        if (typeof constrainRotation === 'number') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSnapToN"])(constrainRotation);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["none"];
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["disable"];
}
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(animation.sourceCenter, animation.targetCenter)) {
            return false;
        }
    }
    if (animation.sourceResolution !== animation.targetResolution) {
        return false;
    }
    if (animation.sourceRotation !== animation.targetRotation) {
        return false;
    }
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */ function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    const cosAngle = Math.cos(-rotation);
    let sinAngle = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    const centerX = rotX * cosAngle - rotY * sinAngle;
    const centerY = rotY * cosAngle + rotX * sinAngle;
    return [
        centerX,
        centerY
    ];
}
const __TURBOPACK__default__export__ = View;
}}),
"[project]/node_modules/ol/expr/expression.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/expr/expression
 */ __turbopack_esm__({
    "AnyType": (()=>AnyType),
    "BooleanType": (()=>BooleanType),
    "CallExpression": (()=>CallExpression),
    "ColorType": (()=>ColorType),
    "LiteralExpression": (()=>LiteralExpression),
    "NoneType": (()=>NoneType),
    "NumberArrayType": (()=>NumberArrayType),
    "NumberType": (()=>NumberType),
    "Ops": (()=>Ops),
    "SizeType": (()=>SizeType),
    "StringType": (()=>StringType),
    "computeGeometryType": (()=>computeGeometryType),
    "includesType": (()=>includesType),
    "isType": (()=>isType),
    "newParsingContext": (()=>newParsingContext),
    "overlapsType": (()=>overlapsType),
    "parse": (()=>parse),
    "typeName": (()=>typeName)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/color.js [app-ssr] (ecmascript)");
;
;
;
/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */ /**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expression.js").ExpressionValue} arguments.
 *
 * See below for details on the available operators (with notes for those that are WebGL or Canvas only).
 *
 * Reading operators:
 *   `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).
 *   `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.
 *   `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a
 *     feature property. The result is `undefined` when there is nothing at the specified key or index.
 *   `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).
 *   `['resolution']` returns the current resolution
 *   `['time']` The time in seconds since the creation of the layer (WebGL only).
 *   `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   `['zoom']` The current zoom level (WebGL only).
 *   `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line
 *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.
 *      Please note that the M component will be linearly interpolated between the two points composing a segment.
 *
 * Math operators:
 *   `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   `['/', value1, value2]` divides `value1` by `value2`
 *   `['+', value1, value2, ...]` adds the values
 *   `['-', value1, value2]` subtracts `value2` from `value1`
 *   `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   `['abs', value1]` returns the absolute value of `value1`
 *   `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`
 *     (Canvas only).
 *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`
 *     (Canvas only).
 *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.
 *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`
 *     (Canvas only).
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,
 *     `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4 (WebGL only).
 *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;
 *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).
 *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range) (WebGL only).
 *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is "true" or "false".
 *     If the input is a number, it is converted to a string as specified by the "NumberToString" algorithm of the ECMAScript
 *     Language Specification. If the input is a color, it is converted to a string of the form "rgba(r,g,b,a)". (Canvas only)
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module:ol/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */ let numTypes = 0;
const NoneType = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const SizeType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;
const typeNames = {
    [BooleanType]: 'boolean',
    [NumberType]: 'number',
    [StringType]: 'string',
    [ColorType]: 'color',
    [NumberArrayType]: 'number[]',
    [SizeType]: 'size'
};
const namedTypes = Object.keys(typeNames).map(Number).sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ascending"]);
/**
 * @param {number} type The type.
 * @return {boolean} The type is one of the specific types (not any or a union type).
 */ function isSpecific(type) {
    return type in typeNames;
}
function typeName(type) {
    const names = [];
    for (const namedType of namedTypes){
        if (includesType(type, namedType)) {
            names.push(typeNames[namedType]);
        }
    }
    if (names.length === 0) {
        return 'untyped';
    }
    if (names.length < 3) {
        return names.join(' or ');
    }
    return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}
function includesType(broad, specific) {
    return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
    return !!(oneType & otherType);
}
function isType(type, expected) {
    return type === expected;
}
class LiteralExpression {
    /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */ constructor(type, value){
        if (!isSpecific(type)) {
            throw new Error(`literal expressions must have a specific type, got ${typeName(type)}`);
        }
        this.type = type;
        this.value = value;
    }
}
class CallExpression {
    /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */ constructor(type, operator, ...args){
        this.type = type;
        this.operator = operator;
        this.args = args;
    }
}
function newParsingContext() {
    return {
        variables: new Set(),
        properties: new Set(),
        featureId: false,
        geometryType: false,
        mapState: false
    };
}
function parse(encoded, expectedType, context) {
    switch(typeof encoded){
        case 'boolean':
            {
                if (isType(expectedType, StringType)) {
                    return new LiteralExpression(StringType, encoded ? 'true' : 'false');
                }
                if (!includesType(expectedType, BooleanType)) {
                    throw new Error(`got a boolean, but expected ${typeName(expectedType)}`);
                }
                return new LiteralExpression(BooleanType, encoded);
            }
        case 'number':
            {
                if (isType(expectedType, SizeType)) {
                    return new LiteralExpression(SizeType, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toSize"])(encoded));
                }
                if (isType(expectedType, BooleanType)) {
                    return new LiteralExpression(BooleanType, !!encoded);
                }
                if (isType(expectedType, StringType)) {
                    return new LiteralExpression(StringType, encoded.toString());
                }
                if (!includesType(expectedType, NumberType)) {
                    throw new Error(`got a number, but expected ${typeName(expectedType)}`);
                }
                return new LiteralExpression(NumberType, encoded);
            }
        case 'string':
            {
                if (isType(expectedType, ColorType)) {
                    return new LiteralExpression(ColorType, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromString"])(encoded));
                }
                if (isType(expectedType, BooleanType)) {
                    return new LiteralExpression(BooleanType, !!encoded);
                }
                if (!includesType(expectedType, StringType)) {
                    throw new Error(`got a string, but expected ${typeName(expectedType)}`);
                }
                return new LiteralExpression(StringType, encoded);
            }
        default:
            {
            // pass
            }
    }
    if (!Array.isArray(encoded)) {
        throw new Error('expression must be an array or a primitive value');
    }
    if (encoded.length === 0) {
        throw new Error('empty expression');
    }
    if (typeof encoded[0] === 'string') {
        return parseCallExpression(encoded, expectedType, context);
    }
    for (const item of encoded){
        if (typeof item !== 'number') {
            throw new Error('expected an array of numbers');
        }
    }
    if (isType(expectedType, SizeType)) {
        if (encoded.length !== 2) {
            throw new Error(`expected an array of two values for a size, got ${encoded.length}`);
        }
        return new LiteralExpression(SizeType, encoded);
    }
    if (isType(expectedType, ColorType)) {
        if (encoded.length === 3) {
            return new LiteralExpression(ColorType, [
                ...encoded,
                1
            ]);
        }
        if (encoded.length === 4) {
            return new LiteralExpression(ColorType, encoded);
        }
        throw new Error(`expected an array of 3 or 4 values for a color, got ${encoded.length}`);
    }
    if (!includesType(expectedType, NumberArrayType)) {
        throw new Error(`got an array of numbers, but expected ${typeName(expectedType)}`);
    }
    return new LiteralExpression(NumberArrayType, encoded);
}
const Ops = {
    Get: 'get',
    Var: 'var',
    Concat: 'concat',
    GeometryType: 'geometry-type',
    LineMetric: 'line-metric',
    Any: 'any',
    All: 'all',
    Not: '!',
    Resolution: 'resolution',
    Zoom: 'zoom',
    Time: 'time',
    Equal: '==',
    NotEqual: '!=',
    GreaterThan: '>',
    GreaterThanOrEqualTo: '>=',
    LessThan: '<',
    LessThanOrEqualTo: '<=',
    Multiply: '*',
    Divide: '/',
    Add: '+',
    Subtract: '-',
    Clamp: 'clamp',
    Mod: '%',
    Pow: '^',
    Abs: 'abs',
    Floor: 'floor',
    Ceil: 'ceil',
    Round: 'round',
    Sin: 'sin',
    Cos: 'cos',
    Atan: 'atan',
    Sqrt: 'sqrt',
    Match: 'match',
    Between: 'between',
    Interpolate: 'interpolate',
    Coalesce: 'coalesce',
    Case: 'case',
    In: 'in',
    Number: 'number',
    String: 'string',
    Array: 'array',
    Color: 'color',
    Id: 'id',
    Band: 'band',
    Palette: 'palette',
    ToString: 'to-string',
    Has: 'has'
};
/**
 * @typedef {function(Array, number, ParsingContext):Expression} Parser
 *
 * Second argument is the expected type.
 */ /**
 * @type {Object<string, Parser>}
 */ const parsers = {
    [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
    [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
    [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
    [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
    [Ops.Concat]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(StringType)),
    [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
    [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
    [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),
    [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),
    [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),
    [Ops.Any]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),
    [Ops.All]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),
    [Ops.Not]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType)),
    [Ops.Equal]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),
    [Ops.NotEqual]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),
    [Ops.GreaterThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.LessThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.LessThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.Multiply]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),
    [Ops.Coalesce]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),
    [Ops.Divide]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.Add]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(NumberType)),
    [Ops.Subtract]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.Clamp]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),
    [Ops.Mod]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.Pow]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),
    [Ops.Abs]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Floor]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Ceil]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Round]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Sin]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Cos]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Atan]: createCallExpressionParser(hasArgsCount(1, 2), withArgsOfType(NumberType)),
    [Ops.Sqrt]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),
    [Ops.Match]: createCallExpressionParser(hasArgsCount(4, Infinity), hasEvenArgs, withMatchArgs),
    [Ops.Between]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),
    [Ops.Interpolate]: createCallExpressionParser(hasArgsCount(6, Infinity), hasEvenArgs, withInterpolateArgs),
    [Ops.Case]: createCallExpressionParser(hasArgsCount(3, Infinity), hasOddArgs, withCaseArgs),
    [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
    [Ops.Number]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),
    [Ops.String]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),
    [Ops.Array]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(NumberType)),
    [Ops.Color]: createCallExpressionParser(hasArgsCount(1, 4), withArgsOfType(NumberType)),
    [Ops.Band]: createCallExpressionParser(hasArgsCount(1, 3), withArgsOfType(NumberType)),
    [Ops.Palette]: createCallExpressionParser(hasArgsCount(2, 2), withPaletteArgs),
    [Ops.ToString]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType | NumberType | StringType | ColorType))
};
/**
 * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator
 *
 * An argument validator applies various checks to an encoded expression arguments and
 * returns the parsed arguments if any.  The second argument is the return type of the call expression.
 */ /**
 * @type {ArgValidator}
 */ function withGetArgs(encoded, returnType, context) {
    const argsCount = encoded.length - 1;
    const args = new Array(argsCount);
    for(let i = 0; i < argsCount; ++i){
        const key = encoded[i + 1];
        switch(typeof key){
            case 'number':
                {
                    args[i] = new LiteralExpression(NumberType, key);
                    break;
                }
            case 'string':
                {
                    args[i] = new LiteralExpression(StringType, key);
                    break;
                }
            default:
                {
                    throw new Error(`expected a string key or numeric array index for a get operation, got ${key}`);
                }
        }
        if (i === 0) {
            context.properties.add(String(key));
        }
    }
    return args;
}
/**
 * @type {ArgValidator}
 */ function withVarArgs(encoded, returnType, context) {
    const name = encoded[1];
    if (typeof name !== 'string') {
        throw new Error('expected a string argument for var operation');
    }
    context.variables.add(name);
    return [
        new LiteralExpression(StringType, name)
    ];
}
/**
 * @type {ArgValidator}
 */ function usesFeatureId(encoded, returnType, context) {
    context.featureId = true;
}
/**
 * @type {ArgValidator}
 */ function usesGeometryType(encoded, returnType, context) {
    context.geometryType = true;
}
/**
 * @type {ArgValidator}
 */ function usesMapState(encoded, returnType, context) {
    context.mapState = true;
}
/**
 * @type {ArgValidator}
 */ function withNoArgs(encoded, returnType, context) {
    const operation = encoded[0];
    if (encoded.length !== 1) {
        throw new Error(`expected no arguments for ${operation} operation`);
    }
    return [];
}
/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @return {ArgValidator} The argument validator
 */ function hasArgsCount(minArgs, maxArgs) {
    return function(encoded, returnType, context) {
        const operation = encoded[0];
        const argCount = encoded.length - 1;
        if (minArgs === maxArgs) {
            if (argCount !== minArgs) {
                const plural = minArgs === 1 ? '' : 's';
                throw new Error(`expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);
            }
        } else if (argCount < minArgs || argCount > maxArgs) {
            const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
            throw new Error(`expected ${range} arguments for ${operation}, got ${argCount}`);
        }
    };
}
/**
 * @type {ArgValidator}
 */ function withArgsOfReturnType(encoded, returnType, context) {
    const argCount = encoded.length - 1;
    /**
   * @type {Array<Expression>}
   */ const args = new Array(argCount);
    for(let i = 0; i < argCount; ++i){
        const expression = parse(encoded[i + 1], returnType, context);
        args[i] = expression;
    }
    return args;
}
/**
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */ function withArgsOfType(argType) {
    return function(encoded, returnType, context) {
        const argCount = encoded.length - 1;
        /**
     * @type {Array<Expression>}
     */ const args = new Array(argCount);
        for(let i = 0; i < argCount; ++i){
            const expression = parse(encoded[i + 1], argType, context);
            args[i] = expression;
        }
        return args;
    };
}
/**
 * @type {ArgValidator}
 */ function hasOddArgs(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 0) {
        throw new Error(`expected an odd number of arguments for ${operation}, got ${argCount} instead`);
    }
}
/**
 * @type {ArgValidator}
 */ function hasEvenArgs(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 1) {
        throw new Error(`expected an even number of arguments for operation ${operation}, got ${argCount} instead`);
    }
}
/**
 * @type {ArgValidator}
 */ function withMatchArgs(encoded, returnType, context) {
    const argsCount = encoded.length - 1;
    const inputType = StringType | NumberType | BooleanType;
    const input = parse(encoded[1], inputType, context);
    const fallback = parse(encoded[encoded.length - 1], returnType, context);
    const args = new Array(argsCount - 2);
    for(let i = 0; i < argsCount - 2; i += 2){
        try {
            const match = parse(encoded[i + 2], input.type, context);
            args[i] = match;
        } catch (err) {
            throw new Error(`failed to parse argument ${i + 1} of match expression: ${err.message}`);
        }
        try {
            const output = parse(encoded[i + 3], fallback.type, context);
            args[i + 1] = output;
        } catch (err) {
            throw new Error(`failed to parse argument ${i + 2} of match expression: ${err.message}`);
        }
    }
    return [
        input,
        ...args,
        fallback
    ];
}
/**
 * @type {ArgValidator}
 */ function withInterpolateArgs(encoded, returnType, context) {
    const interpolationType = encoded[1];
    /**
   * @type {number}
   */ let base;
    switch(interpolationType[0]){
        case 'linear':
            base = 1;
            break;
        case 'exponential':
            const b = interpolationType[1];
            if (typeof b !== 'number' || b <= 0) {
                throw new Error(`expected a number base for exponential interpolation` + `, got ${JSON.stringify(b)} instead`);
            }
            base = b;
            break;
        default:
            throw new Error(`invalid interpolation type: ${JSON.stringify(interpolationType)}`);
    }
    const interpolation = new LiteralExpression(NumberType, base);
    let input;
    try {
        input = parse(encoded[2], NumberType, context);
    } catch (err) {
        throw new Error(`failed to parse argument 1 in interpolate expression: ${err.message}`);
    }
    const args = new Array(encoded.length - 3);
    for(let i = 0; i < args.length; i += 2){
        try {
            const stop = parse(encoded[i + 3], NumberType, context);
            args[i] = stop;
        } catch (err) {
            throw new Error(`failed to parse argument ${i + 2} for interpolate expression: ${err.message}`);
        }
        try {
            const output = parse(encoded[i + 4], returnType, context);
            args[i + 1] = output;
        } catch (err) {
            throw new Error(`failed to parse argument ${i + 3} for interpolate expression: ${err.message}`);
        }
    }
    return [
        interpolation,
        input,
        ...args
    ];
}
/**
 * @type {ArgValidator}
 */ function withCaseArgs(encoded, returnType, context) {
    const fallback = parse(encoded[encoded.length - 1], returnType, context);
    const args = new Array(encoded.length - 1);
    for(let i = 0; i < args.length - 1; i += 2){
        try {
            const condition = parse(encoded[i + 1], BooleanType, context);
            args[i] = condition;
        } catch (err) {
            throw new Error(`failed to parse argument ${i} of case expression: ${err.message}`);
        }
        try {
            const output = parse(encoded[i + 2], fallback.type, context);
            args[i + 1] = output;
        } catch (err) {
            throw new Error(`failed to parse argument ${i + 1} of case expression: ${err.message}`);
        }
    }
    args[args.length - 1] = fallback;
    return args;
}
/**
 * @type {ArgValidator}
 */ function withInArgs(encoded, returnType, context) {
    let haystack = encoded[2];
    if (!Array.isArray(haystack)) {
        throw new Error(`the second argument for the "in" operator must be an array`);
    }
    /**
   * @type {number}
   */ let needleType;
    if (typeof haystack[0] === 'string') {
        if (haystack[0] !== 'literal') {
            throw new Error(`for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`);
        }
        if (!Array.isArray(haystack[1])) {
            throw new Error(`failed to parse "in" expression: the literal operator must be followed by an array`);
        }
        haystack = haystack[1];
        needleType = StringType;
    } else {
        needleType = NumberType;
    }
    const args = new Array(haystack.length);
    for(let i = 0; i < args.length; i++){
        try {
            const arg = parse(haystack[i], needleType, context);
            args[i] = arg;
        } catch (err) {
            throw new Error(`failed to parse haystack item ${i} for "in" expression: ${err.message}`);
        }
    }
    const needle = parse(encoded[1], needleType, context);
    return [
        needle,
        ...args
    ];
}
/**
 * @type {ArgValidator}
 */ function withPaletteArgs(encoded, returnType, context) {
    let index;
    try {
        index = parse(encoded[1], NumberType, context);
    } catch (err) {
        throw new Error(`failed to parse first argument in palette expression: ${err.message}`);
    }
    const colors = encoded[2];
    if (!Array.isArray(colors)) {
        throw new Error('the second argument of palette must be an array');
    }
    const parsedColors = new Array(colors.length);
    for(let i = 0; i < parsedColors.length; i++){
        let color;
        try {
            color = parse(colors[i], ColorType, context);
        } catch (err) {
            throw new Error(`failed to parse color at index ${i} in palette expression: ${err.message}`);
        }
        if (!(color instanceof LiteralExpression)) {
            throw new Error(`the palette color at index ${i} must be a literal value`);
        }
        parsedColors[i] = color;
    }
    return [
        index,
        ...parsedColors
    ];
}
/**
 * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected
 * to return the parsed arguments.
 * @return {Parser} The parser.
 */ function createCallExpressionParser(...validators) {
    return function(encoded, returnType, context) {
        const operator = encoded[0];
        /**
     * @type {Array<Expression>}
     */ let args;
        for(let i = 0; i < validators.length; i++){
            const parsed = validators[i](encoded, returnType, context);
            if (i == validators.length - 1) {
                if (!parsed) {
                    throw new Error('expected last argument validator to return the parsed args');
                }
                args = parsed;
            }
        }
        return new CallExpression(returnType, operator, ...args);
    };
}
/**
 * @param {Array} encoded The encoded expression.
 * @param {number} returnType The expected return type of the call expression.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression.
 */ function parseCallExpression(encoded, returnType, context) {
    const operator = encoded[0];
    const parser = parsers[operator];
    if (!parser) {
        throw new Error(`unknown operator: ${operator}`);
    }
    return parser(encoded, returnType, context);
}
function computeGeometryType(geometry) {
    if (!geometry) {
        return '';
    }
    const type = geometry.getType();
    switch(type){
        case 'Point':
        case 'LineString':
        case 'Polygon':
            return type;
        case 'MultiPoint':
        case 'MultiLineString':
        case 'MultiPolygon':
            return type.substring(5);
        case 'Circle':
            return 'Polygon';
        case 'GeometryCollection':
            return computeGeometryType(/** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries()[0]);
        default:
            return '';
    }
}
}}),
"[project]/node_modules/ol/expr/cpu.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/expr/cpu
 */ __turbopack_esm__({
    "buildExpression": (()=>buildExpression),
    "newEvaluationContext": (()=>newEvaluationContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/expr/expression.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/color.js [app-ssr] (ecmascript)");
;
;
function newEvaluationContext() {
    return {
        variables: {},
        properties: {},
        resolution: NaN,
        featureId: null,
        geometryType: ''
    };
}
function buildExpression(encoded, type, context) {
    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(encoded, type, context);
    return compileExpression(expression, context);
}
/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileExpression(expression, context) {
    if (expression instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LiteralExpression"]) {
        // convert colors to array if possible
        if (expression.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ColorType"] && typeof expression.value === 'string') {
            const colorValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromString"])(expression.value);
            return function() {
                return colorValue;
            };
        }
        return function() {
            return expression.value;
        };
    }
    const operator = expression.operator;
    switch(operator){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Number:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].String:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Coalesce:
            {
                return compileAssertionExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Get:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Var:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Has:
            {
                return compileAccessorExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Id:
            {
                return (context)=>context.featureId;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].GeometryType:
            {
                return (context)=>context.geometryType;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Concat:
            {
                const args = expression.args.map((e)=>compileExpression(e, context));
                return (context)=>''.concat(...args.map((arg)=>arg(context).toString()));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Resolution:
            {
                return (context)=>context.resolution;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Any:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].All:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Between:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].In:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Not:
            {
                return compileLogicalExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Equal:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].NotEqual:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].LessThan:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].LessThanOrEqualTo:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].GreaterThan:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].GreaterThanOrEqualTo:
            {
                return compileComparisonExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Multiply:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Divide:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Add:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Subtract:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Clamp:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Mod:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Pow:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Abs:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Floor:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Ceil:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Round:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Sin:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Cos:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Atan:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Sqrt:
            {
                return compileNumericExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Case:
            {
                return compileCaseExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Match:
            {
                return compileMatchExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Interpolate:
            {
                return compileInterpolateExpression(expression, context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].ToString:
            {
                return compileConvertExpression(expression, context);
            }
        default:
            {
                throw new Error(`Unsupported operator ${operator}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAssertionExpression(expression, context) {
    const type = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    switch(type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Coalesce:
            {
                return (context)=>{
                    for(let i = 0; i < length; ++i){
                        const value = args[i](context);
                        if (typeof value !== 'undefined' && value !== null) {
                            return value;
                        }
                    }
                    throw new Error('Expected one of the values to be non-null');
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Number:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].String:
            {
                return (context)=>{
                    for(let i = 0; i < length; ++i){
                        const value = args[i](context);
                        if (typeof value === type) {
                            return value;
                        }
                    }
                    throw new Error(`Expected one of the values to be a ${type}`);
                };
            }
        default:
            {
                throw new Error(`Unsupported assertion operator ${type}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAccessorExpression(expression, context) {
    const nameExpression = expression.args[0];
    const name = nameExpression.value;
    switch(expression.operator){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Get:
            {
                return (context)=>{
                    const args = expression.args;
                    let value = context.properties[name];
                    for(let i = 1, ii = args.length; i < ii; ++i){
                        const keyExpression = args[i];
                        const key = keyExpression.value;
                        value = value[key];
                    }
                    return value;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Var:
            {
                return (context)=>context.variables[name];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Has:
            {
                return (context)=>{
                    const args = expression.args;
                    if (!(name in context.properties)) {
                        return false;
                    }
                    let value = context.properties[name];
                    for(let i = 1, ii = args.length; i < ii; ++i){
                        const keyExpression = args[i];
                        const key = keyExpression.value;
                        if (!value || !Object.hasOwn(value, key)) {
                            return false;
                        }
                        value = value[key];
                    }
                    return true;
                };
            }
        default:
            {
                throw new Error(`Unsupported accessor operator ${expression.operator}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileComparisonExpression(expression, context) {
    const op = expression.operator;
    const left = compileExpression(expression.args[0], context);
    const right = compileExpression(expression.args[1], context);
    switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Equal:
            {
                return (context)=>left(context) === right(context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].NotEqual:
            {
                return (context)=>left(context) !== right(context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].LessThan:
            {
                return (context)=>left(context) < right(context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].LessThanOrEqualTo:
            {
                return (context)=>left(context) <= right(context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].GreaterThan:
            {
                return (context)=>left(context) > right(context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].GreaterThanOrEqualTo:
            {
                return (context)=>left(context) >= right(context);
            }
        default:
            {
                throw new Error(`Unsupported comparison operator ${op}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileLogicalExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Any:
            {
                return (context)=>{
                    for(let i = 0; i < length; ++i){
                        if (args[i](context)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].All:
            {
                return (context)=>{
                    for(let i = 0; i < length; ++i){
                        if (!args[i](context)) {
                            return false;
                        }
                    }
                    return true;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Between:
            {
                return (context)=>{
                    const value = args[0](context);
                    const min = args[1](context);
                    const max = args[2](context);
                    return value >= min && value <= max;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].In:
            {
                return (context)=>{
                    const value = args[0](context);
                    for(let i = 1; i < length; ++i){
                        if (value === args[i](context)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Not:
            {
                return (context)=>!args[0](context);
            }
        default:
            {
                throw new Error(`Unsupported logical operator ${op}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */ function compileNumericExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Multiply:
            {
                return (context)=>{
                    let value = 1;
                    for(let i = 0; i < length; ++i){
                        value *= args[i](context);
                    }
                    return value;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Divide:
            {
                return (context)=>args[0](context) / args[1](context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Add:
            {
                return (context)=>{
                    let value = 0;
                    for(let i = 0; i < length; ++i){
                        value += args[i](context);
                    }
                    return value;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Subtract:
            {
                return (context)=>args[0](context) - args[1](context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Clamp:
            {
                return (context)=>{
                    const value = args[0](context);
                    const min = args[1](context);
                    if (value < min) {
                        return min;
                    }
                    const max = args[2](context);
                    if (value > max) {
                        return max;
                    }
                    return value;
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Mod:
            {
                return (context)=>args[0](context) % args[1](context);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Pow:
            {
                return (context)=>Math.pow(args[0](context), args[1](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Abs:
            {
                return (context)=>Math.abs(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Floor:
            {
                return (context)=>Math.floor(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Ceil:
            {
                return (context)=>Math.ceil(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Round:
            {
                return (context)=>Math.round(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Sin:
            {
                return (context)=>Math.sin(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Cos:
            {
                return (context)=>Math.cos(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Atan:
            {
                if (length === 2) {
                    return (context)=>Math.atan2(args[0](context), args[1](context));
                }
                return (context)=>Math.atan(args[0](context));
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].Sqrt:
            {
                return (context)=>Math.sqrt(args[0](context));
            }
        default:
            {
                throw new Error(`Unsupported numeric operator ${op}`);
            }
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileCaseExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    return (context)=>{
        for(let i = 0; i < length - 1; i += 2){
            const condition = args[i](context);
            if (condition) {
                return args[i + 1](context);
            }
        }
        return args[length - 1](context);
    };
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileMatchExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    return (context)=>{
        const value = args[0](context);
        for(let i = 1; i < length; i += 2){
            if (value === args[i](context)) {
                return args[i + 1](context);
            }
        }
        return args[length - 1](context);
    };
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileInterpolateExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    return (context)=>{
        const base = args[0](context);
        const value = args[1](context);
        let previousInput;
        let previousOutput;
        for(let i = 2; i < length; i += 2){
            const input = args[i](context);
            let output = args[i + 1](context);
            const isColor = Array.isArray(output);
            if (isColor) {
                output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withAlpha"])(output);
            }
            if (input >= value) {
                if (i === 2) {
                    return output;
                }
                if (isColor) {
                    return interpolateColor(base, value, previousInput, previousOutput, input, output);
                }
                return interpolateNumber(base, value, previousInput, previousOutput, input, output);
            }
            previousInput = input;
            previousOutput = output;
        }
        return previousOutput;
    };
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileConvertExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i){
        args[i] = compileExpression(expression.args[i], context);
    }
    switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ops"].ToString:
            {
                return (context)=>{
                    const value = args[0](context);
                    if (expression.args[0].type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$expr$2f$expression$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ColorType"]) {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toString"])(value);
                    }
                    return value.toString();
                };
            }
        default:
            {
                throw new Error(`Unsupported convert operator ${op}`);
            }
    }
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {number} output1 The first output value.
 * @param {number} input2 The second input value.
 * @param {number} output2 The second output value.
 * @return {number} The interpolated value.
 */ function interpolateNumber(base, value, input1, output1, input2, output2) {
    const delta = input2 - input1;
    if (delta === 0) {
        return output1;
    }
    const along = value - input1;
    const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
    return output1 + factor * (output2 - output1);
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {import('../color.js').Color} rgba1 The first output value.
 * @param {number} input2 The second input value.
 * @param {import('../color.js').Color} rgba2 The second output value.
 * @return {import('../color.js').Color} The interpolated color.
 */ function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
    const delta = input2 - input1;
    if (delta === 0) {
        return rgba1;
    }
    const lcha1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbaToLcha"])(rgba1);
    const lcha2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbaToLcha"])(rgba2);
    let deltaHue = lcha2[2] - lcha1[2];
    if (deltaHue > 180) {
        deltaHue -= 360;
    } else if (deltaHue < -180) {
        deltaHue += 360;
    }
    const lcha = [
        interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
        interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
        lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
        interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalize"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lchaToRgba"])(lcha));
}
}}),
"[project]/node_modules/ol/featureloader.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/featureloader
 */ __turbopack_esm__({
    "loadFeaturesXhr": (()=>loadFeaturesXhr),
    "setWithCredentials": (()=>setWithCredentials),
    "xhr": (()=>xhr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
;
/**
 *
 * @type {boolean}
 * @private
 */ let withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
    if (format.getType() == 'arraybuffer') {
        xhr.responseType = 'arraybuffer';
    }
    xhr.withCredentials = withCredentials;
    /**
   * @param {Event} event Event.
   * @private
   */ xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
            const type = format.getType();
            try {
                /** @type {Document|Node|Object|string|undefined} */ let source;
                if (type == 'text' || type == 'json') {
                    source = xhr.responseText;
                } else if (type == 'xml') {
                    source = xhr.responseXML || xhr.responseText;
                } else if (type == 'arraybuffer') {
                    source = xhr.response;
                }
                if (source) {
                    success(format.readFeatures(source, {
                        extent: extent,
                        featureProjection: projection
                    }), format.readProjection(source));
                } else {
                    failure();
                }
            } catch  {
                failure();
            }
        } else {
            failure();
        }
    };
    /**
   * @private
   */ xhr.onerror = failure;
    xhr.send();
}
function xhr(url, format) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<FeatureType>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   * @this {import("./source/Vector.js").default<FeatureType>}
   */ return function(extent, resolution, projection, success, failure) {
        loadFeaturesXhr(url, format, extent, resolution, projection, /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */ (features, dataProjection)=>{
            this.addFeatures(features);
            if (success !== undefined) {
                success(features);
            }
        }, /* FIXME handle error */ failure ? failure : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"]);
    };
}
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}
}}),
"[project]/node_modules/ol/loadingstrategy.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/loadingstrategy
 */ __turbopack_esm__({
    "all": (()=>all),
    "bbox": (()=>bbox),
    "tile": (()=>tile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
;
function all(extent, resolution) {
    return [
        [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ]
    ];
}
function bbox(extent, resolution) {
    return [
        extent
    ];
}
function tile(tileGrid) {
    return(/**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */ function(extent, resolution, projection) {
        const z = tileGrid.getZForResolution((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserResolution"])(resolution, projection));
        const tileRange = tileGrid.getTileRangeForExtentAndZ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */ const extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */ const tileCoord = [
            z,
            0,
            0
        ];
        for(tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]){
            for(tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]){
                extents.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserExtent"])(tileGrid.getTileCoordExtent(tileCoord), projection));
            }
        }
        return extents;
    });
}
}}),
"[project]/node_modules/ol/structs/RBush.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/structs/RBush
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {import("rbush").BBox & {value: T}} Entry
 * @template T
 */ /**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template {Object} T
 */ class RBush {
    /**
   * @param {number} [maxEntries] Max entries.
   */ constructor(maxEntries){
        /**
     * @private
     * @type {RBush_<Entry<T>>}
     */ this.rbush_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](maxEntries);
        /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry<T>>}
     */ this.items_ = {};
    }
    /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ insert(extent, value) {
        /** @type {Entry<T>} */ const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value
        };
        this.rbush_.insert(item);
        this.items_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(value)] = item;
    }
    /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */ load(extents, values) {
        const items = new Array(values.length);
        for(let i = 0, l = values.length; i < l; i++){
            const extent = extents[i];
            const value = values[i];
            /** @type {Entry<T>} */ const item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value
            };
            items[i] = item;
            this.items_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(value)] = item;
        }
        this.rbush_.load(items);
    }
    /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */ remove(value) {
        const uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    }
    /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ update(extent, value) {
        const item = this.items_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(value)];
        const bbox = [
            item.minX,
            item.minY,
            item.maxX,
            item.maxY
        ];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    }
    /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */ getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */ getInExtent(extent) {
        /** @type {import("rbush").BBox} */ const bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */ forEach(callback) {
        return this.forEach_(this.getAll(), callback);
    }
    /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */ forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
   * @param {Array<T>} values Values.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   * @private
   */ forEach_(values, callback) {
        let result;
        for(let i = 0, l = values.length; i < l; i++){
            result = callback(values[i]);
            if (result) {
                return result;
            }
        }
        return result;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(this.items_);
    }
    /**
   * Remove all values from the RBush.
   */ clear() {
        this.rbush_.clear();
        this.items_ = {};
    }
    /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */ getExtent(extent) {
        const data = this.rbush_.toJSON();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
   * @param {RBush<T>} rbush R-Tree.
   */ concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for(const i in rbush.items_){
            this.items_[i] = rbush.items_[i];
        }
    }
}
const __TURBOPACK__default__export__ = RBush;
}}),
"[project]/node_modules/ol/structs/PriorityQueue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/structs/PriorityQueue
 */ __turbopack_esm__({
    "DROP": (()=>DROP),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
;
;
const DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */ class PriorityQueue {
    /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */ constructor(priorityFunction, keyFunction){
        /**
     * @type {function(T): number}
     * @private
     */ this.priorityFunction_ = priorityFunction;
        /**
     * @type {function(T): string}
     * @private
     */ this.keyFunction_ = keyFunction;
        /**
     * @type {Array<T>}
     * @private
     */ this.elements_ = [];
        /**
     * @type {Array<number>}
     * @private
     */ this.priorities_ = [];
        /**
     * @type {!Object<string, boolean>}
     * @private
     */ this.queuedElements_ = {};
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])(this.queuedElements_);
    }
    /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */ dequeue() {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[0];
        if (elements.length == 1) {
            elements.length = 0;
            priorities.length = 0;
        } else {
            elements[0] = elements.pop();
            priorities[0] = priorities.pop();
            this.siftUp_(0);
        }
        const elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
    }
    /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */ enqueue(element) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!(this.keyFunction_(element) in this.queuedElements_), 'Tried to enqueue an `element` that was already added to the queue');
        const priority = this.priorityFunction_(element);
        if (priority != DROP) {
            this.elements_.push(element);
            this.priorities_.push(priority);
            this.queuedElements_[this.keyFunction_(element)] = true;
            this.siftDown_(0, this.elements_.length - 1);
            return true;
        }
        return false;
    }
    /**
   * @return {number} Count.
   */ getCount() {
        return this.elements_.length;
    }
    /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */ getLeftChildIndex_(index) {
        return index * 2 + 1;
    }
    /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */ getRightChildIndex_(index) {
        return index * 2 + 2;
    }
    /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */ getParentIndex_(index) {
        return index - 1 >> 1;
    }
    /**
   * Make this a heap. O(N).
   * @private
   */ heapify_() {
        let i;
        for(i = (this.elements_.length >> 1) - 1; i >= 0; i--){
            this.siftUp_(i);
        }
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.elements_.length === 0;
    }
    /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */ isKeyQueued(key) {
        return key in this.queuedElements_;
    }
    /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */ isQueued(element) {
        return this.isKeyQueued(this.keyFunction_(element));
    }
    /**
   * @param {number} index The index of the node to move down.
   * @private
   */ siftUp_(index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const count = elements.length;
        const element = elements[index];
        const priority = priorities[index];
        const startIndex = index;
        while(index < count >> 1){
            const lIndex = this.getLeftChildIndex_(index);
            const rIndex = this.getRightChildIndex_(index);
            const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
            elements[index] = elements[smallerChildIndex];
            priorities[index] = priorities[smallerChildIndex];
            index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
    }
    /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */ siftDown_(startIndex, index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[index];
        const priority = priorities[index];
        while(index > startIndex){
            const parentIndex = this.getParentIndex_(index);
            if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
            } else {
                break;
            }
        }
        elements[index] = element;
        priorities[index] = priority;
    }
    /**
   * FIXME empty description for jsdoc
   */ reprioritize() {
        const priorityFunction = this.priorityFunction_;
        const elements = this.elements_;
        const priorities = this.priorities_;
        let index = 0;
        const n = elements.length;
        let element, i, priority;
        for(i = 0; i < n; ++i){
            element = elements[i];
            priority = priorityFunction(element);
            if (priority == DROP) {
                delete this.queuedElements_[this.keyFunction_(element)];
            } else {
                priorities[index] = priority;
                elements[index++] = element;
            }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
    }
}
const __TURBOPACK__default__export__ = PriorityQueue;
}}),
"[project]/node_modules/ol/CollectionEventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/CollectionEventType
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */ ADD: 'add',
    /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */ REMOVE: 'remove'
};
}}),
"[project]/node_modules/ol/Collection.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Collection
 */ __turbopack_esm__({
    "CollectionEvent": (()=>CollectionEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
;
;
;
/**
 * @enum {string}
 * @private
 */ const Property = {
    LENGTH: 'length'
};
class CollectionEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */ constructor(type, element, index){
        super(type);
        /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */ this.element = element;
        /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */ this.index = index;
    }
}
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */ /**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */ class Collection extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */ constructor(array, options){
        super();
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {CollectionOnSignature<T, void>}
     */ this.un;
        options = options || {};
        /**
     * @private
     * @type {boolean}
     */ this.unique_ = !!options.unique;
        /**
     * @private
     * @type {!Array<T>}
     */ this.array_ = array ? array : [];
        if (this.unique_) {
            for(let i = 0, ii = this.array_.length; i < ii; ++i){
                this.assertUnique_(this.array_[i], i);
            }
        }
        this.updateLength_();
    }
    /**
   * Remove all elements from the collection.
   * @api
   */ clear() {
        while(this.getLength() > 0){
            this.pop();
        }
    }
    /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */ extend(arr) {
        for(let i = 0, ii = arr.length; i < ii; ++i){
            this.push(arr[i]);
        }
        return this;
    }
    /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */ forEach(f) {
        const array = this.array_;
        for(let i = 0, ii = array.length; i < ii; ++i){
            f(array[i], i, array);
        }
    }
    /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */ getArray() {
        return this.array_;
    }
    /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */ item(index) {
        return this.array_[index];
    }
    /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */ getLength() {
        return this.get(Property.LENGTH);
    }
    /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
            throw new Error('Index out of bounds: ' + index);
        }
        if (this.unique_) {
            this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, elem, index));
    }
    /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */ pop() {
        return this.removeAt(this.getLength() - 1);
    }
    /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */ push(elem) {
        if (this.unique_) {
            this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    }
    /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */ remove(elem) {
        const arr = this.array_;
        for(let i = 0, ii = arr.length; i < ii; ++i){
            if (arr[i] === elem) {
                return this.removeAt(i);
            }
        }
        return undefined;
    }
    /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */ removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
            return undefined;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, prev, index));
        return prev;
    }
    /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
            this.insertAt(index, elem);
            return;
        }
        if (index < 0) {
            throw new Error('Index out of bounds: ' + index);
        }
        if (this.unique_) {
            this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(new CollectionEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, prev, index));
        this.dispatchEvent(new CollectionEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, elem, index));
    }
    /**
   * @private
   */ updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
    }
    /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */ assertUnique_(elem, except) {
        for(let i = 0, ii = this.array_.length; i < ii; ++i){
            if (this.array_[i] === elem && i !== except) {
                throw new Error('Duplicate item added to a unique collection');
            }
        }
    }
}
const __TURBOPACK__default__export__ = Collection;
}}),
"[project]/node_modules/ol/source/VectorEventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/source/VectorEventType
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */ ADDFEATURE: 'addfeature',
    /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */ CHANGEFEATURE: 'changefeature',
    /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */ CLEAR: 'clear',
    /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */ REMOVEFEATURE: 'removefeature',
    /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */ FEATURESLOADSTART: 'featuresloadstart',
    /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */ FEATURESLOADEND: 'featuresloadend',
    /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */ FEATURESLOADERROR: 'featuresloaderror'
};
 /**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */ }}),
"[project]/node_modules/ol/source/Source.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/source/Source
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
;
;
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */ /**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */ /**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * a simple string (e.g. `' Acme Inc.'`)
 * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)
 * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */ /**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */ class Source extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} options Source options.
   */ constructor(options){
        super();
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */ this.projection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"])(options.projection);
        /**
     * @private
     * @type {?Attribution}
     */ this.attributions_ = adaptAttributions(options.attributions);
        /**
     * @private
     * @type {boolean}
     */ this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
        /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */ this.loading = false;
        /**
     * @private
     * @type {import("./Source.js").State}
     */ this.state_ = options.state !== undefined ? options.state : 'ready';
        /**
     * @private
     * @type {boolean}
     */ this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = !!options.interpolate;
        /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */ this.viewResolver = null;
        /**
     * @protected
     * @type {function(Error):void}
     */ this.viewRejector = null;
        const self = this;
        /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */ this.viewPromise_ = new Promise(function(resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
    }
    /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */ getAttributions() {
        return this.attributions_;
    }
    /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */ getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
    }
    /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */ getProjection() {
        return this.projection;
    }
    /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */ getResolutions(projection) {
        return null;
    }
    /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */ getView() {
        return this.viewPromise_;
    }
    /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */ getState() {
        return this.state_;
    }
    /**
   * @return {boolean|undefined} Wrap X.
   */ getWrapX() {
        return this.wrapX_;
    }
    /**
   * @return {boolean} Use linear interpolation when resampling.
   */ getInterpolate() {
        return this.interpolate_;
    }
    /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */ refresh() {
        this.changed();
    }
    /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */ setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    }
    /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */ setState(state) {
        this.state_ = state;
        this.changed();
    }
}
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */ function adaptAttributions(attributionLike) {
    if (!attributionLike) {
        return null;
    }
    if (typeof attributionLike === 'function') {
        return attributionLike;
    }
    if (!Array.isArray(attributionLike)) {
        attributionLike = [
            attributionLike
        ];
    }
    return (frameState)=>attributionLike;
}
const __TURBOPACK__default__export__ = Source;
}}),
"[project]/node_modules/ol/source/Vector.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/source/Vector
 */ __turbopack_esm__({
    "VectorSourceEvent": (()=>VectorSourceEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$featureloader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/featureloader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$loadingstrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/loadingstrategy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$RBush$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/structs/RBush.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/VectorEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Feature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Source$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/Source.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class VectorSourceEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} type Type.
   * @param {FeatureType} [feature] Feature.
   * @param {Array<FeatureType>} [features] Features.
   */ constructor(type, feature, features){
        super(type);
        /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {FeatureType|undefined}
     * @api
     */ this.feature = feature;
        /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<FeatureType>|undefined}
     * @api
     */ this.features = features;
    }
}
/***
 * @template {import("../Feature.js").FeatureLike} [T=import("../Feature.js").default]
 * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures
 */ /***
 * @template Return
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */ /**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<FeatureType>|Collection<FeatureType>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default<FeatureType>} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader<FeatureType>} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180 and 180 meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */ /**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 */ class VectorSource extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Source$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */ constructor(options){
        options = options || {};
        super({
            attributions: options.attributions,
            interpolate: true,
            projection: undefined,
            state: 'ready',
            wrapX: options.wrapX !== undefined ? options.wrapX : true
        });
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey, FeatureType>}
     */ this.on;
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey, FeatureType>}
     */ this.once;
        /***
     * @type {VectorSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader<import("../Feature.js").FeatureLike>}
     */ this.loader_ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"];
        /**
     * @private
     * @type {import("../format/Feature.js").default<FeatureType>|null}
     */ this.format_ = options.format || null;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */ this.url_ = options.url;
        if (options.loader !== undefined) {
            this.loader_ = options.loader;
        } else if (this.url_ !== undefined) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(this.format_, '`format` must be set when `url` is set');
            // create a XHR feature loader for "url" and "format"
            this.loader_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$featureloader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["xhr"])(this.url_, this.format_);
        }
        /**
     * @private
     * @type {LoadingStrategy}
     */ this.strategy_ = options.strategy !== undefined ? options.strategy : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$loadingstrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["all"];
        const useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
     * @private
     * @type {RBush<FeatureType>}
     */ this.featuresRtree_ = useSpatialIndex ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$RBush$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]() : null;
        /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */ this.loadedExtentsRtree_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$RBush$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        /**
     * @type {number}
     * @private
     */ this.loadingExtentsCount_ = 0;
        /**
     * @private
     * @type {!Object<string, FeatureType>}
     */ this.nullGeometryFeatures_ = {};
        /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}
     */ this.idIndex_ = {};
        /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, FeatureType>}
     */ this.uidIndex_ = {};
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.featureChangeKeys_ = {};
        /**
     * @private
     * @type {Collection<FeatureType>|null}
     */ this.featuresCollection_ = null;
        /** @type {Collection<FeatureType>} */ let collection;
        /** @type {Array<FeatureType>} */ let features;
        if (Array.isArray(options.features)) {
            features = options.features;
        } else if (options.features) {
            collection = options.features;
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) {
            collection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](features);
        }
        if (features !== undefined) {
            this.addFeaturesInternal(features);
        }
        if (collection !== undefined) {
            this.bindFeaturesCollection_(collection);
        }
    }
    /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */ addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
    }
    /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */ addFeatureInternal(feature) {
        const featureKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) {
                this.featuresCollection_.remove(feature);
            }
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const extent = geometry.getExtent();
            if (this.featuresRtree_) {
                this.featuresRtree_.insert(extent, feature);
            }
        } else {
            this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADDFEATURE, feature));
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */ setupChangeEvents_(featureKey, feature) {
        if (feature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
            return;
        }
        this.featureChangeKeys_[featureKey] = [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(feature, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.handleFeatureChange_, this),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(feature, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE, this.handleFeatureChange_, this)
        ];
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */ addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== undefined) {
            const id = String(feature.getId());
            if (!(id in this.idIndex_)) {
                this.idIndex_[id] = feature;
            } else if (feature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
                const indexedFeature = this.idIndex_[id];
                if (!(indexedFeature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])) {
                    valid = false;
                } else if (!Array.isArray(indexedFeature)) {
                    this.idIndex_[id] = [
                        indexedFeature,
                        feature
                    ];
                } else {
                    indexedFeature.push(feature);
                }
            } else {
                valid = false;
            }
        }
        if (valid) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!(featureKey in this.uidIndex_), 'The passed `feature` was already added to the source');
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    }
    /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */ addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
    }
    /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */ addFeaturesInternal(features) {
        const extents = [];
        /** @type {Array<FeatureType>} */ const newFeatures = [];
        /** @type {Array<FeatureType>} */ const geometryFeatures = [];
        for(let i = 0, length = features.length; i < length; i++){
            const feature = features[i];
            const featureKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
            if (this.addToIndex_(featureKey, feature)) {
                newFeatures.push(feature);
            }
        }
        for(let i = 0, length = newFeatures.length; i < length; i++){
            const feature = newFeatures[i];
            const featureKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
            this.setupChangeEvents_(featureKey, feature);
            const geometry = feature.getGeometry();
            if (geometry) {
                const extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
            } else {
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        }
        if (this.featuresRtree_) {
            this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADDFEATURE)) {
            for(let i = 0, length = newFeatures.length; i < length; i++){
                this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADDFEATURE, newFeatures[i]));
            }
        }
    }
    /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */ bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADDFEATURE, /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVEFEATURE, /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
            }
        });
        collection.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
            }
        });
        this.featuresCollection_ = collection;
    }
    /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */ clear(fast) {
        if (fast) {
            for(const featureId in this.featureChangeKeys_){
                const keys = this.featureChangeKeys_[featureId];
                keys.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
            }
        } else {
            if (this.featuresRtree_) {
                this.featuresRtree_.forEach((feature)=>{
                    this.removeFeatureInternal(feature);
                });
                for(const id in this.nullGeometryFeatures_){
                    this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                }
            }
        }
        if (this.featuresCollection_) {
            this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
            this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    }
    /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeature(callback) {
        if (this.featuresRtree_) {
            return this.featuresRtree_.forEach(callback);
        }
        if (this.featuresCollection_) {
            this.featuresCollection_.forEach(callback);
        }
    }
    /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */ forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [
            coordinate[0],
            coordinate[1],
            coordinate[0],
            coordinate[1]
        ];
        return this.forEachFeatureInExtent(extent, function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] || geometry.intersectsCoordinate(coordinate)) {
                return callback(feature);
            }
            return undefined;
        });
    }
    /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) {
            return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        if (this.featuresCollection_) {
            this.featuresCollection_.forEach(callback);
        }
    }
    /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(extent, /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */ function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] || geometry.intersectsExtent(extent)) {
                const result = callback(feature);
                if (result) {
                    return result;
                }
            }
        });
    }
    /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with a {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */ getFeaturesCollection() {
        return this.featuresCollection_;
    }
    /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */ getFeatures() {
        let features;
        if (this.featuresCollection_) {
            features = this.featuresCollection_.getArray().slice(0);
        } else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(this.nullGeometryFeatures_)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extend"])(features, Object.values(this.nullGeometryFeatures_));
            }
        }
        return features;
    }
    /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<FeatureType>} Features.
   * @api
   */ getFeaturesAtCoordinate(coordinate) {
        /** @type {Array<FeatureType>} */ const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
            features.push(feature);
        });
        return features;
    }
    /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */ getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
            const multiWorld = projection && projection.canWrapX() && this.getWrapX();
            if (!multiWorld) {
                return this.featuresRtree_.getInExtent(extent);
            }
            const extents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrapAndSliceX"])(extent, projection);
            return [].concat(...extents.map((anExtent)=>this.featuresRtree_.getInExtent(anExtent)));
        }
        if (this.featuresCollection_) {
            return this.featuresCollection_.getArray().slice(0);
        }
        return [];
    }
    /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */ getClosestFeatureToCoordinate(coordinate, filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [
            NaN,
            NaN
        ];
        let minSquaredDistance = Infinity;
        const extent = [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ];
        filter = filter ? filter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRUE"];
        this.featuresRtree_.forEachInExtent(extent, /**
       * @param {FeatureType} feature Feature.
       */ function(feature) {
            if (filter(feature)) {
                const geometry = feature.getGeometry();
                const previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    const minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    }
    /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
    }
    /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */ getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */ getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * @return {boolean} The source can have overlapping geometries.
   */ getOverlaps() {
        return this.overlaps_;
    }
    /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */ getUrl() {
        return this.url_;
    }
    /**
   * @param {Event} event Event.
   * @private
   */ handleFeatureChange_(event) {
        const feature = event.target;
        const featureKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) {
                    this.featuresRtree_.remove(feature);
                }
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        } else {
            const extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) {
                    this.featuresRtree_.insert(extent, feature);
                }
            } else {
                if (this.featuresRtree_) {
                    this.featuresRtree_.update(extent, feature);
                }
            }
        }
        const id = feature.getId();
        if (id !== undefined) {
            const sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        } else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGEFEATURE, feature));
    }
    /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */ hasFeature(feature) {
        const id = feature.getId();
        if (id !== undefined) {
            return id in this.idIndex_;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature) in this.uidIndex_;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        if (this.featuresRtree_) {
            return this.featuresRtree_.isEmpty() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(this.nullGeometryFeatures_);
        }
        if (this.featuresCollection_) {
            return this.featuresCollection_.getLength() === 0;
        }
        return true;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for(let i = 0, ii = extentsToLoad.length; i < ii; ++i){
            const extentToLoad = extentsToLoad[i];
            const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */ function(object) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsExtent"])(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this.loadingExtentsCount_;
                this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].FEATURESLOADSTART));
                this.loader_.call(this, extentToLoad, resolution, projection, /**
           * @param {Array<FeatureType>} features Loaded features
           */ (features)=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].FEATURESLOADEND, undefined, features));
                }, ()=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].FEATURESLOADERROR));
                });
                loadedExtentsRtree.insert(extentToLoad, {
                    extent: extentToLoad.slice()
                });
            }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
    /**
   * @override
   */ refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
    }
    /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const obj = loadedExtentsRtree.forEachInExtent(extent, function(object) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(object.extent, extent)) {
                return object;
            }
        });
        if (obj) {
            loadedExtentsRtree.remove(obj);
        }
    }
    /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */ removeFeatures(features) {
        let removed = false;
        for(let i = 0, ii = features.length; i < ii; ++i){
            removed = this.removeFeatureInternal(features[i]) || removed;
        }
        if (removed) {
            this.changed();
        }
    }
    /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */ removeFeature(feature) {
        if (!feature) {
            return;
        }
        const removed = this.removeFeatureInternal(feature);
        if (removed) {
            this.changed();
        }
    }
    /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {boolean} True if the feature was removed, false if it was not found.
   * @protected
   */ removeFeatureInternal(feature) {
        const featureKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(feature);
        if (!(featureKey in this.uidIndex_)) {
            return false;
        }
        if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
        } else {
            if (this.featuresRtree_) {
                this.featuresRtree_.remove(feature);
            }
        }
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        featureChangeKeys?.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== undefined) {
            const idString = id.toString();
            const indexedFeature = this.idIndex_[idString];
            if (indexedFeature === feature) {
                delete this.idIndex_[idString];
            } else if (Array.isArray(indexedFeature)) {
                indexedFeature.splice(indexedFeature.indexOf(feature), 1);
                if (indexedFeature.length === 1) {
                    this.idIndex_[idString] = indexedFeature[0];
                }
            }
        }
        delete this.uidIndex_[featureKey];
        if (this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVEFEATURE)) {
            this.dispatchEvent(new VectorSourceEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVEFEATURE, feature));
        }
        return true;
    }
    /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @private
   */ removeFromIdIndex_(feature) {
        for(const id in this.idIndex_){
            if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                break;
            }
        }
    }
    /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */ setLoader(loader) {
        this.loader_ = loader;
    }
    /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */ setUrl(url) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(this.format_, '`format` must be set when `url` is set');
        this.url_ = url;
        this.setLoader((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$featureloader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["xhr"])(url, this.format_));
    }
    /**
   * @param {boolean} overlaps The source can have overlapping geometries.
   */ setOverlaps(overlaps) {
        this.overlaps_ = overlaps;
        this.changed();
    }
}
const __TURBOPACK__default__export__ = VectorSource;
}}),
"[project]/node_modules/ol/source/Vector.js [app-ssr] (ecmascript) <export default as Vector>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Vector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/Vector.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/ol/Feature.js [app-ssr] (ecmascript) <export default as Feature>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: require } = __turbopack_context__;
{
__turbopack_esm__({
    "Feature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/ol/MapEventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapEventType
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */ POSTRENDER: 'postrender',
    /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */ MOVESTART: 'movestart',
    /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */ MOVEEND: 'moveend',
    /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */ LOADSTART: 'loadstart',
    /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */ LOADEND: 'loadend'
};
 /***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */ }}),
"[project]/node_modules/ol/control/Control.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/control/Control
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */ class Control extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} options Control options.
   */ constructor(options){
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
            element.style.pointerEvents = 'auto';
        }
        /**
     * @protected
     * @type {HTMLElement}
     */ this.element = element ? element : null;
        /**
     * @private
     * @type {HTMLElement}
     */ this.target_ = null;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */ this.listenerKeys = [];
        if (options.render) {
            this.render = options.render;
        }
        if (options.target) {
            this.setTarget(options.target);
        }
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        this.element?.remove();
        super.disposeInternal();
    }
    /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.map_) {
            this.element?.remove();
        }
        for(let i = 0, ii = this.listenerKeys.length; i < ii; ++i){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
            const target = this.target_ ?? map.getOverlayContainerStopEvent();
            if (this.element) {
                target.appendChild(this.element);
            }
            if (this.render !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VOID"]) {
                this.listenerKeys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(map, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTRENDER, this.render, this));
            }
            map.render();
        }
    }
    /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */ render(mapEvent) {}
    /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */ setTarget(target) {
        this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
    }
}
const __TURBOPACK__default__export__ = Control;
}}),
"[project]/node_modules/ol/control/Zoom.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/control/Zoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/css.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Control.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel=''] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */ class Zoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Zoom options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            target: options.target
        });
        const className = options.className !== undefined ? options.className : 'ol-zoom';
        const delta = options.delta !== undefined ? options.delta : 1;
        const zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
        const zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
        const zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
        const zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';
        const zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
        const zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
        const inElement = document.createElement('button');
        inElement.className = zoomInClassName;
        inElement.setAttribute('type', 'button');
        inElement.title = zoomInTipLabel;
        inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
        inElement.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, this.handleClick_.bind(this, delta), false);
        const outElement = document.createElement('button');
        outElement.className = zoomOutClassName;
        outElement.setAttribute('type', 'button');
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
        outElement.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, this.handleClick_.bind(this, -delta), false);
        const cssClasses = className + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_UNSELECTABLE"] + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_CONTROL"];
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
    }
    /**
   * @param {number} delta Zoom delta.
   * @private
   */ zoomByDelta_(delta) {
        const map = this.getMap();
        const view = map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        const currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            const newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (this.duration_ > 0) {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.animate({
                    zoom: newZoom,
                    duration: this.duration_,
                    easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeOut"]
                });
            } else {
                view.setZoom(newZoom);
            }
        }
    }
}
const __TURBOPACK__default__export__ = Zoom;
}}),
"[project]/node_modules/ol/control/Rotate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/control/Rotate
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/css.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Control.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */ class Rotate extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Rotate options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        });
        const className = options.className !== undefined ? options.className : 'ol-rotate';
        const label = options.label !== undefined ? options.label : '\u21E7';
        const compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
        /**
     * @type {HTMLElement}
     * @private
     */ this.label_ = null;
        if (typeof label === 'string') {
            this.label_ = document.createElement('span');
            this.label_.className = compassClassName;
            this.label_.textContent = label;
        } else {
            this.label_ = label;
            this.label_.classList.add(compassClassName);
        }
        const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
        const button = document.createElement('button');
        button.className = className + '-reset';
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(this.label_);
        button.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_UNSELECTABLE"] + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_CONTROL"];
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(button);
        /**
     * @private
     */ this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @type {boolean}
     * @private
     */ this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        if (this.autoHide_) {
            this.element.classList.add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_HIDDEN"]);
        }
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) {
            this.callResetNorth_();
        } else {
            this.resetNorth_();
        }
    }
    /**
   * @private
   */ resetNorth_() {
        const map = this.getMap();
        const view = map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        const rotation = view.getRotation();
        if (rotation !== undefined) {
            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                view.animate({
                    rotation: 0,
                    duration: this.duration_,
                    easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["easeOut"]
                });
            } else {
                view.setRotation(0);
            }
        }
    }
    /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        const frameState = mapEvent.frameState;
        if (!frameState) {
            return;
        }
        const rotation = frameState.viewState.rotation;
        if (rotation != this.rotation_) {
            const transform = 'rotate(' + rotation + 'rad)';
            if (this.autoHide_) {
                const contains = this.element.classList.contains(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_HIDDEN"]);
                if (!contains && rotation === 0) {
                    this.element.classList.add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_HIDDEN"]);
                } else if (contains && rotation !== 0) {
                    this.element.classList.remove(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_HIDDEN"]);
                }
            }
            this.label_.style.transform = transform;
        }
        this.rotation_ = rotation;
    }
}
const __TURBOPACK__default__export__ = Rotate;
}}),
"[project]/node_modules/ol/control/Attribution.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/control/Attribution
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/css.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Control.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel=''] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {string|Array<string>|undefined} [attributions] Optional attribution(s) that will always be
 * displayed regardless of the layers rendered
 */ /**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */ class Attribution extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Control$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Attribution options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        });
        /**
     * @private
     * @type {HTMLElement}
     */ this.ulElement_ = document.createElement('ul');
        /**
     * @private
     * @type {boolean}
     */ this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
        /**
     * @private
     * @type {boolean}
     */ this.userCollapsed_ = this.collapsed_;
        /**
     * @private
     * @type {boolean}
     */ this.overrideCollapsible_ = options.collapsible !== undefined;
        /**
     * @private
     * @type {boolean}
     */ this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
        if (!this.collapsible_) {
            this.collapsed_ = false;
        }
        /**
     * @private
     * @type {string | Array<string> | undefined}
     */ this.attributions_ = options.attributions;
        const className = options.className !== undefined ? options.className : 'ol-attribution';
        const tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
        const expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
        const collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';
        const collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';
        if (typeof collapseLabel === 'string') {
            /**
       * @private
       * @type {HTMLElement}
       */ this.collapseLabel_ = document.createElement('span');
            this.collapseLabel_.textContent = collapseLabel;
            this.collapseLabel_.className = collapseClassName;
        } else {
            this.collapseLabel_ = collapseLabel;
        }
        const label = options.label !== undefined ? options.label : 'i';
        if (typeof label === 'string') {
            /**
       * @private
       * @type {HTMLElement}
       */ this.label_ = document.createElement('span');
            this.label_.textContent = label;
            this.label_.className = expandClassName;
        } else {
            this.label_ = label;
        }
        const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
        /**
     * @private
     * @type {HTMLElement}
     */ this.toggleButton_ = document.createElement('button');
        this.toggleButton_.setAttribute('type', 'button');
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
        this.toggleButton_.title = tipLabel;
        this.toggleButton_.appendChild(activeLabel);
        this.toggleButton_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_UNSELECTABLE"] + ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_CONTROL"] + (this.collapsed_ && this.collapsible_ ? ' ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_COLLAPSED"] : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(this.toggleButton_);
        element.appendChild(this.ulElement_);
        /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */ this.renderedAttributions_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
    }
    /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */ collectSourceAttributions_(frameState) {
        const layers = this.getMap().getAllLayers();
        const visibleAttributions = new Set(layers.flatMap((layer)=>layer.getAttributions(frameState)));
        if (this.attributions_ !== undefined) {
            Array.isArray(this.attributions_) ? this.attributions_.forEach((item)=>visibleAttributions.add(item)) : visibleAttributions.add(this.attributions_);
        }
        if (!this.overrideCollapsible_) {
            const collapsible = !layers.some((layer)=>layer.getSource()?.getAttributionsCollapsible() === false);
            this.setCollapsible(collapsible);
        }
        return Array.from(visibleAttributions);
    }
    /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ async updateElement_(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        const attributions = await Promise.all(this.collectSourceAttributions_(frameState).map((attribution)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromise"])(()=>attribution)));
        const visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
            this.element.style.display = visible ? '' : 'none';
            this.renderedVisible_ = visible;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(attributions, this.renderedAttributions_)) {
            return;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeChildren"])(this.ulElement_);
        // append the attributions
        for(let i = 0, ii = attributions.length; i < ii; ++i){
            const element = document.createElement('li');
            element.innerHTML = attributions[i];
            this.ulElement_.appendChild(element);
        }
        this.renderedAttributions_ = attributions;
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
    }
    /**
   * @private
   */ handleToggle_() {
        this.element.classList.toggle(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$css$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CLASS_COLLAPSED"]);
        if (this.collapsed_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["replaceNode"])(this.collapseLabel_, this.label_);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["replaceNode"])(this.label_, this.collapseLabel_);
        }
        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    }
    /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */ getCollapsible() {
        return this.collapsible_;
    }
    /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */ setCollapsible(collapsible) {
        if (this.collapsible_ === collapsible) {
            return;
        }
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (this.userCollapsed_) {
            this.handleToggle_();
        }
    }
    /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */ setCollapsed(collapsed) {
        this.userCollapsed_ = collapsed;
        if (!this.collapsible_ || this.collapsed_ === collapsed) {
            return;
        }
        this.handleToggle_();
    }
    /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */ getCollapsed() {
        return this.collapsed_;
    }
    /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        this.updateElement_(mapEvent.frameState);
    }
}
const __TURBOPACK__default__export__ = Attribution;
}}),
"[project]/node_modules/ol/control/defaults.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/control/defaults
 */ __turbopack_esm__({
    "defaults": (()=>defaults)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Zoom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Zoom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Rotate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Rotate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Attribution$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/Attribution.js [app-ssr] (ecmascript)");
;
;
;
;
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Control.js").default>} */ const controls = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    const zoomControl = options.zoom !== undefined ? options.zoom : true;
    if (zoomControl) {
        controls.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Zoom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.zoomOptions));
    }
    const rotateControl = options.rotate !== undefined ? options.rotate : true;
    if (rotateControl) {
        controls.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Rotate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.rotateOptions));
    }
    const attributionControl = options.attribution !== undefined ? options.attribution : true;
    if (attributionControl) {
        controls.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$Attribution$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.attributionOptions));
    }
    return controls;
}
}}),
"[project]/node_modules/ol/Kinetic.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Kinetic
 */ /**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class Kinetic {
    /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */ constructor(decay, minVelocity, delay){
        /**
     * @private
     * @type {number}
     */ this.decay_ = decay;
        /**
     * @private
     * @type {number}
     */ this.minVelocity_ = minVelocity;
        /**
     * @private
     * @type {number}
     */ this.delay_ = delay;
        /**
     * @private
     * @type {Array<number>}
     */ this.points_ = [];
        /**
     * @private
     * @type {number}
     */ this.angle_ = 0;
        /**
     * @private
     * @type {number}
     */ this.initialVelocity_ = 0;
    }
    /**
   * FIXME empty description for jsdoc
   */ begin() {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   */ update(x, y) {
        this.points_.push(x, y, Date.now());
    }
    /**
   * @return {boolean} Whether we should do kinetic animation.
   */ end() {
        if (this.points_.length < 6) {
            // at least 2 points are required (i.e. there must be at least 6 elements
            // in the array)
            return false;
        }
        const delay = Date.now() - this.delay_;
        const lastIndex = this.points_.length - 3;
        if (this.points_[lastIndex + 2] < delay) {
            // the last tracked point is too old, which means that the user stopped
            // panning before releasing the map
            return false;
        }
        // get the first point which still falls into the delay time
        let firstIndex = lastIndex - 3;
        while(firstIndex > 0 && this.points_[firstIndex + 2] > delay){
            firstIndex -= 3;
        }
        const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
        // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values
        if (duration < 1000 / 60) {
            return false;
        }
        const dx = this.points_[lastIndex] - this.points_[firstIndex];
        const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
    }
    /**
   * @return {number} Total distance travelled (pixels).
   */ getDistance() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */ getAngle() {
        return this.angle_;
    }
}
const __TURBOPACK__default__export__ = Kinetic;
}}),
"[project]/node_modules/ol/MapBrowserEventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapBrowserEventType
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
;
const __TURBOPACK__default__export__ = {
    /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */ SINGLECLICK: 'singleclick',
    /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */ CLICK: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK,
    /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */ DBLCLICK: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DBLCLICK,
    /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */ POINTERDRAG: 'pointerdrag',
    /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */ POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
};
 /***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */ }}),
"[project]/node_modules/ol/TileState.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/TileState
 */ /**
 * @enum {number}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
   * Indicates that tile loading failed
   * @type {number}
   */ ERROR: 3,
    EMPTY: 4
};
}}),
"[project]/node_modules/ol/TileQueue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/TileQueue
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "getTilePriority": (()=>getTilePriority)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/TileState.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$PriorityQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/structs/PriorityQueue.js [app-ssr] (ecmascript)");
;
;
;
/**
 * @typedef {function(import("./Tile.js").default, string, import('./tilecoord.js').TileCoord, number): number} PriorityFunction
 */ /**
 * @typedef {[import('./Tile.js').default, string, import('./tilecoord.js').TileCoord, number]} TileQueueElement
 */ /**
 * @extends PriorityQueue<TileQueueElement>}
 */ class TileQueue extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$PriorityQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */ constructor(tilePriorityFunction, tileChangeCallback){
        super((element)=>tilePriorityFunction.apply(null, element), (element)=>element[0].getKey());
        /** @private */ this.boundHandleTileChange_ = this.handleTileChange.bind(this);
        /**
     * @private
     * @type {function(): ?}
     */ this.tileChangeCallback_ = tileChangeCallback;
        /**
     * @private
     * @type {number}
     */ this.tilesLoading_ = 0;
        /**
     * @private
     * @type {!Object<string,boolean>}
     */ this.tilesLoadingKeys_ = {};
    }
    /**
   * @param {TileQueueElement} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */ enqueue(element) {
        const added = super.enqueue(element);
        if (added) {
            const tile = element[0];
            tile.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.boundHandleTileChange_);
        }
        return added;
    }
    /**
   * @return {number} Number of tiles loading.
   */ getTilesLoading() {
        return this.tilesLoading_;
    }
    /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */ handleTileChange(event) {
        const tile = event.target;
        const state = tile.getState();
        if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADED || state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR || state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].EMPTY) {
            if (state !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ERROR) {
                tile.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.boundHandleTileChange_);
            }
            const tileKey = tile.getKey();
            if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
            }
            this.tileChangeCallback_();
        }
    }
    /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */ loadMoreTiles(maxTotalLoading, maxNewLoads) {
        let newLoads = 0;
        while(this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0){
            const tile = this.dequeue()[0];
            const tileKey = tile.getKey();
            const state = tile.getState();
            if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileState$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
            }
        }
    }
}
const __TURBOPACK__default__export__ = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$PriorityQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DROP"];
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$PriorityQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DROP"];
    }
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    const center = frameState.viewState.center;
    const deltaX = tileCenter[0] - center[0];
    const deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
}}),
"[project]/node_modules/ol/MapProperty.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapProperty
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    LAYERGROUP: 'layergroup',
    SIZE: 'size',
    TARGET: 'target',
    VIEW: 'view'
};
}}),
"[project]/node_modules/ol/MapEvent.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapEvent
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-ssr] (ecmascript)");
;
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */ class MapEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */ constructor(type, map, frameState){
        super(type);
        /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */ this.map = map;
        /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */ this.frameState = frameState !== undefined ? frameState : null;
    }
}
const __TURBOPACK__default__export__ = MapEvent;
}}),
"[project]/node_modules/ol/MapBrowserEvent.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapBrowserEvent
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapEvent.js [app-ssr] (ecmascript)");
;
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */ class MapBrowserEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */ constructor(type, map, originalEvent, dragging, frameState, activePointers){
        super(type, map, frameState);
        /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */ this.originalEvent = originalEvent;
        /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     * @private
     */ this.pixel_ = null;
        /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     * @private
     */ this.coordinate_ = null;
        /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */ this.dragging = dragging !== undefined ? dragging : false;
        /**
     * @type {Array<PointerEvent>|undefined}
     */ this.activePointers = activePointers;
    }
    /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */ get pixel() {
        if (!this.pixel_) {
            this.pixel_ = this.map.getEventPixel(this.originalEvent);
        }
        return this.pixel_;
    }
    set pixel(pixel) {
        this.pixel_ = pixel;
    }
    /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */ get coordinate() {
        if (!this.coordinate_) {
            this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        }
        return this.coordinate_;
    }
    set coordinate(coordinate) {
        this.coordinate_ = coordinate;
    }
    /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */ preventDefault() {
        super.preventDefault();
        if ('preventDefault' in this.originalEvent) {
            /** @type {UIEvent} */ this.originalEvent.preventDefault();
        }
    }
    /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */ stopPropagation() {
        super.stopPropagation();
        if ('stopPropagation' in this.originalEvent) {
            /** @type {UIEvent} */ this.originalEvent.stopPropagation();
        }
    }
}
const __TURBOPACK__default__export__ = MapBrowserEvent;
}}),
"[project]/node_modules/ol/pointer/EventType.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/pointer/EventType
 */ /**
 * Constants for event names.
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
};
}}),
"[project]/node_modules/ol/MapBrowserEventHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/MapBrowserEventHandler
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$pointer$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/pointer/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Target.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
class MapBrowserEventHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Target$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */ constructor(map, moveTolerance){
        super(map);
        /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */ this.map_ = map;
        /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */ this.clickTimeoutId_;
        /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */ this.emulateClicks_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.dragging_ = false;
        /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */ this.dragListenerKeys_ = [];
        /**
     * @type {number}
     * @private
     */ this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
        /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */ this.down_ = null;
        const element = this.map_.getViewport();
        /**
     * @type {Array<PointerEvent>}
     * @private
     */ this.activePointers_ = [];
        /**
     * @type {!Object<number, Event>}
     * @private
     */ this.trackedTouches_ = {};
        /**
     * @private
     */ this.element_ = element;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.pointerdownListenerKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(element, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$pointer$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERDOWN, this.handlePointerDown_, this);
        /**
     * @type {PointerEvent}
     * @private
     */ this.originalPointerMoveEvent_;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.relayedListenerKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(element, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$pointer$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERMOVE, this.relayMoveEvent_, this);
        /**
     * @private
     */ this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
        this.element_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TOUCHMOVE, this.boundHandleTouchMove_, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PASSIVE_EVENT_LISTENERS"] ? {
            passive: false
        } : false);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ emulateClick_(pointerEvent) {
        let newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== undefined) {
            // double-click
            clearTimeout(this.clickTimeoutId_);
            this.clickTimeoutId_ = undefined;
            newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DBLCLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        } else {
            // click
            this.clickTimeoutId_ = setTimeout(()=>{
                this.clickTimeoutId_ = undefined;
                const newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SINGLECLICK, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
            }, 250);
        }
    }
    /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ updateActivePointers_(pointerEvent) {
        const event = pointerEvent;
        const id = event.pointerId;
        if (event.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERUP || event.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERCANCEL) {
            delete this.trackedTouches_[id];
            for(const pointerId in this.trackedTouches_){
                if (this.trackedTouches_[pointerId].target !== event.target) {
                    // Some platforms assign a new pointerId when the target changes.
                    // If this happens, delete one tracked pointer. If there is more
                    // than one tracked pointer for the old target, it will be cleared
                    // by subsequent POINTERUP events from other pointers.
                    delete this.trackedTouches_[pointerId];
                    break;
                }
            }
        } else if (event.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERDOWN || event.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERMOVE) {
            this.trackedTouches_[id] = event;
        }
        this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerUp_(pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        const newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().
        if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
            this.emulateClick_(this.down_);
        }
        if (this.activePointers_.length === 0) {
            this.dragListenerKeys_.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
            this.dragListenerKeys_.length = 0;
            this.dragging_ = false;
            this.down_ = null;
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */ isMouseActionButton_(pointerEvent) {
        return pointerEvent.button === 0;
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerDown_(pointerEvent) {
        this.emulateClicks_ = this.activePointers_.length === 0;
        this.updateActivePointers_(pointerEvent);
        const newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
        Object.defineProperty(this.down_, 'target', {
            writable: false,
            value: pointerEvent.target
        });
        if (this.dragListenerKeys_.length === 0) {
            const doc = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(doc, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERMOVE, this.handlePointerMove_, this), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(doc, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERUP, this.handlePointerUp_, this), /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(this.element_, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERCANCEL, this.handlePointerUp_, this));
            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
                this.dragListenerKeys_.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(this.element_.getRootNode(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERUP, this.handlePointerUp_, this));
            }
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerMove_(pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
            this.updateActivePointers_(pointerEvent);
            this.dragging_ = true;
            const newEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
            this.dispatchEvent(newEvent);
        }
    }
    /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ relayMoveEvent_(pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERMOVE, this.map_, pointerEvent, dragging));
    }
    /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */ handleTouchMove_(event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events,
        // when elm-pep is used as pointer events polyfill.
        const originalEvent = this.originalPointerMoveEvent_;
        if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
            event.preventDefault();
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */ isMoving_(pointerEvent) {
        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
   * Clean up.
   * @override
   */ disposeInternal() {
        if (this.relayedListenerKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.relayedListenerKey_);
            this.relayedListenerKey_ = null;
        }
        this.element_.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TOUCHMOVE, this.boundHandleTouchMove_);
        if (this.pointerdownListenerKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.pointerdownListenerKey_);
            this.pointerdownListenerKey_ = null;
        }
        this.dragListenerKeys_.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
        this.dragListenerKeys_.length = 0;
        this.element_ = null;
        super.disposeInternal();
    }
}
const __TURBOPACK__default__export__ = MapBrowserEventHandler;
}}),
"[project]/node_modules/ol/Map.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
/**
 * @module ol/Map
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Layer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Group.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$defaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/control/defaults.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$defaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/defaults.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/TileQueue.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/View.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$pointer$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/pointer/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ViewHint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/EventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Composite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/renderer/Composite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventHandler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/ObjectEventType.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$console$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/console.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/asserts.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {Object<string, import("rbush").default<import('./render/canvas/Executor.js').DeclutterEntry>>|null} declutter
 * Declutter trees by declutter group.
 * When null, no decluttering is needed because no layers have decluttering enabled.
 * @property {null|import("./extent.js").Extent} extent Extent (in view projection coordinates).
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */ /**
 * @typedef {function(Map, FrameState): any} PostRenderFunction
 */ /**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */ /**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */ /**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */ /**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
 *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
 *  `tabindex` atribute must be set on the custom element's host element.
 * **Note:** CSS `transform` support for the target element is limited to `scale`.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */ /**
 * @param {import("./layer/Base.js").default} layer Layer.
 */ function removeLayerMapProperty(layer) {
    if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        layer.setMapInternal(null);
        return;
    }
    if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        layer.getLayers().forEach(removeLayerMapProperty);
    }
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */ function setLayerMapProperty(layer, map) {
    if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Layer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        layer.setMapInternal(map);
        return;
    }
    if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
        const layers = layer.getLayers().getArray();
        for(let i = 0, ii = layers.length; i < ii; ++i){
            setLayerMapProperty(layers[i], map);
        }
    }
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */ class Map extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {MapOptions} [options] Map options.
   */ constructor(options){
        super();
        options = options || {};
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {MapEventHandler<void>}
     */ this.un;
        const optionsInternal = createOptionsInternal(options);
        /**
     * @private
     * @type {boolean}
     */ this.renderComplete_ = false;
        /**
     * @private
     * @type {boolean}
     */ this.loaded_ = true;
        /** @private */ this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
        /**
     * @type {number}
     * @private
     */ this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEVICE_PIXEL_RATIO"];
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.postRenderTimeoutHandle_;
        /**
     * @private
     * @type {number|undefined}
     */ this.animationDelayKey_;
        /**
     * @private
     */ this.animationDelay_ = this.animationDelay_.bind(this);
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.coordinateToPixelTransform_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.pixelToCoordinateTransform_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
        /**
     * @private
     * @type {number}
     */ this.frameIndex_ = 0;
        /**
     * @private
     * @type {?FrameState}
     */ this.frameState_ = null;
        /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */ this.previousExtent_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewPropertyListenerKey_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewChangeListenerKey_ = null;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.layerGroupPropertyListenerKeys_ = null;
        /**
     * @private
     * @type {!HTMLElement}
     */ this.viewport_ = document.createElement('div');
        this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
        this.viewport_.style.position = 'relative';
        this.viewport_.style.overflow = 'hidden';
        this.viewport_.style.width = '100%';
        this.viewport_.style.height = '100%';
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainer_ = document.createElement('div');
        this.overlayContainer_.style.position = 'absolute';
        this.overlayContainer_.style.zIndex = '0';
        this.overlayContainer_.style.width = '100%';
        this.overlayContainer_.style.height = '100%';
        this.overlayContainer_.style.pointerEvents = 'none';
        this.overlayContainer_.className = 'ol-overlaycontainer';
        this.viewport_.appendChild(this.overlayContainer_);
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainerStopEvent_ = document.createElement('div');
        this.overlayContainerStopEvent_.style.position = 'absolute';
        this.overlayContainerStopEvent_.style.zIndex = '0';
        this.overlayContainerStopEvent_.style.width = '100%';
        this.overlayContainerStopEvent_.style.height = '100%';
        this.overlayContainerStopEvent_.style.pointerEvents = 'none';
        this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
        this.viewport_.appendChild(this.overlayContainerStopEvent_);
        /**
     * @private
     * @type {MapBrowserEventHandler}
     */ this.mapBrowserEventHandler_ = null;
        /**
     * @private
     * @type {number}
     */ this.moveTolerance_ = options.moveTolerance;
        /**
     * @private
     * @type {HTMLElement|Document}
     */ this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.targetChangeHandlerKeys_ = null;
        /**
     * @private
     * @type {HTMLElement|null}
     */ this.targetElement_ = null;
        /**
     * @private
     * @type {ResizeObserver}
     */ this.resizeObserver_ = new ResizeObserver(()=>this.updateSize());
        /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */ this.controls = optionsInternal.controls || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$control$2f$defaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaults"])();
        /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */ this.interactions = optionsInternal.interactions || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$defaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaults"])({
            onFocusOnly: true
        });
        /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */ this.overlays_ = optionsInternal.overlays;
        /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */ this.overlayIdIndex_ = {};
        /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */ this.renderer_ = null;
        /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */ this.postRenderFunctions_ = [];
        /**
     * @private
     * @type {TileQueue}
     */ this.tileQueue_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LAYERGROUP, this.handleLayerGroupChanged_);
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIEW, this.handleViewChanged_);
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SIZE, this.handleSizeChanged_);
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TARGET, this.handleTargetChanged_);
        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        this.setProperties(optionsInternal.values);
        const map = this;
        if (options.view && !(options.view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])) {
            options.view.then(function(viewOptions) {
                map.setView(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](viewOptions));
            });
        }
        this.controls.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */ (event)=>{
            event.element.setMap(this);
        });
        this.controls.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(null);
        });
        this.interactions.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(this);
        });
        this.interactions.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(null);
        });
        this.overlays_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (event)=>{
            this.addOverlayInternal_(event.element);
        });
        this.overlays_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (event)=>{
            const id = event.element.getId();
            if (id !== undefined) {
                delete this.overlayIdIndex_[id.toString()];
            }
            event.element.setMap(null);
        });
        this.controls.forEach(/**
       * @param {import("./control/Control.js").default} control Control.
       */ (control)=>{
            control.setMap(this);
        });
        this.interactions.forEach(/**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */ (interaction)=>{
            interaction.setMap(this);
        });
        this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */ addControl(control) {
        this.getControls().push(control);
    }
    /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */ addInteraction(interaction) {
        this.getInteractions().push(interaction);
    }
    /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */ addLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        layers.push(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */ handleLayerAdd_(event) {
        setLayerMapProperty(event.layer, this);
    }
    /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */ addOverlay(overlay) {
        this.getOverlays().push(overlay);
    }
    /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */ addOverlayInternal_(overlay) {
        const id = overlay.getId();
        if (id !== undefined) {
            this.overlayIdIndex_[id.toString()] = overlay;
        }
        overlay.setMap(this);
    }
    /**
   *
   * Clean up.
   * @override
   */ disposeInternal() {
        this.controls.clear();
        this.interactions.clear();
        this.overlays_.clear();
        this.resizeObserver_.disconnect();
        this.setTarget(null);
        super.disposeInternal();
    }
    /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */ forEachFeatureAtPixel(pixel, callback, options) {
        if (!this.frameState_ || !this.renderer_) {
            return;
        }
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRUE"];
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    }
    /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */ getFeaturesAtPixel(pixel, options) {
        const features = [];
        this.forEachFeatureAtPixel(pixel, function(feature) {
            features.push(feature);
        }, options);
        return features;
    }
    /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */ getAllLayers() {
        const layers = [];
        function addLayersFrom(layerGroup) {
            layerGroup.forEach(function(layer) {
                if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
                    addLayersFrom(layer.getLayers());
                } else {
                    layers.push(layer);
                }
            });
        }
        addLayersFrom(this.getLayers());
        return layers;
    }
    /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */ hasFeatureAtPixel(pixel, options) {
        if (!this.frameState_ || !this.renderer_) {
            return false;
        }
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRUE"];
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    }
    /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */ getEventCoordinate(event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
    }
    /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */ getEventCoordinateInternal(event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }
    /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */ getEventPixel(event) {
        const viewport = this.viewport_;
        const viewportPosition = viewport.getBoundingClientRect();
        const viewportSize = this.getSize();
        const scaleX = viewportPosition.width / viewportSize[0];
        const scaleY = viewportPosition.height / viewportSize[1];
        const eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
        'changedTouches' in event ? /** @type {TouchEvent} */ event.changedTouches[0] : event;
        return [
            (eventPosition.clientX - viewportPosition.left) / scaleX,
            (eventPosition.clientY - viewportPosition.top) / scaleY
        ];
    }
    /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */ getTarget() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TARGET);
    }
    /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */ getTargetElement() {
        return this.targetElement_;
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */ getCoordinateFromPixel(pixel) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */ getCoordinateFromPixelInternal(pixel) {
        const frameState = this.frameState_;
        if (!frameState) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.pixelToCoordinateTransform, pixel.slice());
    }
    /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */ getControls() {
        return this.controls;
    }
    /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */ getOverlays() {
        return this.overlays_;
    }
    /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */ getOverlayById(id) {
        const overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
    }
    /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */ getInteractions() {
        return this.interactions;
    }
    /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */ getLayerGroup() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LAYERGROUP);
    }
    /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */ setLayers(layers) {
        const group = this.getLayerGroup();
        if (layers instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
            group.setLayers(layers);
            return;
        }
        const collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
    }
    /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */ getLayers() {
        const layers = this.getLayerGroup().getLayers();
        return layers;
    }
    /**
   * @return {boolean} Layers have sources that are still loading.
   */ getLoadingOrNotReady() {
        const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const state = layerStatesArray[i];
            if (!state.visible) {
                continue;
            }
            const renderer = state.layer.getRenderer();
            if (renderer && !renderer.ready) {
                return true;
            }
            const source = state.layer.getSource();
            if (source && source.loading) {
                return true;
            }
        }
        return false;
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */ getPixelFromCoordinate(coordinate) {
        const viewCoordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */ getPixelFromCoordinateInternal(coordinate) {
        const frameState = this.frameState_;
        if (!frameState) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["apply"])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
    /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ getSize() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SIZE);
    }
    /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */ getView() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIEW);
    }
    /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */ getViewport() {
        return this.viewport_;
    }
    /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */ getOverlayContainer() {
        return this.overlayContainer_;
    }
    /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */ getOverlayContainerStopEvent() {
        return this.overlayContainerStopEvent_;
    }
    /**
   * @return {!Document} The document where the map is displayed.
   */ getOwnerDocument() {
        const targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
    }
    /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */ getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$TileQueue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTilePriority"])(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    }
    /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */ handleBrowserEvent(browserEvent, type) {
        type = type || browserEvent.type;
        const mapBrowserEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
    }
    /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */ handleMapBrowserEvent(mapBrowserEvent) {
        if (!this.frameState_) {
            // With no view defined, we cannot translate pixels into geographical
            // coordinates so interactions cannot be used.
            return;
        }
        const originalEvent = mapBrowserEvent.originalEvent;
        const eventType = originalEvent.type;
        if (eventType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$pointer$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POINTERDOWN || eventType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].WHEEL || eventType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].KEYDOWN) {
            const doc = this.getOwnerDocument();
            const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
            const target = originalEvent.target;
            const currentDoc = rootNode instanceof ShadowRoot ? rootNode.host === target ? rootNode.host.ownerDocument : rootNode : rootNode === doc ? doc.documentElement : rootNode;
            if (// Abort if the target is a child of the container for elements whose events are not meant
            // to be handled by map interactions.
            this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
            // It's possible for the target to no longer be in the page if it has been removed in an
            // event listener, this might happen in a Control that recreates it's content based on
            // user interaction either manually or via a render in something like https://reactjs.org/
            !currentDoc.contains(target)) {
                return;
            }
        }
        mapBrowserEvent.frameState = this.frameState_;
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
            const interactionsArray = this.getInteractions().getArray().slice();
            for(let i = interactionsArray.length - 1; i >= 0; i--){
                const interaction = interactionsArray[i];
                if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
                    continue;
                }
                const cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) {
                    break;
                }
            }
        }
    }
    /**
   * @protected
   */ handlePostRender() {
        const frameState = this.frameState_;
        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        const tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
            let maxTotalLoading = this.maxTilesLoading_;
            let maxNewLoads = maxTotalLoading;
            if (frameState) {
                const hints = frameState.viewHints;
                if (hints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING] || hints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING]) {
                    const lowOnFrameBudget = Date.now() - frameState.time > 8;
                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                    maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
            }
            if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize(); // FIXME only call if view has changed
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
            }
        }
        if (frameState && this.renderer_ && !frameState.animate) {
            if (this.renderComplete_) {
                if (this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RENDERCOMPLETE)) {
                    this.renderer_.dispatchRenderEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RENDERCOMPLETE, frameState);
                }
                if (this.loaded_ === false) {
                    this.loaded_ = true;
                    this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADEND, this, frameState));
                }
            } else if (this.loaded_ === true) {
                this.loaded_ = false;
                this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADSTART, this, frameState));
            }
        }
        const postRenderFunctions = this.postRenderFunctions_;
        if (frameState) {
            for(let i = 0, ii = postRenderFunctions.length; i < ii; ++i){
                postRenderFunctions[i](this, frameState);
            }
        }
        postRenderFunctions.length = 0;
    }
    /**
   * @private
   */ handleSizeChanged_() {
        if (this.getView() && !this.getView().getAnimating()) {
            this.getView().resolveConstraints(0);
        }
        this.render();
    }
    /**
   * @private
   */ handleTargetChanged_() {
        if (this.mapBrowserEventHandler_) {
            for(let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i){
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.targetChangeHandlerKeys_[i]);
            }
            this.targetChangeHandlerKeys_ = null;
            this.viewport_.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CONTEXTMENU, this.boundHandleBrowserEvent_);
            this.viewport_.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].WHEEL, this.boundHandleBrowserEvent_);
            this.mapBrowserEventHandler_.dispose();
            this.mapBrowserEventHandler_ = null;
            this.viewport_.remove();
        }
        if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const rootNode = this.targetElement_.getRootNode();
            if (rootNode instanceof ShadowRoot) {
                this.resizeObserver_.unobserve(rootNode.host);
            }
            this.setSize(undefined);
        }
        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.
        const target = this.getTarget();
        const targetElement = typeof target === 'string' ? document.getElementById(target) : target;
        this.targetElement_ = targetElement;
        if (!targetElement) {
            if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = undefined;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
            }
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = undefined;
            }
        } else {
            targetElement.appendChild(this.viewport_);
            if (!this.renderer_) {
                this.renderer_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$renderer$2f$Composite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this);
            }
            this.mapBrowserEventHandler_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this, this.moveTolerance_);
            for(const key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]){
                this.mapBrowserEventHandler_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"][key], this.handleMapBrowserEvent.bind(this));
            }
            this.viewport_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CONTEXTMENU, this.boundHandleBrowserEvent_, false);
            this.viewport_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].WHEEL, this.boundHandleBrowserEvent_, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PASSIVE_EVENT_LISTENERS"] ? {
                passive: false
            } : false);
            let keyboardEventTarget;
            if (!this.keyboardEventTarget_) {
                // check if map target is in shadowDOM, if yes use host element as target
                const targetRoot = targetElement.getRootNode();
                const targetCandidate = targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;
                keyboardEventTarget = targetCandidate;
            } else {
                keyboardEventTarget = this.keyboardEventTarget_;
            }
            this.targetChangeHandlerKeys_ = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(keyboardEventTarget, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].KEYDOWN, this.handleBrowserEvent, this),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(keyboardEventTarget, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].KEYPRESS, this.handleBrowserEvent, this)
            ];
            const rootNode = targetElement.getRootNode();
            if (rootNode instanceof ShadowRoot) {
                this.resizeObserver_.observe(rootNode.host);
            }
            this.resizeObserver_.observe(targetElement);
        }
        this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
    }
    /**
   * @private
   */ handleTileChange_() {
        this.render();
    }
    /**
   * @private
   */ handleViewPropertyChanged_() {
        this.render();
    }
    /**
   * @private
   */ handleViewChanged_() {
        if (this.viewPropertyListenerKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.viewPropertyListenerKey_);
            this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"])(this.viewChangeListenerKey_);
            this.viewChangeListenerKey_ = null;
        }
        const view = this.getView();
        if (view) {
            this.updateViewportSize_(this.getSize());
            this.viewPropertyListenerKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(view, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
            this.viewChangeListenerKey_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(view, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.handleViewPropertyChanged_, this);
            view.resolveConstraints(0);
        }
        this.render();
    }
    /**
   * @private
   */ handleLayerGroupChanged_() {
        if (this.layerGroupPropertyListenerKeys_) {
            this.layerGroupPropertyListenerKeys_.forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unlistenByKey"]);
            this.layerGroupPropertyListenerKeys_ = null;
        }
        const layerGroup = this.getLayerGroup();
        if (layerGroup) {
            this.handleLayerAdd_(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GroupEvent"]('addlayer', layerGroup));
            this.layerGroupPropertyListenerKeys_ = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layerGroup, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ObjectEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PROPERTYCHANGE, this.render, this),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layerGroup, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.render, this),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layerGroup, 'addlayer', this.handleLayerAdd_, this),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["listen"])(layerGroup, 'removelayer', this.handleLayerRemove_, this)
            ];
        }
        this.render();
    }
    /**
   * @return {boolean} Is rendered.
   */ isRendered() {
        return !!this.frameState_;
    }
    /**
   * @private
   */ animationDelay_() {
        this.animationDelayKey_ = undefined;
        this.renderFrame_(Date.now());
    }
    /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */ renderSync() {
        if (this.animationDelayKey_) {
            cancelAnimationFrame(this.animationDelayKey_);
        }
        this.animationDelay_();
    }
    /**
   * Redraws all text after new fonts have loaded
   */ redrawText() {
        const layerStates = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStates.length; i < ii; ++i){
            const layer = layerStates[i].layer;
            if (layer.hasRenderer()) {
                layer.getRenderer().handleFontsChanged();
            }
        }
    }
    /**
   * Request a map rendering (at the next animation frame).
   * @api
   */ render() {
        if (this.renderer_ && this.animationDelayKey_ === undefined) {
            this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
        }
    }
    /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */ removeControl(control) {
        return this.getControls().remove(control);
    }
    /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */ removeInteraction(interaction) {
        return this.getInteractions().remove(interaction);
    }
    /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */ removeLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */ handleLayerRemove_(event) {
        removeLayerMapProperty(event.layer);
    }
    /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */ removeOverlay(overlay) {
        return this.getOverlays().remove(overlay);
    }
    /**
   * @param {number} time Time.
   * @private
   */ renderFrame_(time) {
        const size = this.getSize();
        const view = this.getView();
        const previousFrameState = this.frameState_;
        /** @type {?FrameState} */ let frameState = null;
        if (size !== undefined && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasArea"])(size) && view && view.isDef()) {
            const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
            const viewState = view.getState();
            frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutter: null,
                extent: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getForViewAndSize"])(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: size,
                tileQueue: this.tileQueue_,
                time: time,
                usedTiles: {},
                viewState: viewState,
                viewHints: viewHints,
                wantedTiles: {},
                mapId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUid"])(this),
                renderTargets: {}
            };
            if (viewState.nextCenter && viewState.nextResolution) {
                const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
                frameState.nextExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getForViewAndSize"])(viewState.nextCenter, viewState.nextResolution, rotation, size);
            }
        }
        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);
        if (frameState) {
            if (frameState.animate) {
                this.render();
            }
            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
            if (previousFrameState) {
                const moveStart = !this.previousExtent_ || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEmpty"])(this.previousExtent_) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(frameState.extent, this.previousExtent_);
                if (moveStart) {
                    this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOVESTART, this, previousFrameState));
                    this.previousExtent_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createOrUpdateEmpty"])(this.previousExtent_);
                }
            }
            const idle = this.previousExtent_ && !frameState.viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ANIMATING] && !frameState.viewHints[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$ViewHint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].INTERACTING] && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(frameState.extent, this.previousExtent_);
            if (idle) {
                this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOVEEND, this, frameState));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(frameState.extent, this.previousExtent_);
            }
        }
        this.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].POSTRENDER, this, frameState));
        this.renderComplete_ = (this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADSTART) || this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapEventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LOADEND) || this.hasListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$EventType$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();
        if (!this.postRenderTimeoutHandle_) {
            this.postRenderTimeoutHandle_ = setTimeout(()=>{
                this.postRenderTimeoutHandle_ = undefined;
                this.handlePostRender();
            }, 0);
        }
    }
    /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */ setLayerGroup(layerGroup) {
        const oldLayerGroup = this.getLayerGroup();
        if (oldLayerGroup) {
            this.handleLayerRemove_(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GroupEvent"]('removelayer', oldLayerGroup));
        }
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LAYERGROUP, layerGroup);
    }
    /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ setSize(size) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SIZE, size);
    }
    /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */ setTarget(target) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TARGET, target);
    }
    /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */ setView(view) {
        if (!view || view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
            this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIEW, view);
            return;
        }
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIEW, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]());
        const map = this;
        view.then(function(viewOptions) {
            map.setView(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](viewOptions));
        });
    }
    /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */ updateSize() {
        const targetElement = this.getTargetElement();
        let size = undefined;
        if (targetElement) {
            const computedStyle = getComputedStyle(targetElement);
            const width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
            const height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);
            if (!isNaN(width) && !isNaN(height)) {
                size = [
                    Math.max(0, width),
                    Math.max(0, height)
                ];
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasArea"])(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$console$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("No map visible because the map container's width or height are 0.");
                }
            }
        }
        const oldSize = this.getSize();
        if (size && (!oldSize || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equals"])(size, oldSize))) {
            this.setSize(size);
            this.updateViewportSize_(size);
        }
    }
    /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */ updateViewportSize_(size) {
        const view = this.getView();
        if (view) {
            view.setViewportSize(size);
        }
    }
}
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */ function createOptionsInternal(options) {
    /**
   * @type {HTMLElement|Document}
   */ let keyboardEventTarget = null;
    if (options.keyboardEventTarget !== undefined) {
        keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    }
    /**
   * @type {Object<string, *>}
   */ const values = {};
    const layerGroup = options.layers && typeof /** @type {?} */ options.layers.getLayers === 'function' ? options.layers : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Group$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]({
        layers: options.layers
    });
    values[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LAYERGROUP] = layerGroup;
    values[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TARGET] = options.target;
    values[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIEW] = options.view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] ? options.view : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$View$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    /** @type {Collection<import("./control/Control.js").default>} */ let controls;
    if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) {
            controls = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.controls.slice());
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof /** @type {?} */ options.controls.getArray === 'function', 'Expected `controls` to be an array or an `ol/Collection.js`');
            controls = options.controls;
        }
    }
    /** @type {Collection<import("./interaction/Interaction").default>} */ let interactions;
    if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) {
            interactions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.interactions.slice());
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof /** @type {?} */ options.interactions.getArray === 'function', 'Expected `interactions` to be an array or an `ol/Collection.js`');
            interactions = options.interactions;
        }
    }
    /** @type {Collection<import("./Overlay.js").default>} */ let overlays;
    if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) {
            overlays = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](options.overlays.slice());
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$asserts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(typeof /** @type {?} */ options.overlays.getArray === 'function', 'Expected `overlays` to be an array or an `ol/Collection.js`');
            overlays = options.overlays;
        }
    } else {
        overlays = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    }
    return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values
    };
}
const __TURBOPACK__default__export__ = Map;
}}),

};

//# sourceMappingURL=node_modules_ol_4820dc._.js.map