(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_ol_interaction_f661b8._.js", {

"[project]/node_modules/ol/interaction/Property.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Property
 */ /**
 * @enum {string}
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    ACTIVE: 'active'
};
}}),
"[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Interaction
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "pan": (()=>pan),
    "zoomByDelta": (()=>zoomByDelta)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-client] (ecmascript)");
;
;
;
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */ /**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */ class Interaction extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {InteractionOptions} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {InteractionOnSignature<void>}
     */ this.un;
        if (options && options.handleEvent) {
            this.handleEvent = options.handleEvent;
        }
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        this.setActive(true);
    }
    /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */ getActive() {
        return this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ACTIVE);
    }
    /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        return true;
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        this.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ACTIVE, active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        this.map_ = map;
    }
}
function pan(view, delta, duration) {
    const currentCenter = view.getCenterInternal();
    if (currentCenter) {
        const center = [
            currentCenter[0] + delta[0],
            currentCenter[1] + delta[1]
        ];
        view.animateInternal({
            duration: duration !== undefined ? duration : 250,
            easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["linear"],
            center: view.getConstrainedCenter(center)
        });
    }
}
function zoomByDelta(view, delta, anchor, duration) {
    const currentZoom = view.getZoom();
    if (currentZoom === undefined) {
        return;
    }
    const newZoom = view.getConstrainedZoom(currentZoom + delta);
    const newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) {
        view.cancelAnimations();
    }
    view.animate({
        resolution: newResolution,
        anchor: anchor,
        duration: duration !== undefined ? duration : 250,
        easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["easeOut"]
    });
}
const __TURBOPACK__default__export__ = Interaction;
}}),
"[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Pointer
 */ __turbopack_esm__({
    "centroid": (()=>centroid),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
;
;
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */ /**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */ class PointerInteraction extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        if (options.handleDownEvent) {
            this.handleDownEvent = options.handleDownEvent;
        }
        if (options.handleDragEvent) {
            this.handleDragEvent = options.handleDragEvent;
        }
        if (options.handleMoveEvent) {
            this.handleMoveEvent = options.handleMoveEvent;
        }
        if (options.handleUpEvent) {
            this.handleUpEvent = options.handleUpEvent;
        }
        if (options.stopDown) {
            this.stopDown = options.stopDown;
        }
        /**
     * @type {boolean}
     * @protected
     */ this.handlingDownUpSequence = false;
        /**
     * @type {Array<PointerEvent>}
     * @protected
     */ this.targetPointers = [];
    }
    /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */ getPointerCount() {
        return this.targetPointers.length;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleDownEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleDragEvent(mapBrowserEvent) {}
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
            return true;
        }
        let stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            } else if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERUP) {
                const handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
            }
        } else {
            if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDOWN) {
                const handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            } else if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERMOVE) {
                this.handleMoveEvent(mapBrowserEvent);
            }
        }
        return !stopEvent;
    }
    /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleMoveEvent(mapBrowserEvent) {}
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleUpEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */ stopDown(handled) {
        return handled;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */ updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) {
            this.targetPointers = mapBrowserEvent.activePointers;
        }
    }
}
function centroid(pointerEvents) {
    const length = pointerEvents.length;
    let clientX = 0;
    let clientY = 0;
    for(let i = 0; i < length; i++){
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return {
        clientX: clientX / length,
        clientY: clientY / length
    };
}
const __TURBOPACK__default__export__ = PointerInteraction;
}}),
"[project]/node_modules/ol/interaction/DragRotate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/DragRotate
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/rotationconstraint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */ class DragRotate extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super({
            stopDown: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FALSE"]
        });
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["altShiftKeysOnly"];
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */ handleDragEvent(mapBrowserEvent) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mouseOnly"])(mapBrowserEvent)) {
            return;
        }
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disable"]) {
            return;
        }
        const size = map.getSize();
        const offset = mapBrowserEvent.pixel;
        const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
        if (this.lastAngle_ !== undefined) {
            const delta = theta - this.lastAngle_;
            view.adjustRotationInternal(-delta);
        }
        this.lastAngle_ = theta;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(mapBrowserEvent) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mouseOnly"])(mapBrowserEvent)) {
            return true;
        }
        const map = mapBrowserEvent.map;
        const view = map.getView();
        view.endInteraction(this.duration_);
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(mapBrowserEvent) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mouseOnly"])(mapBrowserEvent)) {
            return false;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mouseActionButton"])(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            return true;
        }
        return false;
    }
}
const __TURBOPACK__default__export__ = DragRotate;
}}),
"[project]/node_modules/ol/interaction/DoubleClickZoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/DoubleClickZoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
;
;
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */ /**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */ class DoubleClickZoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DBLCLICK) {
            const browserEvent = mapBrowserEvent.originalEvent;
            const map = mapBrowserEvent.map;
            const anchor = mapBrowserEvent.coordinate;
            const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
            const view = map.getView();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zoomByDelta"])(view, delta, anchor, this.duration_);
            browserEvent.preventDefault();
            stopEvent = true;
        }
        return !stopEvent;
    }
}
const __TURBOPACK__default__export__ = DoubleClickZoom;
}}),
"[project]/node_modules/ol/interaction/DragPan.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/DragPan
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */ /**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */ class DragPan extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super({
            stopDown: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FALSE"]
        });
        options = options ? options : {};
        /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */ this.kinetic_ = options.kinetic;
        /**
     * @type {import("../pixel.js").Pixel}
     */ this.lastCentroid = null;
        /**
     * @type {number}
     * @private
     */ this.lastPointersCount_;
        /**
     * @type {boolean}
     * @private
     */ this.panning_ = false;
        const condition = options.condition ? options.condition : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["all"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noModifierKeys"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["primaryAction"]);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["all"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusWithTabindex"], condition) : condition;
        /**
     * @private
     * @type {boolean}
     */ this.noKinetic_ = false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */ handleDragEvent(mapBrowserEvent) {
        const map = mapBrowserEvent.map;
        if (!this.panning_) {
            this.panning_ = true;
            map.getView().beginInteraction();
        }
        const targetPointers = this.targetPointers;
        const centroid = map.getEventPixel((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(targetPointers));
        if (targetPointers.length == this.lastPointersCount_) {
            if (this.kinetic_) {
                this.kinetic_.update(centroid[0], centroid[1]);
            }
            if (this.lastCentroid) {
                const delta = [
                    this.lastCentroid[0] - centroid[0],
                    centroid[1] - this.lastCentroid[1]
                ];
                const map = mapBrowserEvent.map;
                const view = map.getView();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(delta, view.getResolution());
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotate"])(delta, view.getRotation());
                view.adjustCenterInternal(delta);
            }
        } else if (this.kinetic_) {
            // reset so we don't overestimate the kinetic energy after
            // after one finger down, tiny drag, second finger down
            this.kinetic_.begin();
        }
        this.lastCentroid = centroid;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(mapBrowserEvent) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                const distance = this.kinetic_.getDistance();
                const angle = this.kinetic_.getAngle();
                const center = view.getCenterInternal();
                const centerpx = map.getPixelFromCoordinateInternal(center);
                const dest = map.getCoordinateFromPixelInternal([
                    centerpx[0] - distance * Math.cos(angle),
                    centerpx[1] - distance * Math.sin(angle)
                ]);
                view.animateInternal({
                    center: view.getConstrainedCenter(dest),
                    duration: 500,
                    easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["easeOut"]
                });
            }
            if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
            }
            return false;
        }
        if (this.kinetic_) {
            // reset so we don't overestimate the kinetic energy after
            // after one finger up, tiny drag, second finger up
            this.kinetic_.begin();
        }
        this.lastCentroid = null;
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            this.lastCentroid = null;
            // stop any current animation
            if (view.getAnimating()) {
                view.cancelAnimations();
            }
            if (this.kinetic_) {
                this.kinetic_.begin();
            }
            // No kinetic as soon as more than one pointer on the screen is
            // detected. This is to prevent nasty pans after pinch.
            this.noKinetic_ = this.targetPointers.length > 1;
            return true;
        }
        return false;
    }
}
const __TURBOPACK__default__export__ = DragPan;
}}),
"[project]/node_modules/ol/interaction/PinchRotate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/PinchRotate
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/rotationconstraint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
;
;
;
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */ class PinchRotate extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = options;
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FALSE"];
        }
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {boolean}
     */ this.rotating_ = false;
        /**
     * @private
     * @type {number}
     */ this.rotationDelta_ = 0.0;
        /**
     * @private
     * @type {number}
     */ this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */ handleDragEvent(mapBrowserEvent) {
        let rotationDelta = 0.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        // angle between touches
        const angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
        if (this.lastAngle_ !== undefined) {
            const delta = angle - this.lastAngle_;
            this.rotationDelta_ += delta;
            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                this.rotating_ = true;
            }
            rotationDelta = delta;
        }
        this.lastAngle_ = angle;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$rotationconstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disable"]) {
            return;
        }
        // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1
        this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(this.targetPointers)));
        // rotate
        if (this.rotating_) {
            map.render();
            view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        }
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastAngle_ = undefined;
            this.rotating_ = false;
            this.rotationDelta_ = 0.0;
            if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
            }
            return true;
        }
        return false;
    }
}
const __TURBOPACK__default__export__ = PinchRotate;
}}),
"[project]/node_modules/ol/interaction/PinchZoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/PinchZoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
;
;
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */ class PinchZoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = options;
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FALSE"];
        }
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 400;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastDistance_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.lastScaleDelta_ = 1;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */ handleDragEvent(mapBrowserEvent) {
        let scaleDelta = 1.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        const dx = touch0.clientX - touch1.clientX;
        const dy = touch0.clientY - touch1.clientY;
        // distance between touches
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (this.lastDistance_ !== undefined) {
            scaleDelta = this.lastDistance_ / distance;
        }
        this.lastDistance_ = distance;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (scaleDelta != 1.0) {
            this.lastScaleDelta_ = scaleDelta;
        }
        // scale anchor point.
        this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(this.targetPointers)));
        // scale, bypass the resolution constraint
        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            return false;
        }
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastDistance_ = undefined;
            this.lastScaleDelta_ = 1;
            if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
            }
            return true;
        }
        return false;
    }
}
const __TURBOPACK__default__export__ = PinchZoom;
}}),
"[project]/node_modules/ol/interaction/KeyboardPan.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/KeyboardPan
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Key.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */ /**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */ class KeyboardPan extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options || {};
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultCondition_ = function(mapBrowserEvent) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noModifierKeys"])(mapBrowserEvent) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["targetNotEditable"])(mapBrowserEvent);
        };
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
        /**
     * @private
     * @type {number}
     */ this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEYDOWN) {
            const keyEvent = mapBrowserEvent.originalEvent;
            const key = keyEvent.key;
            if (this.condition_(mapBrowserEvent) && (key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOWN || key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LEFT || key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RIGHT || key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UP)) {
                const map = mapBrowserEvent.map;
                const view = map.getView();
                const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                let deltaX = 0, deltaY = 0;
                if (key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOWN) {
                    deltaY = -mapUnitsDelta;
                } else if (key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LEFT) {
                    deltaX = -mapUnitsDelta;
                } else if (key == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RIGHT) {
                    deltaX = mapUnitsDelta;
                } else {
                    deltaY = mapUnitsDelta;
                }
                const delta = [
                    deltaX,
                    deltaY
                ];
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotate"])(delta, view.getRotation());
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pan"])(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
const __TURBOPACK__default__export__ = KeyboardPan;
}}),
"[project]/node_modules/ol/interaction/KeyboardZoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/KeyboardZoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
;
;
;
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */ /**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */ class KeyboardZoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["platformModifierKey"])(mapBrowserEvent) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["targetNotEditable"])(mapBrowserEvent);
        };
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEYDOWN || mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEYPRESS) {
            const keyEvent = mapBrowserEvent.originalEvent;
            const key = keyEvent.key;
            if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {
                const map = mapBrowserEvent.map;
                const delta = key === '+' ? this.delta_ : -this.delta_;
                const view = map.getView();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zoomByDelta"])(view, delta, undefined, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
const __TURBOPACK__default__export__ = KeyboardZoom;
}}),
"[project]/node_modules/ol/interaction/MouseWheelZoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/MouseWheelZoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/has.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */ class MouseWheelZoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        /**
     * @private
     * @type {number}
     */ this.totalDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.lastDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @private
     * @type {number}
     */ this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
        /**
     * @private
     * @type {boolean}
     */ this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
        /**
     * @private
     * @type {boolean}
     */ this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
        const condition = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["always"];
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["all"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusWithTabindex"], condition) : condition;
        /**
     * @private
     * @type {?import("../pixel.js").Pixel}
     */ this.lastAnchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.startTime_ = undefined;
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.timeoutId_;
        /**
     * @private
     * @type {Mode|undefined}
     */ this.mode_ = undefined;
        /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */ this.trackpadEventGap_ = 400;
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.trackpadTimeoutId_;
        /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */ this.deltaPerZoom_ = 300;
    }
    /**
   * @private
   */ endInteraction_() {
        this.trackpadTimeoutId_ = undefined;
        const map = this.getMap();
        if (!map) {
            return;
        }
        const view = map.getView();
        view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null);
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) {
            return true;
        }
        const type = mapBrowserEvent.type;
        if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].WHEEL) {
            return true;
        }
        const map = mapBrowserEvent.map;
        const wheelEvent = mapBrowserEvent.originalEvent;
        wheelEvent.preventDefault();
        if (this.useAnchor_) {
            this.lastAnchor_ = mapBrowserEvent.pixel;
        }
        // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
        let delta;
        if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].WHEEL) {
            delta = wheelEvent.deltaY;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FIREFOX"] && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                delta /= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$has$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEVICE_PIXEL_RATIO"];
            }
            if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                delta *= 40;
            }
        }
        if (delta === 0) {
            return false;
        }
        this.lastDelta_ = delta;
        const now = Date.now();
        if (this.startTime_ === undefined) {
            this.startTime_ = now;
        }
        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
            this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
        }
        const view = map.getView();
        if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {
            if (this.trackpadTimeoutId_) {
                clearTimeout(this.trackpadTimeoutId_);
            } else {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.beginInteraction();
            }
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
            view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null);
            this.startTime_ = now;
            return false;
        }
        this.totalDelta_ += delta;
        const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
    }
    /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */ handleWheelZoom_(map) {
        const view = map.getView();
        if (view.getAnimating()) {
            view.cancelAnimations();
        }
        let delta = -(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        if (view.getConstrainResolution() || this.constrainResolution_) {
            // view has a zoom constraint, zoom by 1
            delta = delta ? delta > 0 ? 1 : -1 : 0;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zoomByDelta"])(view, delta, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
    }
    /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */ setMouseAnchor(useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) {
            this.lastAnchor_ = null;
        }
    }
}
const __TURBOPACK__default__export__ = MouseWheelZoom;
}}),
"[project]/node_modules/ol/interaction/DragBox.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/DragBox
 */ // FIXME draw drag box
__turbopack_esm__({
    "DragBoxEvent": (()=>DragBoxEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Box$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/render/Box.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
;
;
;
;
/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */ /**
 * @enum {string}
 */ const DragBoxEventType = {
    /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */ BOXSTART: 'boxstart',
    /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */ BOXDRAG: 'boxdrag',
    /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */ BOXEND: 'boxend',
    /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */ BOXCANCEL: 'boxcancel'
};
class DragBoxEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */ constructor(type, coordinate, mapBrowserEvent){
        super(type);
        /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */ this.coordinate = coordinate;
        /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */ /**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */ class DragBox extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DragBoxOnSignature<void>}
     */ this.un;
        options = options ?? {};
        /**
     * @type {import("../render/Box.js").default}
     * @private
     */ this.box_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$render$2f$Box$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](options.className || 'ol-dragbox');
        /**
     * @type {number}
     * @private
     */ this.minArea_ = options.minArea ?? 64;
        if (options.onBoxEnd) {
            this.onBoxEnd = options.onBoxEnd;
        }
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.startPixel_ = null;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mouseActionButton"];
        /**
     * @private
     * @type {EndCondition}
     */ this.boxEndCondition_ = options.boxEndCondition ?? this.defaultBoxEndCondition;
    }
    /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */ defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
        const width = endPixel[0] - startPixel[0];
        const height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
    }
    /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */ getGeometry() {
        return this.box_.getGeometry();
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */ handleDragEvent(mapBrowserEvent) {
        if (!this.startPixel_) {
            return;
        }
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(mapBrowserEvent) {
        if (!this.startPixel_) {
            return false;
        }
        const completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
        if (completeBox) {
            this.onBoxEnd(mapBrowserEvent);
        }
        this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        this.box_.setMap(null);
        this.startPixel_ = null;
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
            this.startPixel_ = mapBrowserEvent.pixel;
            this.box_.setMap(mapBrowserEvent.map);
            this.box_.setPixels(this.startPixel_, this.startPixel_);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
            return true;
        }
        return false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */ onBoxEnd(event) {}
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */ setActive(active) {
        if (!active) {
            this.box_.setMap(null);
            if (this.startPixel_) {
                this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null));
                this.startPixel_ = null;
            }
        }
        super.setActive(active);
    }
    /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */ setMap(map) {
        const oldMap = this.getMap();
        if (oldMap) {
            this.box_.setMap(null);
            if (this.startPixel_) {
                this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null));
                this.startPixel_ = null;
            }
        }
        super.setMap(map);
    }
}
const __TURBOPACK__default__export__ = DragBox;
}}),
"[project]/node_modules/ol/interaction/DragZoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/DragZoom
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/easing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/DragBox.js [app-client] (ecmascript)");
;
;
;
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */ class DragZoom extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const condition = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shiftKeyOnly"];
        super({
            condition: condition,
            className: options.className || 'ol-dragzoom',
            minArea: options.minArea
        });
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 200;
        /**
     * @private
     * @type {boolean}
     */ this.out_ = options.out !== undefined ? options.out : false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */ onBoxEnd(event) {
        const map = this.getMap();
        const view = map.getView();
        let geometry = this.getGeometry();
        if (this.out_) {
            const rotatedExtent = view.rotatedExtentForGeometry(geometry);
            const resolution = view.getResolutionForExtentInternal(rotatedExtent);
            const factor = view.getResolution() / resolution;
            geometry = geometry.clone();
            geometry.scale(factor * factor);
        }
        view.fitInternal(geometry, {
            duration: this.duration_,
            easing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$easing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["easeOut"]
        });
    }
}
const __TURBOPACK__default__export__ = DragZoom;
}}),
"[project]/node_modules/ol/interaction/defaults.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/defaults
 */ __turbopack_esm__({
    "defaults": (()=>defaults)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Kinetic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Kinetic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragRotate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/DragRotate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DoubleClickZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/DoubleClickZoom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragPan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/DragPan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$PinchRotate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/PinchRotate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$PinchZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/PinchZoom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$KeyboardPan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/KeyboardPan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$KeyboardZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/KeyboardZoom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$MouseWheelZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/MouseWheelZoom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/DragZoom.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Interaction.js").default>} */ const interactions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    const kinetic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Kinetic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](-0.005, 0.05, 100);
    const altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
    if (altShiftDragRotate) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragRotate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
    }
    const doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
    if (doubleClickZoom) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DoubleClickZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            delta: options.zoomDelta,
            duration: options.zoomDuration
        }));
    }
    const dragPan = options.dragPan !== undefined ? options.dragPan : true;
    if (dragPan) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragPan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            onFocusOnly: options.onFocusOnly,
            kinetic: kinetic
        }));
    }
    const pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
    if (pinchRotate) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$PinchRotate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
    }
    const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
    if (pinchZoom) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$PinchZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            duration: options.zoomDuration
        }));
    }
    const keyboard = options.keyboard !== undefined ? options.keyboard : true;
    if (keyboard) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$KeyboardPan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$KeyboardZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            delta: options.zoomDelta,
            duration: options.zoomDuration
        }));
    }
    const mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$MouseWheelZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            onFocusOnly: options.onFocusOnly,
            duration: options.zoomDuration
        }));
    }
    const shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
    if (shiftDragZoom) {
        interactions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$DragZoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            duration: options.zoomDuration
        }));
    }
    return interactions;
}
}}),
"[project]/node_modules/ol/interaction/Select.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Select
 */ __turbopack_esm__({
    "SelectEvent": (()=>SelectEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/obj.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Interaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/Style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @enum {string}
 */ const SelectEventType = {
    /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */ SELECT: 'select'
};
class SelectEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */ constructor(type, selected, deselected, mapBrowserEvent){
        super(type);
        /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */ this.selected = selected;
        /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */ this.deselected = deselected;
        /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object<number, import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */ const originalFeatureStyles = {};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */ /**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */ class Select extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {SelectOnSignature<void>}
     */ this.un;
        options = options ? options : {};
        /**
     * @private
     */ this.boundAddFeature_ = this.addFeature_.bind(this);
        /**
     * @private
     */ this.boundRemoveFeature_ = this.removeFeature_.bind(this);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["singleClick"];
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.addCondition_ = options.addCondition ? options.addCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["never"];
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.removeCondition_ = options.removeCondition ? options.removeCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["never"];
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shiftKeyOnly"];
        /**
     * @private
     * @type {boolean}
     */ this.multi_ = options.multi ? options.multi : false;
        /**
     * @private
     * @type {FilterFunction}
     */ this.filter_ = options.filter ? options.filter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRUE"];
        /**
     * @private
     * @type {number}
     */ this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
        /**
     * @private
     * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */ this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
        /**
     * @private
     * @type {Collection<Feature>}
     */ this.features_ = options.features || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */ let layerFilter;
        if (options.layers) {
            if (typeof options.layers === 'function') {
                layerFilter = options.layers;
            } else {
                const layers = options.layers;
                layerFilter = function(layer) {
                    return layers.includes(layer);
                };
            }
        } else {
            layerFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRUE"];
        }
        /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */ this.layerFilter_ = layerFilter;
        /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */ this.featureLayerAssociation_ = {};
    }
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */ addFeatureLayerAssociation_(feature, layer) {
        this.featureLayerAssociation_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(feature)] = layer;
    }
    /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */ getFeatures() {
        return this.features_;
    }
    /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */ getHitTolerance() {
        return this.hitTolerance_;
    }
    /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */ getLayer(feature) {
        return this.featureLayerAssociation_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(feature)];
    }
    /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */ setHitTolerance(hitTolerance) {
        this.hitTolerance_ = hitTolerance;
    }
    /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */ setMap(map) {
        const currentMap = this.getMap();
        if (currentMap && this.style_) {
            this.features_.forEach(this.restorePreviousStyle_.bind(this));
        }
        super.setMap(map);
        if (map) {
            this.features_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADD, this.boundAddFeature_);
            this.features_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE, this.boundRemoveFeature_);
            if (this.style_) {
                this.features_.forEach(this.applySelectedStyle_.bind(this));
            }
        } else {
            this.features_.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADD, this.boundAddFeature_);
            this.features_.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE, this.boundRemoveFeature_);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ addFeature_(evt) {
        const feature = evt.element;
        if (this.style_) {
            this.applySelectedStyle_(feature);
        }
        if (!this.getLayer(feature)) {
            const layer = this.getMap().getAllLayers().find(function(layer) {
                if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && layer.getSource() && layer.getSource().hasFeature(feature)) {
                    return layer;
                }
            });
            if (layer) {
                this.addFeatureLayerAssociation_(feature, layer);
            }
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ removeFeature_(evt) {
        if (this.style_) {
            this.restorePreviousStyle_(evt.element);
        }
    }
    /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */ getStyle() {
        return this.style_;
    }
    /**
   * @param {Feature} feature Feature
   * @private
   */ applySelectedStyle_(feature) {
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(feature);
        if (!(key in originalFeatureStyles)) {
            originalFeatureStyles[key] = feature.getStyle();
        }
        feature.setStyle(this.style_);
    }
    /**
   * @param {Feature} feature Feature
   * @private
   */ restorePreviousStyle_(feature) {
        const interactions = this.getMap().getInteractions().getArray();
        for(let i = interactions.length - 1; i >= 0; --i){
            const interaction = interactions[i];
            if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
                feature.setStyle(interaction.getStyle());
                return;
            }
        }
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(feature);
        feature.setStyle(originalFeatureStyles[key]);
        delete originalFeatureStyles[key];
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeatureLayerAssociation_(feature) {
        delete this.featureLayerAssociation_[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(feature)];
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) {
            return true;
        }
        const add = this.addCondition_(mapBrowserEvent);
        const remove = this.removeCondition_(mapBrowserEvent);
        const toggle = this.toggleCondition_(mapBrowserEvent);
        const set = !add && !remove && !toggle;
        const map = mapBrowserEvent.map;
        const features = this.getFeatures();
        /**
     * @type {Array<Feature>}
     */ const deselected = [];
        /**
     * @type {Array<Feature>}
     */ const selected = [];
        if (set) {
            // Replace the currently selected feature(s) with the feature(s) at the
            // pixel, or clear the selected feature(s) if there is no feature at
            // the pixel.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$obj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clear"])(this.featureLayerAssociation_);
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */ (feature, layer)=>{
                if (!(feature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) || !this.filter_(feature, layer)) {
                    return;
                }
                this.addFeatureLayerAssociation_(feature, layer);
                selected.push(feature);
                return !this.multi_;
            }, {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(let i = features.getLength() - 1; i >= 0; --i){
                const feature = features.item(i);
                const index = selected.indexOf(feature);
                if (index > -1) {
                    // feature is already selected
                    selected.splice(index, 1);
                } else {
                    features.remove(feature);
                    deselected.push(feature);
                }
            }
            if (selected.length !== 0) {
                features.extend(selected);
            }
        } else {
            // Modify the currently selected feature(s).
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */ (feature, layer)=>{
                if (!(feature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) || !this.filter_(feature, layer)) {
                    return;
                }
                if ((add || toggle) && !features.getArray().includes(feature)) {
                    this.addFeatureLayerAssociation_(feature, layer);
                    selected.push(feature);
                } else if ((remove || toggle) && features.getArray().includes(feature)) {
                    deselected.push(feature);
                    this.removeFeatureLayerAssociation_(feature);
                }
                return !this.multi_;
            }, {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(let j = deselected.length - 1; j >= 0; --j){
                features.remove(deselected[j]);
            }
            features.extend(selected);
        }
        if (selected.length > 0 || deselected.length > 0) {
            this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
        }
        return true;
    }
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const styles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditingStyle"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extend"])(styles['Polygon'], styles['LineString']);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extend"])(styles['GeometryCollection'], styles['LineString']);
    return function(feature) {
        if (!feature.getGeometry()) {
            return null;
        }
        return styles[feature.getGeometry().getType()];
    };
}
const __TURBOPACK__default__export__ = Select;
}}),
"[project]/node_modules/ol/interaction/Modify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Modify
 */ __turbopack_esm__({
    "ModifyEvent": (()=>ModifyEvent),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$RBush$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/structs/RBush.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Collection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/VectorEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/CollectionEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Polygon.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/Style.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CIRCUMFERENCE_INDEX = 1;
const tempExtent = [
    0,
    0,
    0,
    0
];
const tempSegment = [];
/**
 * @enum {string}
 */ const ModifyEventType = {
    /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */ MODIFYSTART: 'modifystart',
    /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */ MODIFYEND: 'modifyend'
};
class ModifyEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */ constructor(type, features, mapBrowserEvent){
        super(type);
        /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */ this.features = features;
        /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */ /**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */ class Modify extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        super(options);
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {ModifyOnSignature<void>}
     */ this.un;
        /** @private */ this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["primaryAction"];
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultDeleteCondition_ = function(mapBrowserEvent) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["altKeyOnly"])(mapBrowserEvent) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["singleClick"])(mapBrowserEvent);
        };
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["always"];
        /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */ this.vertexFeature_ = null;
        /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */ this.vertexSegments_ = null;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.lastPixel_ = [
            0,
            0
        ];
        /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */ this.ignoreNextSingleClick_ = false;
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.featuresBeingModified_ = null;
        /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */ this.rBush_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$structs$2f$RBush$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        /**
     * @type {number}
     * @private
     */ this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
     * @type {boolean}
     * @private
     */ this.snappedToVertex_ = false;
        /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */ this.changingFeature_ = false;
        /**
     * @type {Array<DragSegment>}
     * @private
     */ this.dragSegments_ = [];
        /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            source: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                useSpatialIndex: false,
                wrapX: !!options.wrapX
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */ this.SEGMENT_WRITERS_ = {
            'Point': this.writePointGeometry_.bind(this),
            'LineString': this.writeLineStringGeometry_.bind(this),
            'LinearRing': this.writeLineStringGeometry_.bind(this),
            'Polygon': this.writePolygonGeometry_.bind(this),
            'MultiPoint': this.writeMultiPointGeometry_.bind(this),
            'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),
            'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),
            'Circle': this.writeCircleGeometry_.bind(this),
            'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this)
        };
        /**
     * @type {VectorSource}
     * @private
     */ this.source_ = null;
        /**
     * @type {boolean|import("../layer/BaseVector").default}
     * @private
     */ this.hitDetection_ = null;
        /** @type {Collection<Feature>} */ let features;
        if (options.features) {
            features = options.features;
        } else if (options.source) {
            this.source_ = options.source;
            features = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.source_.getFeatures());
            this.source_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADDFEATURE, this.handleSourceAdd_.bind(this));
            this.source_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$VectorEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVEFEATURE, this.handleSourceRemove_.bind(this));
        }
        if (!features) {
            throw new Error('The modify interaction requires features, a source or a layer');
        }
        if (options.hitDetection) {
            this.hitDetection_ = options.hitDetection;
        }
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.features_ = features;
        this.features_.forEach(this.addFeature_.bind(this));
        this.features_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADD, this.handleFeatureAdd_.bind(this));
        this.features_.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$CollectionEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE, this.handleFeatureRemove_.bind(this));
        /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */ this.lastPointerEvent_ = null;
        /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     * @private
     */ this.delta_ = [
            0,
            0
        ];
        /**
     * @private
     */ this.snapToPointer_ = options.snapToPointer === undefined ? !this.hitDetection_ : options.snapToPointer;
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ addFeature_(feature) {
        const geometry = feature.getGeometry();
        if (geometry) {
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            if (writer) {
                writer(feature, geometry);
            }
        }
        const map = this.getMap();
        if (map && map.isRendered() && this.getActive()) {
            this.handlePointerAtPixel_(map.getCoordinateFromPixel(this.lastPixel_));
        }
        feature.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<SegmentData>} segments The segments subject to modification.
   * @private
   */ willModifyFeatures_(evt, segments) {
        if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Collection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            const features = this.featuresBeingModified_.getArray();
            for(let i = 0, ii = segments.length; i < ii; ++i){
                const feature = segments[i].feature;
                if (feature && !features.includes(feature)) {
                    this.featuresBeingModified_.push(feature);
                }
            }
            if (this.featuresBeingModified_.getLength() === 0) {
                this.featuresBeingModified_ = null;
            } else {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
            }
        }
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeature_(feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of candidate features is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        feature.removeEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeatureSegmentData_(feature) {
        const rBush = this.rBush_;
        /** @type {Array<SegmentData>} */ const nodesToRemove = [];
        rBush.forEach(/**
       * @param {SegmentData} node RTree node.
       */ function(node) {
            if (feature === node.feature) {
                nodesToRemove.push(node);
            }
        });
        for(let i = nodesToRemove.length - 1; i >= 0; --i){
            const nodeToRemove = nodesToRemove[i];
            for(let j = this.dragSegments_.length - 1; j >= 0; --j){
                if (this.dragSegments_[j][0] === nodeToRemove) {
                    this.dragSegments_.splice(j, 1);
                }
            }
            rBush.remove(nodeToRemove);
        }
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */ setActive(active) {
        if (this.vertexFeature_ && !active) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        super.setActive(active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   * @override
   */ setMap(map) {
        this.overlay_.setMap(map);
        super.setMap(map);
    }
    /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceAdd_(event) {
        if (event.feature) {
            this.features_.push(event.feature);
        }
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceRemove_(event) {
        if (event.feature) {
            this.features_.remove(event.feature);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureAdd_(evt) {
        this.addFeature_(evt.element);
    }
    /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */ handleFeatureChange_(evt) {
        if (!this.changingFeature_) {
            const feature = evt.target;
            this.removeFeature_(feature);
            this.addFeature_(feature);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureRemove_(evt) {
        this.removeFeature_(evt.element);
    }
    /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */ writePointGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        /** @type {SegmentData} */ const segmentData = {
            feature: feature,
            geometry: geometry,
            segment: [
                coordinates,
                coordinates
            ]
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */ writeMultiPointGeometry_(feature, geometry) {
        const points = geometry.getCoordinates();
        for(let i = 0, ii = points.length; i < ii; ++i){
            const coordinates = points[i];
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                depth: [
                    i
                ],
                index: i,
                segment: [
                    coordinates,
                    coordinates
                ]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */ writeLineStringGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
            const segment = coordinates.slice(i, i + 2);
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                index: i,
                segment: segment
            };
            this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(segment), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */ writeMultiLineStringGeometry_(feature, geometry) {
        const lines = geometry.getCoordinates();
        for(let j = 0, jj = lines.length; j < jj; ++j){
            const coordinates = lines[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */ writePolygonGeometry_(feature, geometry) {
        const rings = geometry.getCoordinates();
        for(let j = 0, jj = rings.length; j < jj; ++j){
            const coordinates = rings[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */ writeMultiPolygonGeometry_(feature, geometry) {
        const polygons = geometry.getCoordinates();
        for(let k = 0, kk = polygons.length; k < kk; ++k){
            const rings = polygons[k];
            for(let j = 0, jj = rings.length; j < jj; ++j){
                const coordinates = rings[j];
                for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                    const segment = coordinates.slice(i, i + 2);
                    /** @type {SegmentData} */ const segmentData = {
                        feature: feature,
                        geometry: geometry,
                        depth: [
                            j,
                            k
                        ],
                        index: i,
                        segment: segment
                    };
                    this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(segment), segmentData);
                }
            }
        }
    }
    /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */ writeCircleGeometry_(feature, geometry) {
        const coordinates = geometry.getCenter();
        /** @type {SegmentData} */ const centerSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CENTER_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        /** @type {SegmentData} */ const circumferenceSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CIRCUMFERENCE_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        const featureSegments = [
            centerSegmentData,
            circumferenceSegmentData
        ];
        centerSegmentData.featureSegments = featureSegments;
        circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
        let circleGeometry = geometry;
        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
        if (userProjection && this.getMap()) {
            const projection = this.getMap().getView().getProjection();
            circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            circleGeometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCircle"])(circleGeometry).transform(projection, userProjection);
        }
        this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */ writeGeometryCollectionGeometry_(feature, geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0; i < geometries.length; ++i){
            const geometry = geometries[i];
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            writer(feature, geometry);
        }
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @param {boolean} existing The vertex represents an existing vertex.
   * @return {Feature} Vertex feature.
   * @private
   */ createOrUpdateVertexFeature_(coordinates, features, geometries, existing) {
        let vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](coordinates));
            this.vertexFeature_ = vertexFeature;
            this.overlay_.getSource().addFeature(vertexFeature);
        } else {
            const geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(coordinates);
        }
        vertexFeature.set('features', features);
        vertexFeature.set('geometries', geometries);
        vertexFeature.set('existing', existing);
        return vertexFeature;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
            return true;
        }
        this.lastPointerEvent_ = mapBrowserEvent;
        let handled;
        if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
            this.handlePointerMove_(mapBrowserEvent);
        }
        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
            if (mapBrowserEvent.type != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SINGLECLICK || !this.ignoreNextSingleClick_) {
                handled = this.removePoint();
            } else {
                handled = true;
            }
        }
        if (mapBrowserEvent.type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SINGLECLICK) {
            this.ignoreNextSingleClick_ = false;
        }
        return super.handleEvent(mapBrowserEvent) && !handled;
    }
    findInsertVerticesAndUpdateDragSegments_(pixelCoordinate) {
        this.handlePointerAtPixel_(pixelCoordinate);
        this.dragSegments_.length = 0;
        this.featuresBeingModified_ = null;
        const vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            return;
        }
        const projection = this.getMap().getView().getProjection();
        const insertVertices = [];
        const vertex = vertexFeature.getGeometry().getCoordinates();
        const vertexExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])([
            vertex
        ]);
        const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
        const componentSegments = {};
        segmentDataMatches.sort(compareIndexes);
        for(let i = 0, ii = segmentDataMatches.length; i < ii; ++i){
            const segmentDataMatch = segmentDataMatches[i];
            const segment = segmentDataMatch.segment;
            let uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(segmentDataMatch.geometry);
            const depth = segmentDataMatch.depth;
            if (depth) {
                uid += '-' + depth.join('-'); // separate feature components
            }
            if (!componentSegments[uid]) {
                componentSegments[uid] = new Array(2);
            }
            if (segmentDataMatch.geometry.getType() === 'Circle' && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(closestVertex, vertex) && !componentSegments[uid][0]) {
                    this.dragSegments_.push([
                        segmentDataMatch,
                        0
                    ]);
                    componentSegments[uid][0] = segmentDataMatch;
                }
                continue;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[0], vertex) && !componentSegments[uid][0]) {
                this.dragSegments_.push([
                    segmentDataMatch,
                    0
                ]);
                componentSegments[uid][0] = segmentDataMatch;
                continue;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[1], vertex) && !componentSegments[uid][1]) {
                if (componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
                    let coordinates = segmentDataMatch.geometry.getCoordinates();
                    switch(segmentDataMatch.geometry.getType()){
                        // prevent dragging closed linestrings by the connecting node
                        case 'LineString':
                        case 'MultiLineString':
                            continue;
                        // if dragging the first vertex of a polygon, ensure the other segment
                        // belongs to the closing vertex of the linear ring
                        case 'MultiPolygon':
                            coordinates = coordinates[depth[1]];
                        /* falls through */ case 'Polygon':
                            if (segmentDataMatch.index !== coordinates[depth[0]].length - 2) {
                                continue;
                            }
                            break;
                        default:
                    }
                }
                this.dragSegments_.push([
                    segmentDataMatch,
                    1
                ]);
                componentSegments[uid][1] = segmentDataMatch;
                continue;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1]) {
                insertVertices.push(segmentDataMatch);
            }
        }
        return insertVertices;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @override
   */ handleDragEvent(evt) {
        this.ignoreNextSingleClick_ = false;
        this.willModifyFeatures_(evt, this.dragSegments_.map(([segment])=>segment));
        const vertex = [
            evt.coordinate[0] + this.delta_[0],
            evt.coordinate[1] + this.delta_[1]
        ];
        const features = [];
        const geometries = [];
        for(let i = 0, ii = this.dragSegments_.length; i < ii; ++i){
            const dragSegment = this.dragSegments_[i];
            const segmentData = dragSegment[0];
            const feature = segmentData.feature;
            if (!features.includes(feature)) {
                features.push(feature);
            }
            const geometry = segmentData.geometry;
            if (!geometries.includes(geometry)) {
                geometries.push(geometry);
            }
            const depth = segmentData.depth;
            let coordinates;
            const segment = segmentData.segment;
            const index = dragSegment[1];
            while(vertex.length < geometry.getStride()){
                vertex.push(segment[index][vertex.length]);
            }
            switch(geometry.getType()){
                case 'Point':
                    coordinates = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'MultiPoint':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index] = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'LineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiLineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Polygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiPolygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Circle':
                    const circle = geometry;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        circle.setCenter(vertex);
                        this.changingFeature_ = false;
                    } else {
                        // We're dragging the circle's circumference:
                        this.changingFeature_ = true;
                        const projection = evt.map.getView().getProjection();
                        let radius = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(circle.getCenter(), projection), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(vertex, projection));
                        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
                        if (userProjection) {
                            const circleGeometry = circle.clone().transform(userProjection, projection);
                            circleGeometry.setRadius(radius);
                            radius = circleGeometry.transform(projection, userProjection).getRadius();
                        }
                        circle.setRadius(radius);
                        this.changingFeature_ = false;
                    }
                    break;
                default:
            }
            if (coordinates) {
                this.setGeometryCoordinates_(geometry, coordinates);
            }
        }
        this.createOrUpdateVertexFeature_(vertex, features, geometries, true);
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(evt) {
        if (!this.condition_(evt)) {
            return false;
        }
        const pixelCoordinate = evt.coordinate;
        const insertVertices = this.findInsertVerticesAndUpdateDragSegments_(pixelCoordinate);
        if (insertVertices?.length && this.insertVertexCondition_(evt)) {
            this.willModifyFeatures_(evt, insertVertices);
            if (this.vertexFeature_) {
                const vertex = this.vertexFeature_.getGeometry().getCoordinates();
                for(let j = insertVertices.length - 1; j >= 0; --j){
                    this.insertVertex_(insertVertices[j], vertex);
                }
                this.ignoreNextSingleClick_ = true;
            }
        }
        return !!this.vertexFeature_;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(evt) {
        for(let i = this.dragSegments_.length - 1; i >= 0; --i){
            const segmentData = this.dragSegments_[i][0];
            const geometry = segmentData.geometry;
            if (geometry.getType() === 'Circle') {
                const circle = geometry;
                // Update a circle object in the R* bush:
                const coordinates = circle.getCenter();
                const centerSegmentData = segmentData.featureSegments[0];
                const circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
                /** @type {import("../geom/Circle.js").default | import("../geom/Polygon.js").default} */ let circleGeometry = circle;
                const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
                if (userProjection) {
                    const projection = evt.map.getView().getProjection();
                    circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    circleGeometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCircle"])(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
            } else {
                this.rBush_.update((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(segmentData.segment), segmentData);
            }
        }
        if (this.featuresBeingModified_) {
            this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
        }
        return false;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */ handlePointerMove_(evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.coordinate);
    }
    /**
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate The pixel Coordinate.
   * @private
   */ handlePointerAtPixel_(pixelCoordinate) {
        const map = this.getMap();
        const pixel = map.getPixelFromCoordinate(pixelCoordinate);
        const projection = map.getView().getProjection();
        const sortByDistance = function(a, b) {
            return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
        };
        /** @type {Array<SegmentData>|undefined} */ let nodes;
        /** @type {Point|undefined} */ let hitPointGeometry;
        if (this.hitDetection_) {
            const layerFilter = typeof this.hitDetection_ === 'object' ? (layer)=>layer === this.hitDetection_ : undefined;
            map.forEachFeatureAtPixel(pixel, (feature, layer, geometry)=>{
                if (geometry && geometry.getType() === 'Point') {
                    geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(geometry.getCoordinates(), projection));
                }
                const geom = geometry || feature.getGeometry();
                if (geom && geom.getType() === 'Point' && feature instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && this.features_.getArray().includes(feature)) {
                    hitPointGeometry = geom;
                    const coordinate = /** @type {Point} */ feature.getGeometry().getFlatCoordinates().slice(0, 2);
                    nodes = [
                        {
                            feature,
                            geometry: hitPointGeometry,
                            segment: [
                                coordinate,
                                coordinate
                            ]
                        }
                    ];
                }
                return true;
            }, {
                layerFilter
            });
        }
        if (!nodes) {
            const viewExtent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserExtent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOrUpdateFromCoordinate"])(pixelCoordinate, tempExtent), projection);
            const buffer = map.getView().getResolution() * this.pixelTolerance_;
            const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserExtent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buffer"])(viewExtent, buffer, tempExtent), projection);
            nodes = this.rBush_.getInExtent(box);
        }
        if (nodes && nodes.length > 0) {
            const node = nodes.sort(sortByDistance)[0];
            const closestSegment = node.segment;
            let vertex = closestOnSegmentData(pixelCoordinate, node, projection);
            const vertexPixel = map.getPixelFromCoordinate(vertex);
            let dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pixel, vertexPixel);
            if (hitPointGeometry || dist <= this.pixelTolerance_) {
                /** @type {Object<string, boolean>} */ const vertexSegments = {};
                vertexSegments[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(closestSegment)] = true;
                if (!this.snapToPointer_) {
                    this.delta_[0] = vertex[0] - pixelCoordinate[0];
                    this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === 'Circle' && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    this.snappedToVertex_ = true;
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ], this.snappedToVertex_);
                } else {
                    const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    const squaredDist1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(vertexPixel, pixel1);
                    const squaredDist2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(vertexPixel, pixel2);
                    dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    this.snappedToVertex_ = dist <= this.pixelTolerance_;
                    // Stop and cleanup overlay vertex feature if a segment was hit and new vertex creation is not allowed by the insertVertexCondition
                    if (!this.snappedToVertex_ && !this.insertVertexCondition_(this.lastPointerEvent_)) {
                        if (this.vertexFeature_) {
                            this.overlay_.getSource().removeFeature(this.vertexFeature_);
                            this.vertexFeature_ = null;
                        }
                        return;
                    }
                    if (this.snappedToVertex_) {
                        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    }
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ], this.snappedToVertex_);
                    const geometries = {};
                    geometries[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(node.geometry)] = true;
                    for(let i = 1, ii = nodes.length; i < ii; ++i){
                        const segment = nodes[i].segment;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(closestSegment[0], segment[0]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(closestSegment[1], segment[1]) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(closestSegment[0], segment[1]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(closestSegment[1], segment[0])) {
                            const geometryUid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(nodes[i].geometry);
                            if (!(geometryUid in geometries)) {
                                geometries[geometryUid] = true;
                                vertexSegments[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(segment)] = true;
                            }
                        } else {
                            break;
                        }
                    }
                }
                this.vertexSegments_ = vertexSegments;
                return;
            }
        }
        if (this.vertexFeature_) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
    }
    /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @return {boolean} A vertex was inserted.
   * @private
   */ insertVertex_(segmentData, vertex) {
        const segment = segmentData.segment;
        const feature = segmentData.feature;
        const geometry = segmentData.geometry;
        const depth = segmentData.depth;
        const index = segmentData.index;
        let coordinates;
        while(vertex.length < geometry.getStride()){
            vertex.push(0);
        }
        switch(geometry.getType()){
            case 'MultiLineString':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'Polygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'MultiPolygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'LineString':
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
            default:
                return false;
        }
        this.setGeometryCoordinates_(geometry, coordinates);
        const rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        /** @type {SegmentData} */ const newSegmentData = {
            segment: [
                segment[0],
                vertex
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index
        };
        rTree.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(newSegmentData.segment), newSegmentData);
        this.dragSegments_.push([
            newSegmentData,
            1
        ]);
        /** @type {SegmentData} */ const newSegmentData2 = {
            segment: [
                vertex,
                segment[1]
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index + 1
        };
        rTree.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([
            newSegmentData2,
            0
        ]);
        return true;
    }
    updatePointer_(coordinate) {
        if (coordinate) {
            this.findInsertVerticesAndUpdateDragSegments_(coordinate);
        }
        return this.vertexFeature_?.getGeometry().getCoordinates();
    }
    /**
   * Get the current pointer position.
   * @return {import("../coordinate.js").Coordinate | null} The current pointer coordinate.
   */ getPoint() {
        const coordinate = this.vertexFeature_?.getGeometry().getCoordinates();
        if (!coordinate) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(coordinate, this.getMap().getView().getProjection());
    }
    /**
   * Check if a point can be removed from the current linestring or polygon at the current
   * pointer position.
   * @return {boolean} A point can be deleted at the current pointer position.
   * @api
   */ canRemovePoint() {
        if (!this.vertexFeature_) {
            return false;
        }
        if (this.vertexFeature_.get('geometries').every((geometry)=>geometry.getType() === 'Circle' || geometry.getType().endsWith('Point'))) {
            return false;
        }
        const coordinate = this.vertexFeature_.getGeometry().getCoordinates();
        const segments = this.rBush_.getInExtent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])([
            coordinate
        ]));
        return segments.some(({ segment })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[0], coordinate) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[1], coordinate));
    }
    /**
   * Removes the vertex currently being pointed from the current linestring or polygon.
   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
   * @return {boolean} True when a vertex was removed.
   * @api
   */ removePoint(coordinate) {
        if (coordinate) {
            coordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinate, this.getMap().getView().getProjection());
            this.updatePointer_(coordinate);
        }
        if (!this.lastPointerEvent_ || this.lastPointerEvent_ && this.lastPointerEvent_.type != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDRAG) {
            const evt = this.lastPointerEvent_;
            this.willModifyFeatures_(evt, this.dragSegments_.map(([segment])=>segment));
            const removed = this.removeVertex_();
            if (this.featuresBeingModified_) {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            }
            this.featuresBeingModified_ = null;
            return removed;
        }
        return false;
    }
    /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */ removeVertex_() {
        const dragSegments = this.dragSegments_;
        const segmentsByFeature = {};
        let deleted = false;
        let component, coordinates, dragSegment, geometry, i, index, left;
        let newIndex, right, segmentData, uid;
        for(i = dragSegments.length - 1; i >= 0; --i){
            dragSegment = dragSegments[i];
            segmentData = dragSegment[0];
            uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUid"])(segmentData.feature);
            if (segmentData.depth) {
                // separate feature components
                uid += '-' + segmentData.depth.join('-');
            }
            if (!(uid in segmentsByFeature)) {
                segmentsByFeature[uid] = {};
            }
            if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
            } else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
            }
        }
        for(uid in segmentsByFeature){
            right = segmentsByFeature[uid].right;
            left = segmentsByFeature[uid].left;
            index = segmentsByFeature[uid].index;
            newIndex = index - 1;
            if (left !== undefined) {
                segmentData = left;
            } else {
                segmentData = right;
            }
            if (newIndex < 0) {
                newIndex = 0;
            }
            geometry = segmentData.geometry;
            coordinates = geometry.getCoordinates();
            component = coordinates;
            deleted = false;
            switch(geometry.getType()){
                case 'MultiLineString':
                    if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'LineString':
                    if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'MultiPolygon':
                    component = component[segmentData.depth[1]];
                /* falls through */ case 'Polygon':
                    component = component[segmentData.depth[0]];
                    if (component.length > 4) {
                        if (index == component.length - 1) {
                            index = 0;
                        }
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                            // close the ring again
                            component.pop();
                            component.push(component[0]);
                            newIndex = component.length - 1;
                        }
                    }
                    break;
                default:
            }
            if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                const segments = [];
                if (left !== undefined) {
                    this.rBush_.remove(left);
                    segments.push(left.segment[0]);
                }
                if (right !== undefined) {
                    this.rBush_.remove(right);
                    segments.push(right.segment[1]);
                }
                if (left !== undefined && right !== undefined) {
                    /** @type {SegmentData} */ const newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments
                    };
                    this.rBush_.insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                    this.overlay_.getSource().removeFeature(this.vertexFeature_);
                    this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
            }
        }
        return deleted;
    }
    /**
   * Check if a point can be inserted to the current linestring or polygon at the current
   * pointer position.
   * @return {boolean} A point can be inserted at the current pointer position.
   * @api
   */ canInsertPoint() {
        if (!this.vertexFeature_) {
            return false;
        }
        if (this.vertexFeature_.get('geometries').every((geometry)=>geometry.getType() === 'Circle' || geometry.getType().endsWith('Point'))) {
            return false;
        }
        const coordinate = this.vertexFeature_.getGeometry().getCoordinates();
        const segments = this.rBush_.getInExtent((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])([
            coordinate
        ]));
        return segments.some(({ segment })=>!((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[0], coordinate) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segment[1], coordinate)));
    }
    /**
   * Inserts the vertex currently being pointed to the current linestring or polygon.
   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
   * @return {boolean} A vertex was inserted.
   * @api
   */ insertPoint(coordinate) {
        const pixelCoordinate = coordinate ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinate, this.getMap().getView().getProjection()) : this.vertexFeature_?.getGeometry().getCoordinates();
        if (!pixelCoordinate) {
            return false;
        }
        const insertVertices = this.findInsertVerticesAndUpdateDragSegments_(pixelCoordinate);
        return insertVertices.reduce((prev, segmentData)=>prev || this.insertVertex_(segmentData, pixelCoordinate), false);
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */ setGeometryCoordinates_(geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */ updateSegmentIndices_(geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
            if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
                segmentDataMatch.index += delta;
            }
        });
    }
}
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */ function compareIndexes(a, b) {
    return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */ function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle') {
        let circleGeometry = geometry;
        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
            if (userProjection) {
                circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            }
            const distanceToCenterSquared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(circleGeometry.getCenter(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(pointCoordinates, projection));
            const distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
            return distanceToCircumference * distanceToCircumference;
        }
    }
    const coordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(pointCoordinates, projection);
    tempSegment[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(segmentData.segment[0], projection);
    tempSegment[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(segmentData.segment[1], projection);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistanceToSegment"])(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */ function closestOnSegmentData(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle' && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        let circleGeometry = geometry;
        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
        if (userProjection) {
            circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])(circleGeometry.getClosestPoint((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(pointCoordinates, projection)), projection);
    }
    const coordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(pointCoordinates, projection);
    tempSegment[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(segmentData.segment[0], projection);
    tempSegment[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(segmentData.segment[1], projection);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUserCoordinate"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["closestOnSegment"])(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditingStyle"])();
    return function(feature, resolution) {
        return style['Point'];
    };
}
const __TURBOPACK__default__export__ = Modify;
}}),
"[project]/node_modules/ol/interaction/Draw.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: require } = __turbopack_context__;
{
/**
 * @module ol/interaction/Draw
 */ __turbopack_esm__({
    "DrawEvent": (()=>DrawEvent),
    "createBox": (()=>createBox),
    "createRegularPolygon": (()=>createRegularPolygon),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/Event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/LineString.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiLineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiLineString.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Polygon.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPolygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiPolygon.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$GeometryCollection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/GeometryCollection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/Circle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/ol/proj.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/layer/Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/source/Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/condition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/events/EventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEventType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/MapBrowserEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/extent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/Feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/SimpleGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPoint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/geom/MultiPoint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/interaction/Pointer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/ol/style/Style.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.
 * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.
 * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with
 * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.
 * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`
 * geometry that corresponds to the polygon between the already drawn points and the current cursor position
 * (note that this polygon has only two points if only one point is drawn).
 * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose
 * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */ /**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */ /**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */ /**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */ /**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */ /**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */ /**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */ /**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */ /**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */ /**
 * @enum {string}
 */ const DrawEventType = {
    /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */ DRAWSTART: 'drawstart',
    /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */ DRAWEND: 'drawend',
    /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */ DRAWABORT: 'drawabort'
};
class DrawEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */ constructor(type, feature){
        super(type);
        /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */ this.feature = feature;
    }
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */ function getTraceTargets(coordinate, features) {
    /**
   * @type {Array<TraceTarget>}
   */ const targets = [];
    for(let i = 0; i < features.length; ++i){
        const feature = features[i];
        const geometry = feature.getGeometry();
        appendGeometryTraceTargets(coordinate, geometry, targets);
    }
    return targets;
}
/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */ function getSquaredDistance(a, b) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(a[0], a[1], b[0], b[1]);
}
/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */ function getCoordinate(coordinates, index) {
    const count = coordinates.length;
    if (index < 0) {
        return coordinates[index + count];
    }
    if (index >= count) {
        return coordinates[index - count];
    }
    return coordinates[index];
}
/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */ function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
    let lowIndex, highIndex;
    if (startIndex < endIndex) {
        lowIndex = startIndex;
        highIndex = endIndex;
    } else {
        lowIndex = endIndex;
        highIndex = startIndex;
    }
    const lowWholeIndex = Math.ceil(lowIndex);
    const highWholeIndex = Math.floor(highIndex);
    if (lowWholeIndex > highWholeIndex) {
        // both start and end are on the same segment
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        return getSquaredDistance(start, end);
    }
    let sd = 0;
    if (lowIndex < lowWholeIndex) {
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = getCoordinate(coordinates, lowWholeIndex);
        sd += getSquaredDistance(start, end);
    }
    if (highWholeIndex < highIndex) {
        const start = getCoordinate(coordinates, highWholeIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        sd += getSquaredDistance(start, end);
    }
    for(let i = lowWholeIndex; i < highWholeIndex - 1; ++i){
        const start = getCoordinate(coordinates, i);
        const end = getCoordinate(coordinates, i + 1);
        sd += getSquaredDistance(start, end);
    }
    return sd;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendGeometryTraceTargets(coordinate, geometry, targets) {
    if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
        return;
    }
    if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiLineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i){
            appendTraceTarget(coordinate, coordinates[i], false, targets);
        }
        return;
    }
    if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i){
            appendTraceTarget(coordinate, coordinates[i], true, targets);
        }
        return;
    }
    if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPolygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        const polys = geometry.getCoordinates();
        for(let i = 0, ii = polys.length; i < ii; ++i){
            const coordinates = polys[i];
            for(let j = 0, jj = coordinates.length; j < jj; ++j){
                appendTraceTarget(coordinate, coordinates[j], true, targets);
            }
        }
        return;
    }
    if (geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$GeometryCollection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        const geometries = geometry.getGeometries();
        for(let i = 0; i < geometries.length; ++i){
            appendGeometryTraceTargets(coordinate, geometries[i], targets);
        }
        return;
    }
// other types cannot be traced
}
/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */ /**
 * @type {TraceTargetUpdateInfo}
 */ const sharedUpdateInfo = {
    index: -1,
    endIndex: NaN
};
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */ function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
    const x = coordinate[0];
    const y = coordinate[1];
    let closestTargetDistance = Infinity;
    let newTargetIndex = -1;
    let newEndIndex = NaN;
    for(let targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex){
        const target = traceState.targets[targetIndex];
        const coordinates = target.coordinates;
        let minSegmentDistance = Infinity;
        let endIndex;
        for(let coordinateIndex = 0; coordinateIndex < coordinates.length - 1; ++coordinateIndex){
            const start = coordinates[coordinateIndex];
            const end = coordinates[coordinateIndex + 1];
            const rel = getPointSegmentRelationship(x, y, start, end);
            if (rel.squaredDistance < minSegmentDistance) {
                minSegmentDistance = rel.squaredDistance;
                endIndex = coordinateIndex + rel.along;
            }
        }
        if (minSegmentDistance < closestTargetDistance) {
            closestTargetDistance = minSegmentDistance;
            if (target.ring && traceState.targetIndex === targetIndex) {
                // same target, maintain the same trace direction
                if (target.endIndex > target.startIndex) {
                    // forward trace
                    if (endIndex < target.startIndex) {
                        endIndex += coordinates.length;
                    }
                } else if (target.endIndex < target.startIndex) {
                    // reverse trace
                    if (endIndex > target.startIndex) {
                        endIndex -= coordinates.length;
                    }
                }
            }
            newEndIndex = endIndex;
            newTargetIndex = targetIndex;
        }
    }
    const newTarget = traceState.targets[newTargetIndex];
    let considerBothDirections = newTarget.ring;
    if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
        // only consider switching trace direction if close to the start
        const newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);
        const pixel = map.getPixelFromCoordinate(newCoordinate);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pixel, traceState.startPx) > snapTolerance) {
            considerBothDirections = false;
        }
    }
    if (considerBothDirections) {
        const coordinates = newTarget.coordinates;
        const count = coordinates.length;
        const startIndex = newTarget.startIndex;
        const endIndex = newEndIndex;
        if (startIndex < endIndex) {
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex - count);
            if (reverseDistance < forwardDistance) {
                newEndIndex -= count;
            }
        } else {
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex + count);
            if (forwardDistance < reverseDistance) {
                newEndIndex += count;
            }
        }
    }
    sharedUpdateInfo.index = newTargetIndex;
    sharedUpdateInfo.endIndex = newEndIndex;
    return sharedUpdateInfo;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendTraceTarget(coordinate, coordinates, ring, targets) {
    const x = coordinate[0];
    const y = coordinate[1];
    for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
        const start = coordinates[i];
        const end = coordinates[i + 1];
        const rel = getPointSegmentRelationship(x, y, start, end);
        if (rel.squaredDistance === 0) {
            const index = i + rel.along;
            targets.push({
                coordinates: coordinates,
                ring: ring,
                startIndex: index,
                endIndex: index
            });
            return;
        }
    }
}
/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */ /**
 * @type {PointSegmentRelationship}
 */ const sharedRel = {
    along: 0,
    squaredDistance: 0
};
/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */ function getPointSegmentRelationship(x, y, start, end) {
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    let along = 0;
    let px = x1;
    let py = y1;
    if (dx !== 0 || dy !== 0) {
        along = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
        px += dx * along;
        py += dy * along;
    }
    sharedRel.along = along;
    sharedRel.squaredDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toFixed"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(x, y, px, py), 10);
    return sharedRel;
}
/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */ function interpolateCoordinate(coordinates, index) {
    const count = coordinates.length;
    let startIndex = Math.floor(index);
    const along = index - startIndex;
    if (startIndex >= count) {
        startIndex -= count;
    } else if (startIndex < 0) {
        startIndex += count;
    }
    let endIndex = startIndex + 1;
    if (endIndex >= count) {
        endIndex -= count;
    }
    const start = coordinates[startIndex];
    const x0 = start[0];
    const y0 = start[1];
    const end = coordinates[endIndex];
    const dx = end[0] - x0;
    const dy = end[1] - y0;
    return [
        x0 + dx * along,
        y0 + dy * along
    ];
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */ /**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */ class Draw extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Pointer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        const pointerOptions = options;
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FALSE"];
        }
        super(pointerOptions);
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DrawOnSignature<void>}
     */ this.un;
        /**
     * @type {boolean}
     * @private
     */ this.shouldHandle_ = false;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.downPx_ = null;
        /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */ this.downTimeout_;
        /**
     * @type {number|undefined}
     * @private
     */ this.lastDragTime_;
        /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */ this.pointerType_;
        /**
     * @type {boolean}
     * @private
     */ this.freehand_ = false;
        /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */ this.source_ = options.source ? options.source : null;
        /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */ this.features_ = options.features ? options.features : null;
        /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */ this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */ this.type_ = options.type;
        /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */ this.mode_ = getMode(this.type_);
        /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */ this.stopClick_ = !!options.stopClick;
        /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */ this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === 'Polygon' ? 3 : 2;
        /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */ this.maxPoints_ = this.mode_ === 'Circle' ? 2 : options.maxPoints ? options.maxPoints : Infinity;
        /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.finishCondition_ = options.finishCondition ? options.finishCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRUE"];
        /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */ this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';
        let geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
            const mode = this.mode_;
            if (mode === 'Circle') {
                /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = (coordinates, geometry, projection)=>{
                    const circle = geometry ? geometry : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
                        NaN,
                        NaN
                    ]);
                    const center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinates[0], projection);
                    const squaredLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(center, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinates[coordinates.length - 1], projection));
                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);
                    const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
                    if (userProjection) {
                        circle.transform(projection, userProjection);
                    }
                    return circle;
                };
            } else {
                let Constructor;
                if (mode === 'Point') {
                    Constructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
                } else if (mode === 'LineString') {
                    Constructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
                } else if (mode === 'Polygon') {
                    Constructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
                }
                /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = (coordinates, geometry, projection)=>{
                    if (geometry) {
                        if (mode === 'Polygon') {
                            if (coordinates[0].length) {
                                // Add a closing coordinate to match the first
                                geometry.setCoordinates([
                                    coordinates[0].concat([
                                        coordinates[0][0]
                                    ])
                                ], this.geometryLayout_);
                            } else {
                                geometry.setCoordinates([], this.geometryLayout_);
                            }
                        } else {
                            geometry.setCoordinates(coordinates, this.geometryLayout_);
                        }
                    } else {
                        geometry = new Constructor(coordinates, this.geometryLayout_);
                    }
                    return geometry;
                };
            }
        }
        /**
     * @type {GeometryFunction}
     * @private
     */ this.geometryFunction_ = geometryFunction;
        /**
     * @type {number}
     * @private
     */ this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
        /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */ this.finishCoordinate_ = null;
        /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */ this.sketchFeature_ = null;
        /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */ this.sketchPoint_ = null;
        /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */ this.sketchCoords_ = null;
        /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */ this.sketchLine_ = null;
        /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */ this.sketchLineCoords_ = null;
        /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */ this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
        /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$layer$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            source: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$source$2f$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileInteracting: true
        });
        /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noModifierKeys"];
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.freehandCondition_;
        if (options.freehand) {
            this.freehandCondition_ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["always"];
        } else {
            this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shiftKeyOnly"];
        }
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.traceCondition_;
        this.setTrace(options.trace || false);
        /**
     * @type {TraceState}
     * @private
     */ this.traceState_ = {
            active: false
        };
        /**
     * @type {VectorSource|null}
     * @private
     */ this.traceSource_ = options.traceSource || options.source || null;
        this.addChangeListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$interaction$2f$Property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ACTIVE, this.updateState_);
    }
    /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */ setTrace(trace) {
        let condition;
        if (!trace) {
            condition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["never"];
        } else if (trace === true) {
            condition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$condition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["always"];
        } else {
            condition = trace;
        }
        this.traceCondition_ = condition;
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   * @override
   */ setMap(map) {
        super.setMap(map);
        this.updateState_();
    }
    /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */ handleEvent(event) {
        if (event.originalEvent.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$events$2f$EventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CONTEXTMENU) {
            // Avoid context menu for long taps when drawing on mobile
            event.originalEvent.preventDefault();
        }
        this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
        let move = event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERMOVE;
        let pass = true;
        if (!this.freehand_ && this.lastDragTime_ && event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDRAG) {
            const now = Date.now();
            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
            } else {
                this.lastDragTime_ = undefined;
            }
            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
        }
        if (this.freehand_ && event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDRAG && this.sketchFeature_ !== null) {
            this.addToDrawing_(event.coordinate);
            pass = false;
        } else if (this.freehand_ && event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDOWN) {
            pass = false;
        } else if (move && this.getPointerCount() < 2) {
            pass = event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERMOVE;
            if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) {
                    // Avoid page scrolling when freehand drawing on mobile
                    event.originalEvent.preventDefault();
                }
            } else if (event.originalEvent.pointerType === 'mouse' || event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERDRAG && this.downTimeout_ === undefined) {
                this.handlePointerMove_(event);
            }
        } else if (event.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DBLCLICK) {
            pass = false;
        }
        return super.handleEvent(event) && pass;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleDownEvent(event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
            this.downPx_ = event.pixel;
            if (!this.finishCoordinate_) {
                this.startDrawing_(event.coordinate);
            }
            return true;
        }
        if (!this.condition_(event)) {
            this.lastDragTime_ = undefined;
            return false;
        }
        this.lastDragTime_ = Date.now();
        this.downTimeout_ = setTimeout(()=>{
            this.handlePointerMove_(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$MapBrowserEventType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
        }, this.dragVertexDelay_);
        this.downPx_ = event.pixel;
        return true;
    }
    /**
   * @private
   */ deactivateTrace_() {
        this.traceState_ = {
            active: false
        };
    }
    /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ toggleTraceState_(event) {
        if (!this.traceSource_ || !this.traceCondition_(event)) {
            return;
        }
        if (this.traceState_.active) {
            this.deactivateTrace_();
            return;
        }
        const map = this.getMap();
        const lowerLeft = map.getCoordinateFromPixel([
            event.pixel[0] - this.snapTolerance_,
            event.pixel[1] + this.snapTolerance_
        ]);
        const upperRight = map.getCoordinateFromPixel([
            event.pixel[0] + this.snapTolerance_,
            event.pixel[1] - this.snapTolerance_
        ]);
        const extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])([
            lowerLeft,
            upperRight
        ]);
        const features = this.traceSource_.getFeaturesInExtent(extent);
        if (features.length === 0) {
            return;
        }
        const targets = getTraceTargets(event.coordinate, features);
        if (targets.length) {
            this.traceState_ = {
                active: true,
                startPx: event.pixel.slice(),
                targets: targets,
                targetIndex: -1
            };
        }
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */ addOrRemoveTracedCoordinates_(target, endIndex) {
        // three cases to handle:
        //  1. traced in the same direction and points need adding
        //  2. traced in the same direction and points need removing
        //  3. traced in a new direction
        const previouslyForward = target.startIndex <= target.endIndex;
        const currentlyForward = target.startIndex <= endIndex;
        if (previouslyForward === currentlyForward) {
            // same direction
            if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) {
                // case 1 - add new points
                this.addTracedCoordinates_(target, target.endIndex, endIndex);
            } else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) {
                // case 2 - remove old points
                this.removeTracedCoordinates_(endIndex, target.endIndex);
            }
        } else {
            // case 3 - remove old points, add new points
            this.removeTracedCoordinates_(target.startIndex, target.endIndex);
            this.addTracedCoordinates_(target, target.startIndex, endIndex);
        }
    }
    /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ removeTracedCoordinates_(fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return;
        }
        let remove = 0;
        if (fromIndex < toIndex) {
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) {
                end -= 1;
            }
            remove = end - start + 1;
        } else {
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) {
                end += 1;
            }
            remove = start - end + 1;
        }
        if (remove > 0) {
            this.removeLastPoints_(remove);
        }
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ addTracedCoordinates_(target, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return;
        }
        const coordinates = [];
        if (fromIndex < toIndex) {
            // forward trace
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) {
                // if end is snapped to a vertex, it will be added later
                end -= 1;
            }
            for(let i = start; i <= end; ++i){
                coordinates.push(getCoordinate(target.coordinates, i));
            }
        } else {
            // reverse trace
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) {
                end += 1;
            }
            for(let i = start; i >= end; --i){
                coordinates.push(getCoordinate(target.coordinates, i));
            }
        }
        if (coordinates.length) {
            this.appendCoordinates(coordinates);
        }
    }
    /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ updateTrace_(event) {
        const traceState = this.traceState_;
        if (!traceState.active) {
            return;
        }
        if (traceState.targetIndex === -1) {
            // check if we are ready to pick a target
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(traceState.startPx, event.pixel) < this.snapTolerance_) {
                return;
            }
        }
        const updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);
        if (traceState.targetIndex !== updatedTraceTarget.index) {
            // target changed
            if (traceState.targetIndex !== -1) {
                // remove points added during previous trace
                const oldTarget = traceState.targets[traceState.targetIndex];
                this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
            }
            // add points for the new target
            const newTarget = traceState.targets[updatedTraceTarget.index];
            this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);
        } else {
            // target stayed the same
            const target = traceState.targets[traceState.targetIndex];
            this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);
        }
        // modify the state with updated info
        traceState.targetIndex = updatedTraceTarget.index;
        const target = traceState.targets[traceState.targetIndex];
        target.endIndex = updatedTraceTarget.endIndex;
        // update event coordinate and pixel to match end point of final segment
        const coordinate = interpolateCoordinate(target.coordinates, target.endIndex);
        const pixel = this.getMap().getPixelFromCoordinate(coordinate);
        event.coordinate = coordinate;
        event.pixel = [
            Math.round(pixel[0]),
            Math.round(pixel[1])
        ];
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   * @override
   */ handleUpEvent(event) {
        let pass = true;
        if (this.getPointerCount() === 0) {
            if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
            this.handlePointerMove_(event);
            const tracing = this.traceState_.active;
            this.toggleTraceState_(event);
            if (this.shouldHandle_) {
                const startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) {
                    this.startDrawing_(event.coordinate);
                }
                if (!startingToDraw && this.freehand_) {
                    this.finishDrawing();
                } else if (!this.freehand_ && (!startingToDraw || this.mode_ === 'Point')) {
                    if (this.atFinish_(event.pixel, tracing)) {
                        if (this.finishCondition_(event)) {
                            this.finishDrawing();
                        }
                    } else {
                        this.addToDrawing_(event.coordinate);
                    }
                }
                pass = false;
            } else if (this.freehand_) {
                this.abortDrawing();
            }
        }
        if (!pass && this.stopClick_) {
            event.preventDefault();
        }
        return pass;
    }
    /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */ handlePointerMove_(event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const downPx = this.downPx_;
            const clickPx = event.pixel;
            const dx = downPx[0] - clickPx[0];
            const dy = downPx[1] - clickPx[1];
            const squaredDistance = dx * dx + dy * dy;
            this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
            if (!this.shouldHandle_) {
                return;
            }
        }
        if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(event.coordinate.slice());
            return;
        }
        this.updateTrace_(event);
        this.modifyDrawing_(event.coordinate);
    }
    /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */ atFinish_(pixel, tracing) {
        let at = false;
        if (this.sketchFeature_) {
            let potentiallyDone = false;
            let potentiallyFinishCoordinates = [
                this.finishCoordinate_
            ];
            const mode = this.mode_;
            if (mode === 'Point') {
                at = true;
            } else if (mode === 'Circle') {
                at = this.sketchCoords_.length === 2;
            } else if (mode === 'LineString') {
                potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
            } else if (mode === 'Polygon') {
                const sketchCoords = this.sketchCoords_;
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2]
                ];
                if (tracing) {
                    potentiallyFinishCoordinates = [
                        sketchCoords[0][0]
                    ];
                } else {
                    potentiallyFinishCoordinates = [
                        sketchCoords[0][0],
                        sketchCoords[0][sketchCoords[0].length - 2]
                    ];
                }
            }
            if (potentiallyDone) {
                const map = this.getMap();
                for(let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++){
                    const finishCoordinate = potentiallyFinishCoordinates[i];
                    const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                    const dx = pixel[0] - finishPixel[0];
                    const dy = pixel[1] - finishPixel[1];
                    const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                    if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                    }
                }
            }
        }
        return at;
    }
    /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */ createOrUpdateSketchPoint_(coordinates) {
        if (!this.sketchPoint_) {
            this.sketchPoint_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](coordinates));
            this.updateSketchFeatures_();
        } else {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinates);
        }
    }
    /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */ createOrUpdateCustomSketchLine_(geometry) {
        if (!this.sketchLine_) {
            this.sketchLine_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        }
        const ring = geometry.getLinearRing(0);
        let sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
            sketchLineGeom = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
        } else {
            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
        }
    }
    /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */ startDrawing_(start) {
        const projection = this.getMap().getView().getProjection();
        const stride = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStrideForLayout"])(this.geometryLayout_);
        while(start.length < stride){
            start.push(0);
        }
        this.finishCoordinate_ = start;
        if (this.mode_ === 'Point') {
            this.sketchCoords_ = start.slice();
        } else if (this.mode_ === 'Polygon') {
            this.sketchCoords_ = [
                [
                    start.slice(),
                    start.slice()
                ]
            ];
            this.sketchLineCoords_ = this.sketchCoords_[0];
        } else {
            this.sketchCoords_ = [
                start.slice(),
                start.slice()
            ];
        }
        if (this.sketchLineCoords_) {
            this.sketchLine_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$LineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.sketchLineCoords_));
        }
        const geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
        this.sketchFeature_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        if (this.geometryName_) {
            this.sketchFeature_.setGeometryName(this.geometryName_);
        }
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */ modifyDrawing_(coordinate) {
        const map = this.getMap();
        const geometry = this.sketchFeature_.getGeometry();
        const projection = map.getView().getProjection();
        const stride = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$SimpleGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStrideForLayout"])(this.geometryLayout_);
        let coordinates, last;
        while(coordinate.length < stride){
            coordinate.push(0);
        }
        if (this.mode_ === 'Point') {
            last = this.sketchCoords_;
        } else if (this.mode_ === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            last = coordinates[coordinates.length - 1];
            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
                // snap to finish
                coordinate = this.finishCoordinate_.slice();
            }
        } else {
            coordinates = this.sketchCoords_;
            last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
        if (this.sketchPoint_) {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {
            this.createOrUpdateCustomSketchLine_(geometry);
        } else if (this.sketchLineCoords_) {
            const sketchLineGeom = this.sketchLine_.getGeometry();
            sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
    }
    /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
   * @private
   */ addToDrawing_(coordinate) {
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        let done;
        let coordinates;
        const mode = this.mode_;
        if (mode === 'LineString' || mode === 'Circle') {
            this.finishCoordinate_ = coordinate.slice();
            coordinates = this.sketchCoords_;
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                    coordinates.pop();
                } else {
                    done = true;
                }
            }
            coordinates.push(coordinate.slice());
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (mode === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                    coordinates.pop();
                } else {
                    done = true;
                }
            }
            coordinates.push(coordinate.slice());
            if (done) {
                this.finishCoordinate_ = coordinates[0];
            }
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) {
            return this.finishDrawing();
        }
        return this.sketchFeature_;
    }
    /**
   * @param {number} n The number of points to remove.
   */ removeLastPoints_(n) {
        if (!this.sketchFeature_) {
            return;
        }
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        const mode = this.mode_;
        for(let i = 0; i < n; ++i){
            let coordinates;
            if (mode === 'LineString' || mode === 'Circle') {
                coordinates = this.sketchCoords_;
                coordinates.splice(-2, 1);
                if (coordinates.length >= 2) {
                    this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                    const finishCoordinate = this.finishCoordinate_.slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                this.geometryFunction_(coordinates, geometry, projection);
                if (geometry.getType() === 'Polygon' && this.sketchLine_) {
                    this.createOrUpdateCustomSketchLine_(geometry);
                }
            } else if (mode === 'Polygon') {
                coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
                coordinates.splice(-2, 1);
                const sketchLineGeom = this.sketchLine_.getGeometry();
                if (coordinates.length >= 2) {
                    const finishCoordinate = coordinates[coordinates.length - 2].slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                sketchLineGeom.setCoordinates(coordinates);
                this.geometryFunction_(this.sketchCoords_, geometry, projection);
            }
            if (coordinates.length === 1) {
                this.abortDrawing();
                break;
            }
        }
        this.updateSketchFeatures_();
    }
    /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */ removeLastPoint() {
        this.removeLastPoints_(1);
    }
    /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
   * @api
   */ finishDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (!sketchFeature) {
            return null;
        }
        let coordinates = this.sketchCoords_;
        const geometry = sketchFeature.getGeometry();
        const projection = this.getMap().getView().getProjection();
        if (this.mode_ === 'LineString') {
            // remove the redundant last point
            coordinates.pop();
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (this.mode_ === 'Polygon') {
            // remove the redundant last point in ring
            /** @type {PolyCoordType} */ coordinates[0].pop();
            this.geometryFunction_(coordinates, geometry, projection);
            coordinates = geometry.getCoordinates();
        }
        // cast multi-part geometries
        if (this.type_ === 'MultiPoint') {
            sketchFeature.setGeometry(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPoint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
                coordinates
            ]));
        } else if (this.type_ === 'MultiLineString') {
            sketchFeature.setGeometry(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiLineString$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
                coordinates
            ]));
        } else if (this.type_ === 'MultiPolygon') {
            sketchFeature.setGeometry(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$MultiPolygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
                coordinates
            ]));
        }
        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
        // Then insert feature
        if (this.features_) {
            this.features_.push(sketchFeature);
        }
        if (this.source_) {
            this.source_.addFeature(sketchFeature);
        }
        return sketchFeature;
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */ abortDrawing_() {
        this.finishCoordinate_ = null;
        const sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        this.deactivateTrace_();
        return sketchFeature;
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */ abortDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (sketchFeature) {
            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
        }
    }
    /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */ appendCoordinates(coordinates) {
        const mode = this.mode_;
        const newDrawing = !this.sketchFeature_;
        if (newDrawing) {
            this.startDrawing_(coordinates[0]);
        }
        /** @type {LineCoordType} */ let sketchCoords;
        if (mode === 'LineString' || mode === 'Circle') {
            sketchCoords = this.sketchCoords_;
        } else if (mode === 'Polygon') {
            sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */ this.sketchCoords_[0] : [];
        } else {
            return;
        }
        if (newDrawing) {
            sketchCoords.shift();
        }
        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
        sketchCoords.pop();
        // Append coordinate list
        for(let i = 0; i < coordinates.length; i++){
            this.addToDrawing_(coordinates[i]);
        }
        const ending = coordinates[coordinates.length - 1];
        // Duplicate last coordinate for sketch drawing (cursor position)
        this.sketchFeature_ = this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
    }
    /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */ extend(feature) {
        const geometry = feature.getGeometry();
        const lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        const last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$Feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](last));
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Redraw the sketch features.
   * @private
   */ updateSketchFeatures_() {
        const sketchFeatures = [];
        if (this.sketchFeature_) {
            sketchFeatures.push(this.sketchFeature_);
        }
        if (this.sketchLine_) {
            sketchFeatures.push(this.sketchLine_);
        }
        if (this.sketchPoint_) {
            sketchFeatures.push(this.sketchPoint_);
        }
        const overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
    }
    /**
   * @private
   */ updateState_() {
        const map = this.getMap();
        const active = this.getActive();
        if (!map || !active) {
            this.abortDrawing();
        }
        this.overlay_.setMap(active ? map : null);
    }
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const styles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$style$2f$Style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditingStyle"])();
    return function(feature, resolution) {
        return styles[feature.getGeometry().getType()];
    };
}
function createRegularPolygon(sides, angle) {
    return function(coordinates, geometry, projection) {
        const center = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(/** @type {LineCoordType} */ coordinates[0], projection);
        const end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(/** @type {LineCoordType} */ coordinates[coordinates.length - 1], projection);
        const radius = Math.sqrt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squaredDistance"])(center, end));
        geometry = geometry || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCircle"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](center), sides);
        let internalAngle = angle;
        if (!angle && angle !== 0) {
            const x = end[0] - center[0];
            const y = end[1] - center[1];
            internalAngle = Math.atan2(y, x);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeRegular"])(geometry, center, radius, internalAngle);
        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
        if (userProjection) {
            geometry.transform(projection, userProjection);
        }
        return geometry;
    };
}
function createBox() {
    return function(coordinates, geometry, projection) {
        const extent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boundingExtent"])(/** @type {LineCoordType} */ [
            coordinates[0],
            coordinates[coordinates.length - 1]
        ].map(function(coordinate) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromUserCoordinate"])(coordinate, projection);
        }));
        const boxCoordinates = [
            [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBottomLeft"])(extent),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBottomRight"])(extent),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTopRight"])(extent),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTopLeft"])(extent),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBottomLeft"])(extent)
            ]
        ];
        if (geometry) {
            geometry.setCoordinates(boxCoordinates);
        } else {
            geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$geom$2f$Polygon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](boxCoordinates);
        }
        const userProjection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ol$2f$proj$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getUserProjection"])();
        if (userProjection) {
            geometry.transform(projection, userProjection);
        }
        return geometry;
    };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */ function getMode(type) {
    switch(type){
        case 'Point':
        case 'MultiPoint':
            return 'Point';
        case 'LineString':
        case 'MultiLineString':
            return 'LineString';
        case 'Polygon':
        case 'MultiPolygon':
            return 'Polygon';
        case 'Circle':
            return 'Circle';
        default:
            throw new Error('Invalid type: ' + type);
    }
}
const __TURBOPACK__default__export__ = Draw;
}}),
}]);

//# sourceMappingURL=node_modules_ol_interaction_f661b8._.js.map