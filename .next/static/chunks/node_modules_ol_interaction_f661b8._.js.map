{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Property.js"],"sourcesContent":["/**\n * @module ol/interaction/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  ACTIVE: 'active',\n};\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;uCACc;IACb,QAAQ;AACV","ignoreList":[0]}},
    {"offset": {"line": 17, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Interaction.js"],"sourcesContent":["/**\n * @module ol/interaction/Interaction\n */\nimport BaseObject from '../Object.js';\nimport {easeOut, linear} from '../easing.js';\nimport InteractionProperty from './Property.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active', Return>} InteractionOnSignature\n */\n\n/**\n * Object literal with config options for interactions.\n * @typedef {Object} InteractionOptions\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. If the function returns a falsy value, propagation of\n * the event to other interactions in the map's interactions chain will be\n * prevented (this includes functions with no explicit return). The interactions\n * are traversed in reverse order of the interactions collection of the map.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * User actions that change the state of the map. Some are similar to controls,\n * but are not associated with a DOM element.\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n * by a keyboard event not a button element event.\n * Although interactions do not have a DOM element, some of them do render\n * vectors and so are visible on the screen.\n * @api\n */\nclass Interaction extends BaseObject {\n  /**\n   * @param {InteractionOptions} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {InteractionOnSignature<void>}\n     */\n    this.un;\n\n    if (options && options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    this.setActive(true);\n  }\n\n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n  getActive() {\n    return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\n  }\n\n  /**\n   * Get the map associated with this interaction.\n   * @return {import(\"../Map.js\").default|null} Map.\n   * @api\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    return true;\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMap(map) {\n    this.map_ = map;\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\n * @param {number} [duration] Duration.\n */\nexport function pan(view, delta, duration) {\n  const currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: duration !== undefined ? duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center),\n    });\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {number} delta Delta from previous zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} [anchor] Anchor coordinate in the user projection.\n * @param {number} [duration] Duration.\n */\nexport function zoomByDelta(view, delta, anchor, duration) {\n  const currentZoom = view.getZoom();\n\n  if (currentZoom === undefined) {\n    return;\n  }\n\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\n  const newResolution = view.getResolutionForZoom(newZoom);\n\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: anchor,\n    duration: duration !== undefined ? duration : 250,\n    easing: easeOut,\n  });\n}\n\nexport default Interaction;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;AAGD;AAFA;AACA;;;;AAGA;;;;;;;CAOC,GAED;;;;;;;;;CASC,GAED;;;;;;;;;;;;CAYC,GACD,MAAM,oBAAoB,+HAAA,CAAA,UAAU;IAClC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK;QAEL;;KAEC,GACD,IAAI,CAAC,EAAE;QAEP;;KAEC,GACD,IAAI,CAAC,IAAI;QAET;;KAEC,GACD,IAAI,CAAC,EAAE;QAEP,IAAI,WAAW,QAAQ,WAAW,EAAE;YAClC,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW;QACxC;QAEA;;;KAGC,GACD,IAAI,CAAC,IAAI,GAAG;QAEZ,IAAI,CAAC,SAAS,CAAC;IACjB;IAEA;;;;;GAKC,GACD,YAAY;QACV,OAA+B,IAAI,CAAC,GAAG,CAAC,gJAAA,CAAA,UAAmB,CAAC,MAAM;IACpE;IAEA;;;;GAIC,GACD,SAAS;QACP,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA;;;;;GAKC,GACD,YAAY,eAAe,EAAE;QAC3B,OAAO;IACT;IAEA;;;;;GAKC,GACD,UAAU,MAAM,EAAE;QAChB,IAAI,CAAC,GAAG,CAAC,gJAAA,CAAA,UAAmB,CAAC,MAAM,EAAE;IACvC;IAEA;;;;;GAKC,GACD,OAAO,GAAG,EAAE;QACV,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAOO,SAAS,IAAI,IAAI,EAAE,KAAK,EAAE,QAAQ;IACvC,MAAM,gBAAgB,KAAK,iBAAiB;IAC5C,IAAI,eAAe;QACjB,MAAM,SAAS;YAAC,aAAa,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;YAAE,aAAa,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;SAAC;QACzE,KAAK,eAAe,CAAC;YACnB,UAAU,aAAa,YAAY,WAAW;YAC9C,QAAQ,+HAAA,CAAA,SAAM;YACd,QAAQ,KAAK,oBAAoB,CAAC;QACpC;IACF;AACF;AAQO,SAAS,YAAY,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ;IACvD,MAAM,cAAc,KAAK,OAAO;IAEhC,IAAI,gBAAgB,WAAW;QAC7B;IACF;IAEA,MAAM,UAAU,KAAK,kBAAkB,CAAC,cAAc;IACtD,MAAM,gBAAgB,KAAK,oBAAoB,CAAC;IAEhD,IAAI,KAAK,YAAY,IAAI;QACvB,KAAK,gBAAgB;IACvB;IACA,KAAK,OAAO,CAAC;QACX,YAAY;QACZ,QAAQ;QACR,UAAU,aAAa,YAAY,WAAW;QAC9C,QAAQ,+HAAA,CAAA,UAAO;IACjB;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Pointer.js"],"sourcesContent":["/**\n * @module ol/interaction/Pointer\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Interaction from './Interaction.js';\n\n/**\n * @typedef {Object} Options\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\n * Function handling \"down\" events. If the function returns `true` then a drag\n * sequence is started.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\n * Function handling \"drag\" events. This function is called on \"move\" events\n * during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. The function may return `false` to prevent the\n * propagation of the event to other interactions in the map's interactions\n * chain.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\n * Function handling \"move\" events. This function is called on \"move\" events.\n * This functions is also called during a drag sequence, so during a drag\n * sequence both the `handleDragEvent` function and this function are called.\n * If `handleDownEvent` is defined and it returns true this function will not\n * be called during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\n *  Function handling \"up\" events. If the function returns `false` then the\n * current drag sequence is stopped.\n * @property {function(boolean):boolean} [stopDown]\n * Should the down event be propagated to other interactions, or should be\n * stopped?\n */\n\n/**\n * @classdesc\n * Base class that calls user-defined functions on `down`, `move` and `up`\n * events. This class also manages \"drag sequences\".\n *\n * When the `handleDownEvent` user function returns `true` a drag sequence is\n * started. During a drag sequence the `handleDragEvent` user function is\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\n * user function is called and returns `false`.\n * @api\n */\nclass PointerInteraction extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options),\n    );\n\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n\n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.handlingDownUpSequence = false;\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @protected\n     */\n    this.targetPointers = [];\n  }\n\n  /**\n   * Returns the current number of pointers involved in the interaction,\n   * e.g. `2` when two fingers are used.\n   * @return {number} The number of pointers.\n   * @api\n   */\n  getPointerCount() {\n    return this.targetPointers.length;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleDownEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleDragEvent(mapBrowserEvent) {}\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n   * detected.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n\n    let stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        // prevent page scrolling during dragging\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence =\n          handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        const handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleMoveEvent(mapBrowserEvent) {}\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleUpEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * This function is used to determine if \"down\" events should be propagated\n   * to other interactions or should be stopped.\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the `down` event be stopped?\n   */\n  stopDown(handled) {\n    return handled;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @private\n   */\n  updateTrackedPointers_(mapBrowserEvent) {\n    if (mapBrowserEvent.activePointers) {\n      this.targetPointers = mapBrowserEvent.activePointers;\n    }\n  }\n}\n\n/**\n * @param {Array<PointerEvent>} pointerEvents List of events.\n * @return {{clientX: number, clientY: number}} Centroid pixel.\n */\nexport function centroid(pointerEvents) {\n  const length = pointerEvents.length;\n  let clientX = 0;\n  let clientY = 0;\n  for (let i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n  return {clientX: clientX / length, clientY: clientY / length};\n}\n\nexport default PointerInteraction;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/DragRotate.js"],"sourcesContent":["/**\n * @module ol/interaction/DragRotate\n */\nimport {\n  altShiftKeysOnly,\n  mouseActionButton,\n  mouseOnly,\n} from '../events/condition.js';\nimport {FALSE} from '../functions.js';\nimport {disable} from '../rotationconstraint.js';\nimport PointerInteraction from './Pointer.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.altShiftKeysOnly}.\n * @property {number} [duration=250] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by clicking and dragging on the map,\n * normally combined with a {@link module:ol/events/condition} that limits\n * it to when the alt and shift keys are held down.\n *\n * This interaction is only supported for mouse devices.\n * @api\n */\nclass DragRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      stopDown: FALSE,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @override\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    const size = map.getSize();\n    const offset = mapBrowserEvent.pixel;\n    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      const delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n\n    if (\n      mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)\n    ) {\n      const map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = undefined;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragRotate;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAMD;AALA;AAMA;AACA;;;;;AAEA;;;;;;;CAOC,GAED;;;;;;;;CAQC,GACD,MAAM,mBAAmB,+IAAA,CAAA,UAAkB;IACzC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,UAAU,UAAU,UAAU,CAAC;QAE/B,KAAK,CAAC;YACJ,UAAU,kIAAA,CAAA,QAAK;QACjB;QAEA;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG,QAAQ,SAAS,GAAG,QAAQ,SAAS,GAAG,4IAAA,CAAA,mBAAgB;QAE1E;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG;QAElB;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;IACvE;IAEA;;;;GAIC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,CAAC,CAAA,GAAA,4IAAA,CAAA,YAAS,AAAD,EAAE,kBAAkB;YAC/B;QACF;QAEA,MAAM,MAAM,gBAAgB,GAAG;QAC/B,MAAM,OAAO,IAAI,OAAO;QACxB,IAAI,KAAK,cAAc,GAAG,QAAQ,KAAK,2IAAA,CAAA,UAAO,EAAE;YAC9C;QACF;QACA,MAAM,OAAO,IAAI,OAAO;QACxB,MAAM,SAAS,gBAAgB,KAAK;QACpC,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,GAAG;QACxE,IAAI,IAAI,CAAC,UAAU,KAAK,WAAW;YACjC,MAAM,QAAQ,QAAQ,IAAI,CAAC,UAAU;YACrC,KAAK,sBAAsB,CAAC,CAAC;QAC/B;QACA,IAAI,CAAC,UAAU,GAAG;IACpB;IAEA;;;;;GAKC,GACD,cAAc,eAAe,EAAE;QAC7B,IAAI,CAAC,CAAA,GAAA,4IAAA,CAAA,YAAS,AAAD,EAAE,kBAAkB;YAC/B,OAAO;QACT;QAEA,MAAM,MAAM,gBAAgB,GAAG;QAC/B,MAAM,OAAO,IAAI,OAAO;QACxB,KAAK,cAAc,CAAC,IAAI,CAAC,SAAS;QAClC,OAAO;IACT;IAEA;;;;;GAKC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,CAAC,CAAA,GAAA,4IAAA,CAAA,YAAS,AAAD,EAAE,kBAAkB;YAC/B,OAAO;QACT;QAEA,IACE,CAAA,GAAA,4IAAA,CAAA,oBAAiB,AAAD,EAAE,oBAClB,IAAI,CAAC,UAAU,CAAC,kBAChB;YACA,MAAM,MAAM,gBAAgB,GAAG;YAC/B,IAAI,OAAO,GAAG,gBAAgB;YAC9B,IAAI,CAAC,UAAU,GAAG;YAClB,OAAO;QACT;QACA,OAAO;IACT;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 455, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/DoubleClickZoom.js"],"sourcesContent":["/**\n * @module ol/interaction/DoubleClickZoom\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [delta=1] The zoom delta applied on each double click.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom by double-clicking on the map.\n * @api\n */\nclass DoubleClickZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a\n   * doubleclick) and eventually zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      const browserEvent = /** @type {MouseEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const map = mapBrowserEvent.map;\n      const anchor = mapBrowserEvent.coordinate;\n      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      const view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  }\n}\n\nexport default DoubleClickZoom;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AACD;AACA;;;AAEA;;;;CAIC,GAED;;;;CAIC,GACD,MAAM,wBAAwB,mJAAA,CAAA,UAAW;IACvC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK;QAEL,UAAU,UAAU,UAAU,CAAC;QAE/B;;;KAGC,GACD,IAAI,CAAC,MAAM,GAAG,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG;QAE9C;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;IACvE;IAEA;;;;;;GAMC,GACD,YAAY,eAAe,EAAE;QAC3B,IAAI,YAAY;QAChB,IAAI,gBAAgB,IAAI,IAAI,4IAAA,CAAA,UAAmB,CAAC,QAAQ,EAAE;YACxD,MAAM,eACJ,gBAAgB,aAAa;YAE/B,MAAM,MAAM,gBAAgB,GAAG;YAC/B,MAAM,SAAS,gBAAgB,UAAU;YACzC,MAAM,QAAQ,aAAa,QAAQ,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;YAChE,MAAM,OAAO,IAAI,OAAO;YACxB,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,MAAM,OAAO,QAAQ,IAAI,CAAC,SAAS;YAC/C,aAAa,cAAc;YAC3B,YAAY;QACd;QACA,OAAO,CAAC;IACV;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/DragPan.js"],"sourcesContent":["/**\n * @module ol/interaction/DragPan\n */\nimport {\n  rotate as rotateCoordinate,\n  scale as scaleCoordinate,\n} from '../coordinate.js';\nimport {easeOut} from '../easing.js';\nimport {\n  all,\n  focusWithTabindex,\n  noModifierKeys,\n  primaryAction,\n} from '../events/condition.js';\nimport {FALSE} from '../functions.js';\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nclass DragPan extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super({\n      stopDown: FALSE,\n    });\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.lastPointersCount_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.panning_ = false;\n\n    const condition = options.condition\n      ? options.condition\n      : all(noModifierKeys, primaryAction);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @override\n   */\n  handleDragEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    if (!this.panning_) {\n      this.panning_ = true;\n      map.getView().beginInteraction();\n    }\n    const targetPointers = this.targetPointers;\n    const centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        const delta = [\n          this.lastCentroid[0] - centroid[0],\n          centroid[1] - this.lastCentroid[1],\n        ];\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        const distance = this.kinetic_.getDistance();\n        const angle = this.kinetic_.getAngle();\n        const center = view.getCenterInternal();\n        const centerpx = map.getPixelFromCoordinateInternal(center);\n        const dest = map.getCoordinateFromPixelInternal([\n          centerpx[0] - distance * Math.cos(angle),\n          centerpx[1] - distance * Math.sin(angle),\n        ]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut,\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    }\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragPan;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/PinchRotate.js"],"sourcesContent":["/**\n * @module ol/interaction/PinchRotate\n */\nimport {FALSE} from '../functions.js';\nimport {disable} from '../rotationconstraint.js';\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @override\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(\n      touch1.clientY - touch0.clientY,\n      touch1.clientX - touch0.clientX,\n    );\n\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers)),\n    );\n\n    // rotate\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchRotate;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AACD;AACA;AACA;;;;AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD,MAAM,oBAAoB,+IAAA,CAAA,UAAkB;IAC1C;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,UAAU,UAAU,UAAU,CAAC;QAE/B,MAAM,iBACJ;QAGF,IAAI,CAAC,eAAe,QAAQ,EAAE;YAC5B,eAAe,QAAQ,GAAG,kIAAA,CAAA,QAAK;QACjC;QAEA,KAAK,CAAC;QAEN;;;KAGC,GACD,IAAI,CAAC,OAAO,GAAG;QAEf;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG;QAElB;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG;QAEjB;;;KAGC,GACD,IAAI,CAAC,cAAc,GAAG;QAEtB;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG,QAAQ,SAAS,KAAK,YAAY,QAAQ,SAAS,GAAG;QAExE;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;IACvE;IAEA;;;;GAIC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,gBAAgB;QAEpB,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,EAAE;QACrC,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,EAAE;QAErC,wBAAwB;QACxB,MAAM,QAAQ,KAAK,KAAK,CACtB,OAAO,OAAO,GAAG,OAAO,OAAO,EAC/B,OAAO,OAAO,GAAG,OAAO,OAAO;QAGjC,IAAI,IAAI,CAAC,UAAU,KAAK,WAAW;YACjC,MAAM,QAAQ,QAAQ,IAAI,CAAC,UAAU;YACrC,IAAI,CAAC,cAAc,IAAI;YACvB,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,UAAU,EAAE;gBACtE,IAAI,CAAC,SAAS,GAAG;YACnB;YACA,gBAAgB;QAClB;QACA,IAAI,CAAC,UAAU,GAAG;QAElB,MAAM,MAAM,gBAAgB,GAAG;QAC/B,MAAM,OAAO,IAAI,OAAO;QACxB,IAAI,KAAK,cAAc,GAAG,QAAQ,KAAK,2IAAA,CAAA,UAAO,EAAE;YAC9C;QACF;QAEA,uBAAuB;QACvB,6DAA6D;QAC7D,sDAAsD;QACtD,IAAI,CAAC,OAAO,GAAG,IAAI,8BAA8B,CAC/C,IAAI,aAAa,CAAC,CAAA,GAAA,+IAAA,CAAA,WAAoB,AAAD,EAAE,IAAI,CAAC,cAAc;QAG5D,SAAS;QACT,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,MAAM;YACV,KAAK,sBAAsB,CAAC,eAAe,IAAI,CAAC,OAAO;QACzD;IACF;IAEA;;;;;GAKC,GACD,cAAc,eAAe,EAAE;QAC7B,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,GAAG;YAClC,MAAM,MAAM,gBAAgB,GAAG;YAC/B,MAAM,OAAO,IAAI,OAAO;YACxB,KAAK,cAAc,CAAC,IAAI,CAAC,SAAS;YAClC,OAAO;QACT;QACA,OAAO;IACT;IAEA;;;;;GAKC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,IAAI,GAAG;YACnC,MAAM,MAAM,gBAAgB,GAAG;YAC/B,IAAI,CAAC,OAAO,GAAG;YACf,IAAI,CAAC,UAAU,GAAG;YAClB,IAAI,CAAC,SAAS,GAAG;YACjB,IAAI,CAAC,cAAc,GAAG;YACtB,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAAE;gBAChC,IAAI,OAAO,GAAG,gBAAgB;YAChC;YACA,OAAO;QACT;QACA,OAAO;IACT;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/PinchZoom.js"],"sourcesContent":["/**\n * @module ol/interaction/PinchZoom\n */\nimport {FALSE} from '../functions.js';\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=400] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by pinching with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchZoom extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastDistance_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 1;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @override\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let scaleDelta = 1.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n    const dx = touch0.clientX - touch1.clientX;\n    const dy = touch0.clientY - touch1.clientY;\n\n    // distance between touches\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n\n    // scale anchor point.\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers)),\n    );\n\n    // scale, bypass the resolution constraint\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchZoom;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AACD;AACA;;;AAIA;;;CAGC,GAED;;;;;CAKC,GACD,MAAM,kBAAkB,+IAAA,CAAA,UAAkB;IACxC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,UAAU,UAAU,UAAU,CAAC;QAE/B,MAAM,iBACJ;QAGF,IAAI,CAAC,eAAe,QAAQ,EAAE;YAC5B,eAAe,QAAQ,GAAG,kIAAA,CAAA,QAAK;QACjC;QAEA,KAAK,CAAC;QAEN;;;KAGC,GACD,IAAI,CAAC,OAAO,GAAG;QAEf;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;QAErE;;;KAGC,GACD,IAAI,CAAC,aAAa,GAAG;QAErB;;;KAGC,GACD,IAAI,CAAC,eAAe,GAAG;IACzB;IAEA;;;;GAIC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,aAAa;QAEjB,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,EAAE;QACrC,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,EAAE;QACrC,MAAM,KAAK,OAAO,OAAO,GAAG,OAAO,OAAO;QAC1C,MAAM,KAAK,OAAO,OAAO,GAAG,OAAO,OAAO;QAE1C,2BAA2B;QAC3B,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;QAE1C,IAAI,IAAI,CAAC,aAAa,KAAK,WAAW;YACpC,aAAa,IAAI,CAAC,aAAa,GAAG;QACpC;QACA,IAAI,CAAC,aAAa,GAAG;QAErB,MAAM,MAAM,gBAAgB,GAAG;QAC/B,MAAM,OAAO,IAAI,OAAO;QAExB,IAAI,cAAc,KAAK;YACrB,IAAI,CAAC,eAAe,GAAG;QACzB;QAEA,sBAAsB;QACtB,IAAI,CAAC,OAAO,GAAG,IAAI,8BAA8B,CAC/C,IAAI,aAAa,CAAC,CAAA,GAAA,+IAAA,CAAA,WAAoB,AAAD,EAAE,IAAI,CAAC,cAAc;QAG5D,0CAA0C;QAC1C,IAAI,MAAM;QACV,KAAK,wBAAwB,CAAC,YAAY,IAAI,CAAC,OAAO;IACxD;IAEA;;;;;GAKC,GACD,cAAc,eAAe,EAAE;QAC7B,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,GAAG;YAClC,MAAM,MAAM,gBAAgB,GAAG;YAC/B,MAAM,OAAO,IAAI,OAAO;YACxB,MAAM,YAAY,IAAI,CAAC,eAAe,GAAG,IAAI,IAAI,CAAC;YAClD,KAAK,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE;YACpC,OAAO;QACT;QACA,OAAO;IACT;IAEA;;;;;GAKC,GACD,gBAAgB,eAAe,EAAE;QAC/B,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,IAAI,GAAG;YACnC,MAAM,MAAM,gBAAgB,GAAG;YAC/B,IAAI,CAAC,OAAO,GAAG;YACf,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,eAAe,GAAG;YACvB,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAAE;gBAChC,IAAI,OAAO,GAAG,gBAAgB;YAChC;YACA,OAAO;QACT;QACA,OAAO;IACT;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 924, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/KeyboardPan.js"],"sourcesContent":["/**\n * @module ol/interaction/KeyboardPan\n */\nimport {rotate as rotateCoordinate} from '../coordinate.js';\nimport EventType from '../events/EventType.js';\nimport Key from '../events/Key.js';\nimport {noModifierKeys, targetNotEditable} from '../events/condition.js';\nimport Interaction, {pan} from './Interaction.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.noModifierKeys} and\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n * press.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map using keyboard arrows.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n * @api\n */\nclass KeyboardPan extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return (\n        noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent)\n      );\n    };\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ =\n      options.condition !== undefined\n        ? options.condition\n        : this.defaultCondition_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelDelta_ =\n      options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n   * pressed).\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const key = keyEvent.key;\n      if (\n        this.condition_(mapBrowserEvent) &&\n        (key == Key.DOWN ||\n          key == Key.LEFT ||\n          key == Key.RIGHT ||\n          key == Key.UP)\n      ) {\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        let deltaX = 0,\n          deltaY = 0;\n        if (key == Key.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (key == Key.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (key == Key.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        const delta = [deltaX, deltaY];\n        rotateCoordinate(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardPan;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAID;AAFA;AACA;AAFA;AAIA;;;;;;AAEA;;;;;;;;;;CAUC,GAED;;;;;;;;;;;;CAYC,GACD,MAAM,oBAAoB,mJAAA,CAAA,UAAW;IACnC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK;QAEL,UAAU,WAAW,CAAC;QAEtB;;;;KAIC,GACD,IAAI,CAAC,iBAAiB,GAAG,SAAU,eAAe;YAChD,OACE,CAAA,GAAA,4IAAA,CAAA,iBAAc,AAAD,EAAE,oBAAoB,CAAA,GAAA,4IAAA,CAAA,oBAAiB,AAAD,EAAE;QAEzD;QAEA;;;KAGC,GACD,IAAI,CAAC,UAAU,GACb,QAAQ,SAAS,KAAK,YAClB,QAAQ,SAAS,GACjB,IAAI,CAAC,iBAAiB;QAE5B;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;QAErE;;;KAGC,GACD,IAAI,CAAC,WAAW,GACd,QAAQ,UAAU,KAAK,YAAY,QAAQ,UAAU,GAAG;IAC5D;IAEA;;;;;;;GAOC,GACD,YAAY,eAAe,EAAE;QAC3B,IAAI,YAAY;QAChB,IAAI,gBAAgB,IAAI,IAAI,4IAAA,CAAA,UAAS,CAAC,OAAO,EAAE;YAC7C,MAAM,WACJ,gBAAgB,aAAa;YAE/B,MAAM,MAAM,SAAS,GAAG;YACxB,IACE,IAAI,CAAC,UAAU,CAAC,oBAChB,CAAC,OAAO,sIAAA,CAAA,UAAG,CAAC,IAAI,IACd,OAAO,sIAAA,CAAA,UAAG,CAAC,IAAI,IACf,OAAO,sIAAA,CAAA,UAAG,CAAC,KAAK,IAChB,OAAO,sIAAA,CAAA,UAAG,CAAC,EAAE,GACf;gBACA,MAAM,MAAM,gBAAgB,GAAG;gBAC/B,MAAM,OAAO,IAAI,OAAO;gBACxB,MAAM,gBAAgB,KAAK,aAAa,KAAK,IAAI,CAAC,WAAW;gBAC7D,IAAI,SAAS,GACX,SAAS;gBACX,IAAI,OAAO,sIAAA,CAAA,UAAG,CAAC,IAAI,EAAE;oBACnB,SAAS,CAAC;gBACZ,OAAO,IAAI,OAAO,sIAAA,CAAA,UAAG,CAAC,IAAI,EAAE;oBAC1B,SAAS,CAAC;gBACZ,OAAO,IAAI,OAAO,sIAAA,CAAA,UAAG,CAAC,KAAK,EAAE;oBAC3B,SAAS;gBACX,OAAO;oBACL,SAAS;gBACX;gBACA,MAAM,QAAQ;oBAAC;oBAAQ;iBAAO;gBAC9B,CAAA,GAAA,mIAAA,CAAA,SAAgB,AAAD,EAAE,OAAO,KAAK,WAAW;gBACxC,CAAA,GAAA,mJAAA,CAAA,MAAG,AAAD,EAAE,MAAM,OAAO,IAAI,CAAC,SAAS;gBAC/B,SAAS,cAAc;gBACvB,YAAY;YACd;QACF;QACA,OAAO,CAAC;IACV;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1033, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/KeyboardZoom.js"],"sourcesContent":["/**\n * @module ol/interaction/KeyboardZoom\n */\nimport EventType from '../events/EventType.js';\nimport {platformModifierKey, targetNotEditable} from '../events/condition.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. The default condition is\n * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that\n * the platform modifier key isn't pressed\n * (!{@link module:ol/events/condition.platformModifierKey}).\n * @property {number} [delta=1] The zoom level delta on each key press.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map using keyboard + and -.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n * @api\n */\nclass KeyboardZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition\n      ? options.condition\n      : function (mapBrowserEvent) {\n          return (\n            !platformModifierKey(mapBrowserEvent) &&\n            targetNotEditable(mapBrowserEvent)\n          );\n        };\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n   * key pressed was '+' or '-').\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (\n      mapBrowserEvent.type == EventType.KEYDOWN ||\n      mapBrowserEvent.type == EventType.KEYPRESS\n    ) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const key = keyEvent.key;\n      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {\n        const map = mapBrowserEvent.map;\n        const delta = key === '+' ? this.delta_ : -this.delta_;\n        const view = map.getView();\n        zoomByDelta(view, delta, undefined, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardZoom;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAED;AADA;AAEA;;;;AAEA;;;;;;;;;;CAUC,GAED;;;;;;;;;;;;CAYC,GACD,MAAM,qBAAqB,mJAAA,CAAA,UAAW;IACpC;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK;QAEL,UAAU,UAAU,UAAU,CAAC;QAE/B;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG,QAAQ,SAAS,GAC/B,QAAQ,SAAS,GACjB,SAAU,eAAe;YACvB,OACE,CAAC,CAAA,GAAA,4IAAA,CAAA,sBAAmB,AAAD,EAAE,oBACrB,CAAA,GAAA,4IAAA,CAAA,oBAAiB,AAAD,EAAE;QAEtB;QAEJ;;;KAGC,GACD,IAAI,CAAC,MAAM,GAAG,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG;QAE9C;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;IACvE;IAEA;;;;;;;GAOC,GACD,YAAY,eAAe,EAAE;QAC3B,IAAI,YAAY;QAChB,IACE,gBAAgB,IAAI,IAAI,4IAAA,CAAA,UAAS,CAAC,OAAO,IACzC,gBAAgB,IAAI,IAAI,4IAAA,CAAA,UAAS,CAAC,QAAQ,EAC1C;YACA,MAAM,WACJ,gBAAgB,aAAa;YAE/B,MAAM,MAAM,SAAS,GAAG;YACxB,IAAI,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,QAAQ,OAAO,QAAQ,GAAG,GAAG;gBACpE,MAAM,MAAM,gBAAgB,GAAG;gBAC/B,MAAM,QAAQ,QAAQ,MAAM,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,MAAM;gBACtD,MAAM,OAAO,IAAI,OAAO;gBACxB,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,MAAM,OAAO,WAAW,IAAI,CAAC,SAAS;gBAClD,SAAS,cAAc;gBACvB,YAAY;YACd;QACF;QACA,OAAO,CAAC;IACV;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/MouseWheelZoom.js"],"sourcesContent":["/**\n * @module ol/interaction/MouseWheelZoom\n */\nimport EventType from '../events/EventType.js';\nimport {all, always, focusWithTabindex} from '../events/condition.js';\nimport {DEVICE_PIXEL_RATIO, FIREFOX} from '../has.js';\nimport {clamp} from '../math.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\n\n/**\n * @typedef {'trackpad' | 'wheel'} Mode\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.always}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {number} [maxDelta=1] Maximum mouse wheel delta.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\n * location as the anchor. When set to `false`, zooming in and out will zoom to\n * the center of the screen instead of zooming on the mouse's location.\n * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom\n * event will always animate to the closest zoom level after an interaction;\n * false means intermediary zoom levels are allowed.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by scrolling the mouse wheel.\n * @api\n */\nclass MouseWheelZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options),\n    );\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.totalDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useAnchor_ =\n      options.useAnchor !== undefined ? options.useAnchor : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ =\n      options.constrainResolution !== undefined\n        ? options.constrainResolution\n        : false;\n\n    const condition = options.condition ? options.condition : always;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {?import(\"../pixel.js\").Pixel}\n     */\n    this.lastAnchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.startTime_ = undefined;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.timeoutId_;\n\n    /**\n     * @private\n     * @type {Mode|undefined}\n     */\n    this.mode_ = undefined;\n\n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @private\n     * @type {number}\n     */\n    this.trackpadEventGap_ = 400;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.trackpadTimeoutId_;\n\n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n    this.deltaPerZoom_ = 300;\n  }\n\n  /**\n   * @private\n   */\n  endInteraction_() {\n    this.trackpadTimeoutId_ = undefined;\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const view = map.getView();\n    view.endInteraction(\n      undefined,\n      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,\n      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,\n    );\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n   * zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const wheelEvent = /** @type {WheelEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    wheelEvent.preventDefault();\n\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.pixel;\n    }\n\n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    let delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n\n    if (delta === 0) {\n      return false;\n    }\n    this.lastDelta_ = delta;\n\n    const now = Date.now();\n\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';\n    }\n\n    const view = map.getView();\n    if (\n      this.mode_ === 'trackpad' &&\n      !(view.getConstrainResolution() || this.constrainResolution_)\n    ) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(\n        this.endInteraction_.bind(this),\n        this.timeout_,\n      );\n      view.adjustZoom(\n        -delta / this.deltaPerZoom_,\n        this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,\n      );\n      this.startTime_ = now;\n      return false;\n    }\n\n    this.totalDelta_ += delta;\n\n    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(\n      this.handleWheelZoom_.bind(this, map),\n      timeLeft,\n    );\n\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  handleWheelZoom_(map) {\n    const view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    let delta =\n      -clamp(\n        this.totalDelta_,\n        -this.maxDelta_ * this.deltaPerZoom_,\n        this.maxDelta_ * this.deltaPerZoom_,\n      ) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      // view has a zoom constraint, zoom by 1\n      delta = delta ? (delta > 0 ? 1 : -1) : 0;\n    }\n    zoomByDelta(\n      view,\n      delta,\n      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,\n      this.duration_,\n    );\n\n    this.mode_ = undefined;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  }\n\n  /**\n   * Enable or disable using the mouse's location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\n   * to zoom to the center of the map\n   * @api\n   */\n  setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  }\n}\n\nexport default MouseWheelZoom;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1341, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/DragBox.js"],"sourcesContent":["/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport {mouseActionButton} from '../events/condition.js';\nimport RenderBox from '../render/Box.js';\nimport PointerInteraction from './Pointer.js';\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~mouseActionButton}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default):void} [onBoxEnd] Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\nconst DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend',\n\n  /**\n   * Triggered upon drag box canceled.\n   * @event DragBoxEvent#boxcancel\n   * @api\n   */\n  BOXCANCEL: 'boxcancel',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\nexport class DragBoxEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Originating event.\n   */\n  constructor(type, coordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * @const\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with a {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).\n *\n * @fires DragBoxEvent\n * @api\n */\nclass DragBox extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragBoxOnSignature<void>}\n     */\n    this.un;\n\n    options = options ?? {};\n\n    /**\n     * @type {import(\"../render/Box.js\").default}\n     * @private\n     */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minArea_ = options.minArea ?? 64;\n\n    if (options.onBoxEnd) {\n      this.onBoxEnd = options.onBoxEnd;\n    }\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.startPixel_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ?? mouseActionButton;\n\n    /**\n     * @private\n     * @type {EndCondition}\n     */\n    this.boxEndCondition_ =\n      options.boxEndCondition ?? this.defaultBoxEndCondition;\n  }\n\n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\n   * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   */\n  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    const width = endPixel[0] - startPixel[0];\n    const height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  }\n\n  /**\n   * Returns geometry of last drawn box.\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\n   * @api\n   */\n  getGeometry() {\n    return this.box_.getGeometry();\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @override\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!this.startPixel_) {\n      return;\n    }\n\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n    this.dispatchEvent(\n      new DragBoxEvent(\n        DragBoxEventType.BOXDRAG,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent,\n      ),\n    );\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!this.startPixel_) {\n      return false;\n    }\n\n    const completeBox = this.boxEndCondition_(\n      mapBrowserEvent,\n      this.startPixel_,\n      mapBrowserEvent.pixel,\n    );\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(\n      new DragBoxEvent(\n        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent,\n      ),\n    );\n\n    this.box_.setMap(null);\n    this.startPixel_ = null;\n\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(\n        new DragBoxEvent(\n          DragBoxEventType.BOXSTART,\n          mapBrowserEvent.coordinate,\n          mapBrowserEvent,\n        ),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {}\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   * @override\n   */\n  setActive(active) {\n    if (!active) {\n      this.box_.setMap(null);\n      if (this.startPixel_) {\n        this.dispatchEvent(\n          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null),\n        );\n        this.startPixel_ = null;\n      }\n    }\n\n    super.setActive(active);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @override\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n\n    if (oldMap) {\n      this.box_.setMap(null);\n\n      if (this.startPixel_) {\n        this.dispatchEvent(\n          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null),\n        );\n        this.startPixel_ = null;\n      }\n    }\n\n    super.setMap(map);\n  }\n}\n\nexport default DragBox;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1576, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1582, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/DragZoom.js"],"sourcesContent":["/**\n * @module ol/interaction/DragZoom\n */\nimport {easeOut} from '../easing.js';\nimport {shiftKeyOnly} from '../events/condition.js';\nimport DragBox from './DragBox.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\n * box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {boolean} [out=false] Use interaction for zooming out.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default\n * `boxEndCondition` function.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by clicking and dragging on the map,\n * normally combined with a {@link module:ol/events/condition} that limits\n * it to when a key, shift by default, is held down.\n *\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n * your custom one configured with `className`.\n * @api\n */\nclass DragZoom extends DragBox {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const condition = options.condition ? options.condition : shiftKeyOnly;\n\n    super({\n      condition: condition,\n      className: options.className || 'ol-dragzoom',\n      minArea: options.minArea,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @override\n   */\n  onBoxEnd(event) {\n    const map = this.getMap();\n    const view = /** @type {!import(\"../View.js\").default} */ (map.getView());\n    let geometry = this.getGeometry();\n\n    if (this.out_) {\n      const rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      const resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      const factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut,\n    });\n  }\n}\n\nexport default DragZoom;\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAED;AADA;AAEA;;;;AAEA;;;;;;;;;;;;CAYC,GAED;;;;;;;;;CASC,GACD,MAAM,iBAAiB,+IAAA,CAAA,UAAO;IAC5B;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,UAAU,UAAU,UAAU,CAAC;QAE/B,MAAM,YAAY,QAAQ,SAAS,GAAG,QAAQ,SAAS,GAAG,4IAAA,CAAA,eAAY;QAEtE,KAAK,CAAC;YACJ,WAAW;YACX,WAAW,QAAQ,SAAS,IAAI;YAChC,SAAS,QAAQ,OAAO;QAC1B;QAEA;;;KAGC,GACD,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;QAErE;;;KAGC,GACD,IAAI,CAAC,IAAI,GAAG,QAAQ,GAAG,KAAK,YAAY,QAAQ,GAAG,GAAG;IACxD;IAEA;;;;GAIC,GACD,SAAS,KAAK,EAAE;QACd,MAAM,MAAM,IAAI,CAAC,MAAM;QACvB,MAAM,OAAqD,IAAI,OAAO;QACtE,IAAI,WAAW,IAAI,CAAC,WAAW;QAE/B,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,MAAM,gBAAgB,KAAK,wBAAwB,CAAC;YACpD,MAAM,aAAa,KAAK,8BAA8B,CAAC;YACvD,MAAM,SAAS,KAAK,aAAa,KAAK;YACtC,WAAW,SAAS,KAAK;YACzB,SAAS,KAAK,CAAC,SAAS;QAC1B;QAEA,KAAK,WAAW,CAAC,UAAU;YACzB,UAAU,IAAI,CAAC,SAAS;YACxB,QAAQ,+HAAA,CAAA,UAAO;QACjB;IACF;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 1656, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/defaults.js"],"sourcesContent":["/**\n * @module ol/interaction/defaults\n */\nimport Collection from '../Collection.js';\nimport Kinetic from '../Kinetic.js';\nimport DoubleClickZoom from './DoubleClickZoom.js';\nimport DragPan from './DragPan.js';\nimport DragRotate from './DragRotate.js';\nimport DragZoom from './DragZoom.js';\nimport KeyboardPan from './KeyboardPan.js';\nimport KeyboardZoom from './KeyboardZoom.js';\nimport MouseWheelZoom from './MouseWheelZoom.js';\nimport PinchRotate from './PinchRotate.js';\nimport PinchZoom from './PinchZoom.js';\n\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\n * desired.\n * @property {boolean} [onFocusOnly=false] Interact only when the map has the\n * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\n * useful when page scroll is desired for maps that do not have the browser's\n * focus.\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\n * desired.\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.\n * @property {number} [zoomDuration] Duration of the zoom animation in\n * milliseconds.\n */\n\n/**\n * Set of interactions included in maps by default. Specific interactions can be\n * excluded by setting the appropriate option to false in the constructor\n * options, but the order of the interactions is fixed.  If you want to specify\n * a different order for interactions, you will need to create your own\n * {@link module:ol/interaction/Interaction~Interaction} instances and insert\n * them into a {@link module:ol/Collection~Collection} in the order you want\n * before creating your {@link module:ol/Map~Map} instance. Changing the order can\n * be of interest if the event propagation needs to be stopped at a point.\n * The default set of interactions, in sequence, is:\n * {@link module:ol/interaction/DragRotate~DragRotate}\n * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\n * {@link module:ol/interaction/DragPan~DragPan}\n * {@link module:ol/interaction/PinchRotate~PinchRotate}\n * {@link module:ol/interaction/PinchZoom~PinchZoom}\n * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\n * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\n * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\n * {@link module:ol/interaction/DragZoom~DragZoom}\n *\n * @param {DefaultsOptions} [options] Defaults options.\n * @return {Collection<import(\"./Interaction.js\").default>}\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\n * constructor's `interactions` option.\n * @api\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Interaction.js\").default>} */\n  const interactions = new Collection();\n\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\n\n  const altShiftDragRotate =\n    options.altShiftDragRotate !== undefined\n      ? options.altShiftDragRotate\n      : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate());\n  }\n\n  const doubleClickZoom =\n    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(\n      new DoubleClickZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(\n      new DragPan({\n        onFocusOnly: options.onFocusOnly,\n        kinetic: kinetic,\n      }),\n    );\n  }\n\n  const pinchRotate =\n    options.pinchRotate !== undefined ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate());\n  }\n\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(\n      new PinchZoom({\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan());\n    interactions.push(\n      new KeyboardZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const mouseWheelZoom =\n    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(\n      new MouseWheelZoom({\n        onFocusOnly: options.onFocusOnly,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const shiftDragZoom =\n    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(\n      new DragZoom({\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  return interactions;\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;AACD;AACA;AAGA;AAFA;AACA;AAMA;AACA;AAJA;AACA;AACA;AAHA;;;;;;;;;;;;AAsDO,SAAS,SAAS,OAAO;IAC9B,UAAU,UAAU,UAAU,CAAC;IAE/B,2DAA2D,GAC3D,MAAM,eAAe,IAAI,mIAAA,CAAA,UAAU;IAEnC,MAAM,UAAU,IAAI,gIAAA,CAAA,UAAO,CAAC,CAAC,OAAO,MAAM;IAE1C,MAAM,qBACJ,QAAQ,kBAAkB,KAAK,YAC3B,QAAQ,kBAAkB,GAC1B;IACN,IAAI,oBAAoB;QACtB,aAAa,IAAI,CAAC,IAAI,kJAAA,CAAA,UAAU;IAClC;IAEA,MAAM,kBACJ,QAAQ,eAAe,KAAK,YAAY,QAAQ,eAAe,GAAG;IACpE,IAAI,iBAAiB;QACnB,aAAa,IAAI,CACf,IAAI,uJAAA,CAAA,UAAe,CAAC;YAClB,OAAO,QAAQ,SAAS;YACxB,UAAU,QAAQ,YAAY;QAChC;IAEJ;IAEA,MAAM,UAAU,QAAQ,OAAO,KAAK,YAAY,QAAQ,OAAO,GAAG;IAClE,IAAI,SAAS;QACX,aAAa,IAAI,CACf,IAAI,+IAAA,CAAA,UAAO,CAAC;YACV,aAAa,QAAQ,WAAW;YAChC,SAAS;QACX;IAEJ;IAEA,MAAM,cACJ,QAAQ,WAAW,KAAK,YAAY,QAAQ,WAAW,GAAG;IAC5D,IAAI,aAAa;QACf,aAAa,IAAI,CAAC,IAAI,mJAAA,CAAA,UAAW;IACnC;IAEA,MAAM,YAAY,QAAQ,SAAS,KAAK,YAAY,QAAQ,SAAS,GAAG;IACxE,IAAI,WAAW;QACb,aAAa,IAAI,CACf,IAAI,iJAAA,CAAA,UAAS,CAAC;YACZ,UAAU,QAAQ,YAAY;QAChC;IAEJ;IAEA,MAAM,WAAW,QAAQ,QAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG;IACrE,IAAI,UAAU;QACZ,aAAa,IAAI,CAAC,IAAI,mJAAA,CAAA,UAAW;QACjC,aAAa,IAAI,CACf,IAAI,oJAAA,CAAA,UAAY,CAAC;YACf,OAAO,QAAQ,SAAS;YACxB,UAAU,QAAQ,YAAY;QAChC;IAEJ;IAEA,MAAM,iBACJ,QAAQ,cAAc,KAAK,YAAY,QAAQ,cAAc,GAAG;IAClE,IAAI,gBAAgB;QAClB,aAAa,IAAI,CACf,IAAI,sJAAA,CAAA,UAAc,CAAC;YACjB,aAAa,QAAQ,WAAW;YAChC,UAAU,QAAQ,YAAY;QAChC;IAEJ;IAEA,MAAM,gBACJ,QAAQ,aAAa,KAAK,YAAY,QAAQ,aAAa,GAAG;IAChE,IAAI,eAAe;QACjB,aAAa,IAAI,CACf,IAAI,gJAAA,CAAA,UAAQ,CAAC;YACX,UAAU,QAAQ,YAAY;QAChC;IAEJ;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1750, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Select.js"],"sourcesContent":["/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Event from '../events/Event.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\nimport {TRUE} from '../functions.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {getUid} from '../util.js';\nimport Interaction from './Interaction.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent,\n        ),\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2148, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2154, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Modify.js"],"sourcesContent":["/**\n * @module ol/interaction/Modify\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport {equals} from '../array.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  equals as coordinatesEqual,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {\n  altKeyOnly,\n  always,\n  primaryAction,\n  singleClick,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  buffer as bufferExtent,\n  createOrUpdateFromCoordinate as createExtent,\n} from '../extent.js';\nimport Point from '../geom/Point.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport VectorSource from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {getUid} from '../util.js';\nimport PointerInteraction from './Pointer.js';\n\n/**\n * The segment index assigned to a circle's center when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CENTER_INDEX = 0;\n\n/**\n * The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\nconst tempExtent = [0, 0, 0, 0];\nconst tempSegment = [];\n\n/**\n * @enum {string}\n */\nconst ModifyEventType = {\n  /**\n   * Triggered upon feature modification start\n   * @event ModifyEvent#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ModifyEvent#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend',\n};\n\n/**\n * @typedef {Object} SegmentData\n * @property {Array<number>} [depth] Depth.\n * @property {Feature} feature Feature.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} [index] Index.\n * @property {Array<Array<number>>} segment Segment.\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\n */\n\n/**\n * @typedef {[SegmentData, number]} DragSegment\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event will be considered to add or move a\n * vertex to the sketch. Default is\n * {@link module:ol/events/condition.primaryAction}.\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. By default,\n * {@link module:ol/events/condition.singleClick} with\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\n * function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether a new vertex should be added to the sketch\n * features. Default is {@link module:ol/events/condition.always}.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style used for the modification point or vertex. For linestrings and polygons, this will\n * be the affected vertex, for circles a point along the circle, and for points the actual\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\n * When using a style function, the point feature passed to the function will have an `existing` property -\n * indicating whether there is an existing vertex underneath or not, a `features`\n * property - an array whose entries are the features that are being modified, and a `geometries`\n * property - an array whose entries are the geometries that are being modified. Both arrays are\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\n * the geometry will be the particular geometry from the collection that is being modified.\n * @property {VectorSource} [source] The vector source with\n * features to modify.  If a vector source is not provided, a feature collection\n * must be provided with the `features` option.\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\n * features will be considered for modification based on their visual appearance, instead of being within\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\n * provided, only the rendered representation of the features on that layer will be considered.\n * @property {Collection<Feature>} [features]\n * The features the interaction works on.  If a feature collection is not\n * provided, a vector source must be provided with the `source` option.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\n * pointer coordinate when clicked within the `pixelTolerance`.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\n * instances of this type.\n */\nexport class ModifyEvent extends Event {\n  /**\n   * @param {ModifyEventType} type Type.\n   * @param {Collection<Feature>} features\n   * The features modified.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, features, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being modified.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * Cartesian distance from the pointer is used to determine the features that\n * will be modified. This means that geometries will only be considered for\n * modification when they are within the configured `pixelTolerance`. For point\n * geometries, the `hitDetection` option can be used to match their visual\n * appearance.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n * @fires ModifyEvent\n * @api\n */\nclass Modify extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ModifyOnSignature<void>}\n     */\n    this.un;\n\n    /** @private */\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : primaryAction;\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n    };\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.deleteCondition_ = options.deleteCondition\n      ? options.deleteCondition\n      : this.defaultDeleteCondition_;\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.insertVertexCondition_ = options.insertVertexCondition\n      ? options.insertVertexCondition\n      : always;\n\n    /**\n     * Editing vertex.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    /**\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.vertexSegments_ = null;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.lastPixel_ = [0, 0];\n\n    /**\n     * Tracks if the next `singleclick` event should be ignored to prevent\n     * accidental deletion right after vertex creation.\n     * @type {boolean}\n     * @private\n     */\n    this.ignoreNextSingleClick_ = false;\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.featuresBeingModified_ = null;\n\n    /**\n     * Segment RTree for each layer\n     * @type {RBush<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Indicate whether the interaction is currently changing a feature's\n     * coordinates.\n     * @type {boolean}\n     * @private\n     */\n    this.changingFeature_ = false;\n\n    /**\n     * @type {Array<DragSegment>}\n     * @private\n     */\n    this.dragSegments_ = [];\n\n    /**\n     * Draw overlay where sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * @const\n     * @private\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_.bind(this),\n      'LineString': this.writeLineStringGeometry_.bind(this),\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\n      'Polygon': this.writePolygonGeometry_.bind(this),\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\n      'Circle': this.writeCircleGeometry_.bind(this),\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\n    };\n\n    /**\n     * @type {VectorSource}\n     * @private\n     */\n    this.source_ = null;\n\n    /**\n     * @type {boolean|import(\"../layer/BaseVector\").default}\n     * @private\n     */\n    this.hitDetection_ = null;\n\n    /** @type {Collection<Feature>} */\n    let features;\n    if (options.features) {\n      features = options.features;\n    } else if (options.source) {\n      this.source_ = options.source;\n      features = new Collection(this.source_.getFeatures());\n      this.source_.addEventListener(\n        VectorEventType.ADDFEATURE,\n        this.handleSourceAdd_.bind(this),\n      );\n      this.source_.addEventListener(\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceRemove_.bind(this),\n      );\n    }\n    if (!features) {\n      throw new Error(\n        'The modify interaction requires features, a source or a layer',\n      );\n    }\n    if (options.hitDetection) {\n      this.hitDetection_ = options.hitDetection;\n    }\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.features_ = features;\n\n    this.features_.forEach(this.addFeature_.bind(this));\n    this.features_.addEventListener(\n      CollectionEventType.ADD,\n      this.handleFeatureAdd_.bind(this),\n    );\n    this.features_.addEventListener(\n      CollectionEventType.REMOVE,\n      this.handleFeatureRemove_.bind(this),\n    );\n\n    /**\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @private\n     */\n    this.lastPointerEvent_ = null;\n\n    /**\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\n     * @type {Array<number>}\n     * @private\n     */\n    this.delta_ = [0, 0];\n\n    /**\n     * @private\n     */\n    this.snapToPointer_ =\n      options.snapToPointer === undefined\n        ? !this.hitDetection_\n        : options.snapToPointer;\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  addFeature_(feature) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (writer) {\n        writer(feature, geometry);\n      }\n    }\n    const map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(map.getCoordinateFromPixel(this.lastPixel_));\n    }\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @param {Array<SegmentData>} segments The segments subject to modification.\n   * @private\n   */\n  willModifyFeatures_(evt, segments) {\n    if (!this.featuresBeingModified_) {\n      this.featuresBeingModified_ = new Collection();\n      const features = this.featuresBeingModified_.getArray();\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\n        const feature = segments[i].feature;\n        if (feature && !features.includes(feature)) {\n          this.featuresBeingModified_.push(feature);\n        }\n      }\n      if (this.featuresBeingModified_.getLength() === 0) {\n        this.featuresBeingModified_ = null;\n      } else {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYSTART,\n            this.featuresBeingModified_,\n            evt,\n          ),\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeature_(feature) {\n    this.removeFeatureSegmentData_(feature);\n    // Remove the vertex feature if the collection of candidate features is empty.\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    feature.removeEventListener(\n      EventType.CHANGE,\n      this.boundHandleFeatureChange_,\n    );\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureSegmentData_(feature) {\n    const rBush = this.rBush_;\n    /** @type {Array<SegmentData>} */\n    const nodesToRemove = [];\n    rBush.forEach(\n      /**\n       * @param {SegmentData} node RTree node.\n       */\n      function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      },\n    );\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n      const nodeToRemove = nodesToRemove[i];\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\n        if (this.dragSegments_[j][0] === nodeToRemove) {\n          this.dragSegments_.splice(j, 1);\n        }\n      }\n      rBush.remove(nodeToRemove);\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   * @override\n   */\n  setActive(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    this.overlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceAdd_(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceRemove_(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    this.addFeature_(evt.element);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    if (!this.changingFeature_) {\n      const feature = /** @type {Feature} */ (evt.target);\n      this.removeFeature_(feature);\n      this.addFeature_(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    this.removeFeature_(evt.element);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {Point} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n\n    /** @type {SegmentData} */\n    const segmentData = {\n      feature: feature,\n      geometry: geometry,\n      segment: [coordinates, coordinates],\n    };\n\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        depth: [i],\n        index: i,\n        segment: [coordinates, coordinates],\n      };\n\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        index: i,\n        segment: segment,\n      };\n\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n\n          /** @type {SegmentData} */\n          const segmentData = {\n            feature: feature,\n            geometry: geometry,\n            depth: [j, k],\n            index: i,\n            segment: segment,\n          };\n\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * We convert a circle into two segments.  The segment at index\n   * {@link CIRCLE_CENTER_INDEX} is the\n   * circle's center (a point).  The segment at index\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\n   * the circumference, and is not a line segment.\n   *\n   * @param {Feature} feature Feature.\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const coordinates = geometry.getCenter();\n\n    /** @type {SegmentData} */\n    const centerSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CENTER_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    /** @type {SegmentData} */\n    const circumferenceSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = featureSegments;\n    circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection && this.getMap()) {\n      const projection = this.getMap().getView().getProjection();\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n      circleGeometry = fromCircle(\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n      ).transform(projection, userProjection);\n    }\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i];\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      writer(feature, geometry);\n    }\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {Array<Feature>} features The features being modified.\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\n   * @param {boolean} existing The vertex represents an existing vertex.\n   * @return {Feature} Vertex feature.\n   * @private\n   */\n  createOrUpdateVertexFeature_(coordinates, features, geometries, existing) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(coordinates));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(coordinates);\n    }\n    vertexFeature.set('features', features);\n    vertexFeature.set('geometries', geometries);\n    vertexFeature.set('existing', existing);\n    return vertexFeature;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n\n    let handled;\n    if (\n      !mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\n        !this.ignoreNextSingleClick_\n      ) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n\n    return super.handleEvent(mapBrowserEvent) && !handled;\n  }\n\n  findInsertVerticesAndUpdateDragSegments_(pixelCoordinate) {\n    this.handlePointerAtPixel_(pixelCoordinate);\n    this.dragSegments_.length = 0;\n    this.featuresBeingModified_ = null;\n    const vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      return;\n    }\n\n    const projection = this.getMap().getView().getProjection();\n    const insertVertices = [];\n    const vertex = vertexFeature.getGeometry().getCoordinates();\n    const vertexExtent = boundingExtent([vertex]);\n    const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n    const componentSegments = {};\n    segmentDataMatches.sort(compareIndexes);\n    for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n      const segmentDataMatch = segmentDataMatches[i];\n      const segment = segmentDataMatch.segment;\n      let uid = getUid(segmentDataMatch.geometry);\n      const depth = segmentDataMatch.depth;\n      if (depth) {\n        uid += '-' + depth.join('-'); // separate feature components\n      }\n      if (!componentSegments[uid]) {\n        componentSegments[uid] = new Array(2);\n      }\n\n      if (\n        segmentDataMatch.geometry.getType() === 'Circle' &&\n        segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\n      ) {\n        const closestVertex = closestOnSegmentData(\n          pixelCoordinate,\n          segmentDataMatch,\n          projection,\n        );\n        if (\n          coordinatesEqual(closestVertex, vertex) &&\n          !componentSegments[uid][0]\n        ) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n        }\n        continue;\n      }\n\n      if (coordinatesEqual(segment[0], vertex) && !componentSegments[uid][0]) {\n        this.dragSegments_.push([segmentDataMatch, 0]);\n        componentSegments[uid][0] = segmentDataMatch;\n        continue;\n      }\n\n      if (coordinatesEqual(segment[1], vertex) && !componentSegments[uid][1]) {\n        if (\n          componentSegments[uid][0] &&\n          componentSegments[uid][0].index === 0\n        ) {\n          let coordinates = segmentDataMatch.geometry.getCoordinates();\n          switch (segmentDataMatch.geometry.getType()) {\n            // prevent dragging closed linestrings by the connecting node\n            case 'LineString':\n            case 'MultiLineString':\n              continue;\n            // if dragging the first vertex of a polygon, ensure the other segment\n            // belongs to the closing vertex of the linear ring\n            case 'MultiPolygon':\n              coordinates = coordinates[depth[1]];\n            /* falls through */\n            case 'Polygon':\n              if (segmentDataMatch.index !== coordinates[depth[0]].length - 2) {\n                continue;\n              }\n              break;\n            default:\n            // pass\n          }\n        }\n\n        this.dragSegments_.push([segmentDataMatch, 1]);\n        componentSegments[uid][1] = segmentDataMatch;\n        continue;\n      }\n\n      if (\n        getUid(segment) in this.vertexSegments_ &&\n        !componentSegments[uid][0] &&\n        !componentSegments[uid][1]\n      ) {\n        insertVertices.push(segmentDataMatch);\n      }\n    }\n\n    return insertVertices;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @override\n   */\n  handleDragEvent(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(\n      evt,\n      this.dragSegments_.map(([segment]) => segment),\n    );\n\n    const vertex = [\n      evt.coordinate[0] + this.delta_[0],\n      evt.coordinate[1] + this.delta_[1],\n    ];\n    const features = [];\n    const geometries = [];\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n      const dragSegment = this.dragSegments_[i];\n      const segmentData = dragSegment[0];\n      const feature = segmentData.feature;\n      if (!features.includes(feature)) {\n        features.push(feature);\n      }\n      const geometry = segmentData.geometry;\n      if (!geometries.includes(geometry)) {\n        geometries.push(geometry);\n      }\n      const depth = segmentData.depth;\n      let coordinates;\n      const segment = segmentData.segment;\n      const index = dragSegment[1];\n\n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index][vertex.length]);\n      }\n\n      switch (geometry.getType()) {\n        case 'Point':\n          coordinates = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'MultiPoint':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index] = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'LineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiLineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Polygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiPolygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Circle':\n          const circle = /** @type {import(\"../geom/Circle.js\").default} */ (\n            geometry\n          );\n          segment[0] = vertex;\n          segment[1] = vertex;\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            circle.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else {\n            // We're dragging the circle's circumference:\n            this.changingFeature_ = true;\n            const projection = evt.map.getView().getProjection();\n            let radius = coordinateDistance(\n              fromUserCoordinate(circle.getCenter(), projection),\n              fromUserCoordinate(vertex, projection),\n            );\n            const userProjection = getUserProjection();\n            if (userProjection) {\n              const circleGeometry = circle\n                .clone()\n                .transform(userProjection, projection);\n              circleGeometry.setRadius(radius);\n              radius = circleGeometry\n                .transform(projection, userProjection)\n                .getRadius();\n            }\n            circle.setRadius(radius);\n            this.changingFeature_ = false;\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (coordinates) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex, features, geometries, true);\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    const pixelCoordinate = evt.coordinate;\n    const insertVertices =\n      this.findInsertVerticesAndUpdateDragSegments_(pixelCoordinate);\n\n    if (insertVertices?.length && this.insertVertexCondition_(evt)) {\n      this.willModifyFeatures_(evt, insertVertices);\n\n      if (this.vertexFeature_) {\n        const vertex = this.vertexFeature_.getGeometry().getCoordinates();\n        for (let j = insertVertices.length - 1; j >= 0; --j) {\n          this.insertVertex_(insertVertices[j], vertex);\n        }\n        this.ignoreNextSingleClick_ = true;\n      }\n    }\n\n    return !!this.vertexFeature_;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(evt) {\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n      const segmentData = this.dragSegments_[i][0];\n      const geometry = segmentData.geometry;\n      if (geometry.getType() === 'Circle') {\n        const circle = /** @type {import(\"../geom/Circle.js\").default} */ (\n          geometry\n        );\n        // Update a circle object in the R* bush:\n        const coordinates = circle.getCenter();\n        const centerSegmentData = segmentData.featureSegments[0];\n        const circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = coordinates;\n        centerSegmentData.segment[1] = coordinates;\n        circumferenceSegmentData.segment[0] = coordinates;\n        circumferenceSegmentData.segment[1] = coordinates;\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\n        /** @type {import(\"../geom/Circle.js\").default | import(\"../geom/Polygon.js\").default} */\n        let circleGeometry = circle;\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          const projection = evt.map.getView().getProjection();\n          circleGeometry = circleGeometry\n            .clone()\n            .transform(userProjection, projection);\n          circleGeometry = fromCircle(circleGeometry).transform(\n            projection,\n            userProjection,\n          );\n        }\n        this.rBush_.update(\n          circleGeometry.getExtent(),\n          circumferenceSegmentData,\n        );\n      } else {\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n      }\n    }\n    if (this.featuresBeingModified_) {\n      this.dispatchEvent(\n        new ModifyEvent(\n          ModifyEventType.MODIFYEND,\n          this.featuresBeingModified_,\n          evt,\n        ),\n      );\n      this.featuresBeingModified_ = null;\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @private\n   */\n  handlePointerMove_(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.coordinate);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate The pixel Coordinate.\n   * @private\n   */\n  handlePointerAtPixel_(pixelCoordinate) {\n    const map = this.getMap();\n    const pixel = map.getPixelFromCoordinate(pixelCoordinate);\n    const projection = map.getView().getProjection();\n    const sortByDistance = function (a, b) {\n      return (\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\n      );\n    };\n\n    /** @type {Array<SegmentData>|undefined} */\n    let nodes;\n    /** @type {Point|undefined} */\n    let hitPointGeometry;\n    if (this.hitDetection_) {\n      const layerFilter =\n        typeof this.hitDetection_ === 'object'\n          ? (layer) => layer === this.hitDetection_\n          : undefined;\n      map.forEachFeatureAtPixel(\n        pixel,\n        (feature, layer, geometry) => {\n          if (geometry && geometry.getType() === 'Point') {\n            geometry = new Point(\n              toUserCoordinate(geometry.getCoordinates(), projection),\n            );\n          }\n          const geom = geometry || feature.getGeometry();\n\n          if (\n            geom &&\n            geom.getType() === 'Point' &&\n            feature instanceof Feature &&\n            this.features_.getArray().includes(feature)\n          ) {\n            hitPointGeometry = /** @type {Point} */ (geom);\n            const coordinate = /** @type {Point} */ (feature.getGeometry())\n              .getFlatCoordinates()\n              .slice(0, 2);\n            nodes = [\n              {\n                feature,\n                geometry: hitPointGeometry,\n                segment: [coordinate, coordinate],\n              },\n            ];\n          }\n          return true;\n        },\n        {layerFilter},\n      );\n    }\n    if (!nodes) {\n      const viewExtent = fromUserExtent(\n        createExtent(pixelCoordinate, tempExtent),\n        projection,\n      );\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\n      const box = toUserExtent(\n        bufferExtent(viewExtent, buffer, tempExtent),\n        projection,\n      );\n      nodes = this.rBush_.getInExtent(box);\n    }\n\n    if (nodes && nodes.length > 0) {\n      const node = nodes.sort(sortByDistance)[0];\n      const closestSegment = node.segment;\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\n      let dist = coordinateDistance(pixel, vertexPixel);\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\n        /** @type {Object<string, boolean>} */\n        const vertexSegments = {};\n        vertexSegments[getUid(closestSegment)] = true;\n\n        if (!this.snapToPointer_) {\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\n        }\n        if (\n          node.geometry.getType() === 'Circle' &&\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry],\n            this.snappedToVertex_,\n          );\n        } else {\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          // Stop and cleanup overlay vertex feature if a segment was hit and new vertex creation is not allowed by the insertVertexCondition\n          if (\n            !this.snappedToVertex_ &&\n            !this.insertVertexCondition_(this.lastPointerEvent_)\n          ) {\n            if (this.vertexFeature_) {\n              this.overlay_.getSource().removeFeature(this.vertexFeature_);\n              this.vertexFeature_ = null;\n            }\n            return;\n          }\n          if (this.snappedToVertex_) {\n            vertex =\n              squaredDist1 > squaredDist2\n                ? closestSegment[1]\n                : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry],\n            this.snappedToVertex_,\n          );\n          const geometries = {};\n          geometries[getUid(node.geometry)] = true;\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\n            const segment = nodes[i].segment;\n            if (\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\n                coordinatesEqual(closestSegment[1], segment[1])) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n                coordinatesEqual(closestSegment[1], segment[0]))\n            ) {\n              const geometryUid = getUid(nodes[i].geometry);\n              if (!(geometryUid in geometries)) {\n                geometries[geometryUid] = true;\n                vertexSegments[getUid(segment)] = true;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  }\n\n  /**\n   * @param {SegmentData} segmentData Segment data.\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n   * @return {boolean} A vertex was inserted.\n   * @private\n   */\n  insertVertex_(segmentData, vertex) {\n    const segment = segmentData.segment;\n    const feature = segmentData.feature;\n    const geometry = segmentData.geometry;\n    const depth = segmentData.depth;\n    const index = segmentData.index;\n    let coordinates;\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n\n    switch (geometry.getType()) {\n      case 'MultiLineString':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'Polygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'MultiPolygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'LineString':\n        coordinates = geometry.getCoordinates();\n        coordinates.splice(index + 1, 0, vertex);\n        break;\n      default:\n        return false;\n    }\n\n    this.setGeometryCoordinates_(geometry, coordinates);\n    const rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index, depth, 1);\n\n    /** @type {SegmentData} */\n    const newSegmentData = {\n      segment: [segment[0], vertex],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n\n    /** @type {SegmentData} */\n    const newSegmentData2 = {\n      segment: [vertex, segment[1]],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index + 1,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    return true;\n  }\n\n  updatePointer_(coordinate) {\n    if (coordinate) {\n      this.findInsertVerticesAndUpdateDragSegments_(coordinate);\n    }\n    return this.vertexFeature_?.getGeometry().getCoordinates();\n  }\n\n  /**\n   * Get the current pointer position.\n   * @return {import(\"../coordinate.js\").Coordinate | null} The current pointer coordinate.\n   */\n  getPoint() {\n    const coordinate = this.vertexFeature_?.getGeometry().getCoordinates();\n    if (!coordinate) {\n      return null;\n    }\n    return toUserCoordinate(\n      coordinate,\n      this.getMap().getView().getProjection(),\n    );\n  }\n\n  /**\n   * Check if a point can be removed from the current linestring or polygon at the current\n   * pointer position.\n   * @return {boolean} A point can be deleted at the current pointer position.\n   * @api\n   */\n  canRemovePoint() {\n    if (!this.vertexFeature_) {\n      return false;\n    }\n    if (\n      this.vertexFeature_\n        .get('geometries')\n        .every(\n          (geometry) =>\n            geometry.getType() === 'Circle' ||\n            geometry.getType().endsWith('Point'),\n        )\n    ) {\n      return false;\n    }\n    const coordinate = this.vertexFeature_.getGeometry().getCoordinates();\n    const segments = this.rBush_.getInExtent(boundingExtent([coordinate]));\n    return segments.some(\n      ({segment}) =>\n        coordinatesEqual(segment[0], coordinate) ||\n        coordinatesEqual(segment[1], coordinate),\n    );\n  }\n\n  /**\n   * Removes the vertex currently being pointed from the current linestring or polygon.\n   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer\n   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.\n   * @return {boolean} True when a vertex was removed.\n   * @api\n   */\n  removePoint(coordinate) {\n    if (coordinate) {\n      coordinate = fromUserCoordinate(\n        coordinate,\n        this.getMap().getView().getProjection(),\n      );\n      this.updatePointer_(coordinate);\n    }\n    if (\n      !this.lastPointerEvent_ ||\n      (this.lastPointerEvent_ &&\n        this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG)\n    ) {\n      const evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(\n        evt,\n        this.dragSegments_.map(([segment]) => segment),\n      );\n      const removed = this.removeVertex_();\n      if (this.featuresBeingModified_) {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYEND,\n            this.featuresBeingModified_,\n            evt,\n          ),\n        );\n      }\n\n      this.featuresBeingModified_ = null;\n      return removed;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a vertex from all matching features.\n   * @return {boolean} True when a vertex was removed.\n   * @private\n   */\n  removeVertex_() {\n    const dragSegments = this.dragSegments_;\n    const segmentsByFeature = {};\n    let deleted = false;\n    let component, coordinates, dragSegment, geometry, i, index, left;\n    let newIndex, right, segmentData, uid;\n    for (i = dragSegments.length - 1; i >= 0; --i) {\n      dragSegment = dragSegments[i];\n      segmentData = dragSegment[0];\n      uid = getUid(segmentData.feature);\n      if (segmentData.depth) {\n        // separate feature components\n        uid += '-' + segmentData.depth.join('-');\n      }\n      if (!(uid in segmentsByFeature)) {\n        segmentsByFeature[uid] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid].right = segmentData;\n        segmentsByFeature[uid].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid].left = segmentData;\n        segmentsByFeature[uid].index = segmentData.index + 1;\n      }\n    }\n    for (uid in segmentsByFeature) {\n      right = segmentsByFeature[uid].right;\n      left = segmentsByFeature[uid].left;\n      index = segmentsByFeature[uid].index;\n      newIndex = index - 1;\n      if (left !== undefined) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates = geometry.getCoordinates();\n      component = coordinates;\n      deleted = false;\n      switch (geometry.getType()) {\n        case 'MultiLineString':\n          if (coordinates[segmentData.depth[0]].length > 2) {\n            coordinates[segmentData.depth[0]].splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'LineString':\n          if (coordinates.length > 2) {\n            coordinates.splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'MultiPolygon':\n          component = component[segmentData.depth[1]];\n        /* falls through */\n        case 'Polygon':\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index == component.length - 1) {\n              index = 0;\n            }\n            component.splice(index, 1);\n            deleted = true;\n            if (index === 0) {\n              // close the ring again\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n        const segments = [];\n        if (left !== undefined) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== undefined) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== undefined && right !== undefined) {\n          /** @type {SegmentData} */\n          const newSegmentData = {\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments,\n          };\n\n          this.rBush_.insert(\n            boundingExtent(newSegmentData.segment),\n            newSegmentData,\n          );\n        }\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n    }\n    return deleted;\n  }\n\n  /**\n   * Check if a point can be inserted to the current linestring or polygon at the current\n   * pointer position.\n   * @return {boolean} A point can be inserted at the current pointer position.\n   * @api\n   */\n  canInsertPoint() {\n    if (!this.vertexFeature_) {\n      return false;\n    }\n    if (\n      this.vertexFeature_\n        .get('geometries')\n        .every(\n          (geometry) =>\n            geometry.getType() === 'Circle' ||\n            geometry.getType().endsWith('Point'),\n        )\n    ) {\n      return false;\n    }\n    const coordinate = this.vertexFeature_.getGeometry().getCoordinates();\n    const segments = this.rBush_.getInExtent(boundingExtent([coordinate]));\n    return segments.some(\n      ({segment}) =>\n        !(\n          coordinatesEqual(segment[0], coordinate) ||\n          coordinatesEqual(segment[1], coordinate)\n        ),\n    );\n  }\n\n  /**\n   * Inserts the vertex currently being pointed to the current linestring or polygon.\n   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer\n   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.\n   * @return {boolean} A vertex was inserted.\n   * @api\n   */\n  insertPoint(coordinate) {\n    const pixelCoordinate = coordinate\n      ? fromUserCoordinate(coordinate, this.getMap().getView().getProjection())\n      : this.vertexFeature_?.getGeometry().getCoordinates();\n    if (!pixelCoordinate) {\n      return false;\n    }\n    const insertVertices =\n      this.findInsertVerticesAndUpdateDragSegments_(pixelCoordinate);\n    return insertVertices.reduce(\n      (prev, segmentData) =>\n        prev || this.insertVertex_(segmentData, pixelCoordinate),\n      false,\n    );\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {Array} coordinates Coordinates.\n   * @private\n   */\n  setGeometryCoordinates_(geometry, coordinates) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates);\n    this.changingFeature_ = false;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {number} index Index.\n   * @param {Array<number>|undefined} depth Depth.\n   * @param {number} delta Delta (1 or -1).\n   * @private\n   */\n  updateSegmentIndices_(geometry, index, depth, delta) {\n    this.rBush_.forEachInExtent(\n      geometry.getExtent(),\n      function (segmentDataMatch) {\n        if (\n          segmentDataMatch.geometry === geometry &&\n          (depth === undefined ||\n            segmentDataMatch.depth === undefined ||\n            equals(segmentDataMatch.depth, depth)) &&\n          segmentDataMatch.index > index\n        ) {\n          segmentDataMatch.index += delta;\n        }\n      },\n    );\n  }\n}\n\n/**\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {SegmentData} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction projectedDistanceToSegmentDataSquared(\n  pointCoordinates,\n  segmentData,\n  projection,\n) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === 'Circle') {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        circleGeometry = circleGeometry\n          .clone()\n          .transform(userProjection, projection);\n      }\n      const distanceToCenterSquared = squaredCoordinateDistance(\n        circleGeometry.getCenter(),\n        fromUserCoordinate(pointCoordinates, projection),\n      );\n      const distanceToCircumference =\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return squaredDistanceToSegment(coordinate, tempSegment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {SegmentData} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\n  const geometry = segmentData.geometry;\n\n  if (\n    geometry.getType() === 'Circle' &&\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\n  ) {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    return toUserCoordinate(\n      circleGeometry.getClosestPoint(\n        fromUserCoordinate(pointCoordinates, projection),\n      ),\n      projection,\n    );\n  }\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return toUserCoordinate(\n    closestOnSegment(coordinate, tempSegment),\n    projection,\n  );\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\nexport default Modify;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3535, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Thesis/UCWAYS/UCLM_OpenLayersMapping/node_modules/ol/interaction/Draw.js"],"sourcesContent":["/**\n * @module ol/interaction/Draw\n */\nimport Feature from '../Feature.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport Circle from '../geom/Circle.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport VectorSource from '../source/Vector.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport PointerInteraction from './Pointer.js';\nimport InteractionProperty from './Property.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex,\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count,\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count,\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n        ? 3\n        : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n          ? options.maxPoints\n          : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = (coordinates, geometry, projection) => {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_,\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = (coordinates, geometry, projection) => {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_,\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   * @override\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState,\n        ),\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_,\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex,\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex,\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout(),\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates(),\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection,\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection,\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      return this.finishDrawing();\n    }\n    return this.sketchFeature_;\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry),\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return null;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.sketchFeature_ = this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection,\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection,\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle,\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      }),\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}